<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE stax SYSTEM "stax.dtd">

<!--

  File Name:    STAFTest.xml
  Description:  This STAX xml job tests STAF V3.4.16 and STAX V3.5.8
-->

<stax>

  <!-- Beginning of job -->

  <defaultcall function="DoAll"/>

  <!-- Default variables -->

  <script>
    # Whether we should debug things
    debug = 0

    # TestMachines should be set to a list of machines to test

    TestMachines = ['local']
    
    # TestScopes should be set to None if All tests should be run, otherwise
    # it should be set to a list of test scopes (e.g. ['SERVICE', 'FS']
    # Here's a list of all of the valid test scopes:
    # [ 'CONFIG', 'DELAY', 'DEVICE_C++', 'DEVICE_Java', 'DIAG', 'ECHO', 'EVENT', 'EXECPROXY',
    #   'FS', 'HANDLE', 'HELP', 'LIFECYCLE', 'LOG', 'MISC', 'MONITOR', 'OTHER', 'PING',
    #   'PROCESS', 'QUEUE', 'RESPOOL', 'SEM', 'SERVICE', 'SHUTDOWN', 'STAX', 'TRACE',
    #   'TRUST', 'VAR', 'ZIP', 'FTP' ]
    TestScopes = None
    
    # Set to a true value to run the STAX and EVENT tests (if included in
    # the TestScopes or if TestScopes is set to None to run all tests.
    # They'll only run on the local machine.
    RunSTAXAndEventTests = 1
    
    # Set to a true value to run the FTP tests (if included in the TestScopes
    # or if TestScopes is set to None to run all tests.
    # They'll only run if the test machine provides STAF Java support.
    RunFtpTests = 1

    # Set the endpoint of the FTP machine (staf4g) where the STAF builds for STAF
    # and its services are stored so can use in a FS COPY request to get the FTP
    # service zip/tar file.
    FtpMachine = 'tcp://9.3.211.227@6500'
    FtpBuildDir = '/root/build'      # Directory containing the STAF service sub-directories
    FtpServiceVersion = '103'     # Set to the version of the FTP service to test

    # ImportMachine should be set to the machine where STAXUtil.xml resides
    # (e.g. 'local' if the file resides on the STAX service machine).
    # ImportDirectory should be set to the directory which contains STAXUtil.xml.
    ImportMachine = 'local'
    ImportDirectory = '{STAF/Config/STAFRoot}/services/stax/libraries'
    #ImportDirectory = 'C:/dev/sf/src/staf/services/stax/libraries'
    
    # Set AutomationTestDir to the location where STAFTest.xml is being run from
    import os.path
    AutomationTestDir = os.path.dirname(STAXJobXMLFile)
    # Want to use forward slash not backward slash in directory name
    AutomationTestDir = 'C:/automation/test'

    # EventJarFile should be set to the STAFEvent.jar file on the STAX service machine.
    # DeviceServiceJarFile should be set to the STAFDeviceService.jar file on the STAX service machine

    EventJarFile = '{STAF/Config/STAFRoot}/services/stax/STAFEvent.jar'
    # DeviceServiceJarFile = '{STAF/Config/STAFRoot}/services/STAFDeviceService.jar'
    DeviceServiceJarFile = '{STAF/Config/STAFRoot}/lib/STAFDeviceService.jar'

    # Set the registered names for the external services being tested
    ResPoolService = 'RESPOOL'
    LogService = 'LOG'
    MonitorService = 'MONITOR'
    STAXService = 'STAX'
    EventService = 'Event'
    ZipService = 'ZIP'

    # To register a STAF Java service on a HPUX IA-64 64-bit machine using a 64-bit JVM,
    # need to set RequiredJVMOptions =  'OPTION J2=-d64'
    RequiredJVMOptions = ''

    # Timer duration for each STAF command to prevent STAFTest for hanging forever
    # on some commands like SERVICE ADD for a Java service on Solaris sparc64/x64.
    stafcmd_timeout = '15m'

    # Set these to some default values, just in case

    STAFResult = ''
    RC = 0

  </script>
 
  <!-- Import necessary utilities -->

  <script>
    import re
    import string

    from com.ibm.staf import STAFUtil

    # Test if set a variable named 'copy' that this doesn't break the STAXPythonFunction_CloneGlobals
    # function that uses the copy module when the creation of a new STAX-Thread clones variables.
    copy = 'XXX'
  </script>

  <!-- Start function definitions -->


  <!-- ================================================================= -->
  <!-- InitTests - This function initializes all the test information    -->
  <!-- ================================================================= -->

  <function name="InitTests">
    <sequence>

      <script>

        allTests = []

        # Whenever you add a new Test Scope, need to add a Init Function and then
        # add it to the following map, using the Test Scope as the key, e.g. 'VAR',
        # and the name of the Init Function as its value.

        # An Init Function should assign a list of tests to run.  The format of
        # each test entry is the list is a list of the following:
        #
        #   1) 'STD:' + the service being tested (capitalized)
        #      This is a required entry in the list.
        #
        #   2) Service to which the request will be submitted to
        #      This is a required entry in the list.
        #
        #   3) Request to be submitted
        #      This is a required entry in the list.
        #
        #   4) A list of the STAF return codes that indicate a success
        #      This is a required entry in the list.
        #
        #   5) A regular expression (re) string to be compared with the STAFResult
        #      if the STAF return indicates a success or None if no compare should
        #      be performed on the STAFResult using re.
        #      This is a required entry in the list.
        #
        #   6) A string containing Python expression to be evaluated.
        #      If it evaluates to true, this indicates a test success.
        #      This is especially useful if the STAFResult is a marshalled object
        #      so that you can specify what determines a successful STAFResult.
        #      This is an optional entry in the list.
        #
        #   7) Python code to be executed.
        #      This is especially useful if you want to assign one or more
        #      variables from the STAFResult to be used in a following test.
        #      This is an optional entry in the list.
        #
        # Examples:
        #
        # [ 'STD:LOG', 'LOG', 'DELETE GLOBAL LOGNAME staftest CONFIRM',
        #   [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        # ],
        #
        # [ 'STD:LOG', 'LOG', 'QUERY GLOBAL LOGNAME {STAFTest/LogName} NAME {STAFTest/HName} total',
        #   [ STAFRC.Ok ],
        #   r"""(?mx)
        #       ^3\s*"""
        # ],
        # [ 'STD:LOG', 'LOG', 'QUERY GLOBAL LOGNAME staftest CONTAINS {STAFTest/LogContains} CONTAINS TUESDAY FIRST 2 LEVELBITSTRING',
        #   [ STAFRC.Ok ], None,
        #   "len(STAFResult) == 2 and " +
        #   "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
        #   "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        # ],
        #
        # Also, the first test should request a mutex semaphore specifying a unique
        # name to identify the set of tests, e.g. 'STAFTest/' + service being tested.
        # And, the last test should release the mutex semaphore.  Be sure to add name
        # of the mutex semaphore to the SemMutexList defined in function
        # 'InitTestMachine' so that any mutex semaphores are left over from a previous
        # run are deleted.

        InitTestMap = {
                        'PING':        'InitPINGTests',
                        'ECHO':        'InitECHOTests',
                        'DELAY':       'InitDELAYTests',
                        'SHUTDOWN':    'InitSHUTDOWNTests',
                        'DIAG':        'InitDIAGTests',
                        'SERVICE':     'InitSERVICETests',
                        'MISC':        'InitMISCTests',
                        'HELP':        'InitHELPTests',
                        'TRACE':       'InitTRACETests',
                        'TRUST':       'InitTRUSTTests',
                        'FS':          'InitFSTests',
                        'VAR':         'InitVARTests',
                        'QUEUE':       'InitQUEUETests',
                        'PROCESS':     'InitPROCESSTests',
                        'HANDLE':      'InitHANDLETests',
                        'SEM':         'InitSEMTests',
                        'LIFECYCLE':   'InitLIFECYCLETests',
                        'CONFIG':      'InitCONFIGTests',
                        'LOG':         'InitLOGTests',
                        'MONITOR':     'InitMONITORTests',
                        'RESPOOL':     'InitRESPOOLTests',
                        'ZIP':         'InitZIPTests',
                        'INSTALL':     'InitINSTALLTests',
                        'EXECPROXY':   'InitEXECPROXYTests',
                        'OTHER':       'InitOTHERTests',
                        # Comment out by default since not distributed with STAF, only build machines will have the C++ Device service
                        #'DEVICE_C++':  'InitDEVICECTests',
                        'DEVICE_Java': 'InitDEVICEJavaTests'
                        # XXX: Comment out until Perl Services work
                        #'DEVICE_PERL': 'InitDEVICEPerlTests'
                      }

        if RunSTAXAndEventTests:
          InitTestMap['STAX'] = 'InitSTAXTests'     # Add new entry to map
          InitTestMap['EVENT'] = 'InitEVENTTests'   # Add new entry to map

        if RunFtpTests:
          InitTestMap['FTP'] = 'InitFTPTests' # Add new entry to map
      </script>

      <if expr="TestScopes">
        <script>TestsToRun = TestScopes</script>
        <else>
          <script>TestsToRun = InitTestMap.keys()</script>
        </else>
      </if>

      <iterate var="TestScope" in="TestsToRun">
        <sequence>

          <message log="1">
            'Initializing %s tests on machine %s via function %s...' % \
            (TestScope, TestMach, InitTestMap[TestScope])
          </message>

          <call function="InitTestMap[TestScope]"/>

          <script>
            allTests = allTests + STAXResult
          </script>

        </sequence>
      </iterate>

    </sequence>
  </function>


  <!--  Start of Test List Definitionss for the different Test Scopes -->


  <!-- ========================================================================== -->
  <!-- InitPingTests - This function initializes all the PING test information    -->
  <!-- ========================================================================== -->

  <function name="InitPINGTests" scope="local">
    <sequence>

      <script>

      PINGTests = [

        #
        # PING tests
        #

        [ 'STD:PING', 'SEM',  'REQUEST MUTEX STAFTest/PING',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PING', 'PING', 'HELP',
          [ STAFRC.Ok ], '.*'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:PING', 'PING', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:PING', 'PING', 'PING',
          [ STAFRC.Ok ], 'PONG'
        ],

        # Make sure the request strips any whitespace
        [ 'STD:PING', 'PING', ' PING ',
          [ STAFRC.Ok ], 'PONG'
        ],

        [ 'STD:PING', 'ping', 'ping',
          [ STAFRC.Ok ], 'PONG'
        ],

        # Test invalid request
        [ 'STD:PING', 'PING', 'PONG',
          [ STAFRC.InvalidRequestString ], None
        ],

        # Test invalid service name
        [ 'STD:PING', 'PONG', 'PING',
          [ STAFRC.UnknownService ], None
        ],

        [ 'STD:PING', 'PING', 'PING MACHINE %s' % (TestMach),
          [ STAFRC.Ok ], 'PONG'
        ],

        [ 'STD:PING', 'VAR', 'SET VAR STAFTest/PingMachine=local',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PING', 'PING', 'PING MACHINE {STAFTest/PingMachine}',
          [ STAFRC.Ok ], 'PONG'
        ],

        # Clean-up
        [ 'STD:PING', 'VAR', 'DELETE VAR STAFTest/PingMachine',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PING', 'SEM', 'RELEASE MUTEX STAFTest/PING',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>PINGTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitEchoTests - This function initializes all the ECHO test information    -->
  <!-- ========================================================================== -->

  <function name="InitECHOTests" scope="local">
    <sequence>

      <script>

      ECHOTests = [

        #
        # ECHO tests
        #

        [ 'STD:ECHO', 'SEM',  'REQUEST MUTEX STAFTest/ECHO',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ECHO', 'ECHO', 'HELP',
          [ STAFRC.Ok ], r'.*'
        ],
        
        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:ECHO', 'ECHO', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:ECHO', 'ECHO', 'ECHO Hello World',
          [ STAFRC.Ok ], 'Hello World'
        ],

        [ 'STD:ECHO', 'ECHO', 'ECHO "Hello World"',
          [ STAFRC.Ok ], '"Hello World"'
        ],

        # Test invalid request
        [ 'STD:ECHO', 'ECHO', 'INVALID',
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:ECHO', 'SEM',  'RELEASE MUTEX STAFTest/ECHO',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>ECHOTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitDelayTests - This function initializes all the DELAY test information  -->
  <!-- ========================================================================== -->

  <function name="InitDELAYTests" scope="local">
    <sequence>

      <!-- Test that garbage collection occurs when the handle that submitted a DELAY WAIT request is unregistered
            - First test using a regular STAF handle
            - Then test using a static STAF handle
         -->

      <testcase name="'DELAY'">
        <sequence>

          <message>
            'DELAY: Verify when a STAF handle is unregistered, any pending DELAY WAIT ' + \
            'requests it submitted will fail with RC 56 (Request Cancelled)'
          </message>

          <script> 
            # Create a STAF handle 
            from com.ibm.staf import STAFHandle 
            myHandle = STAFHandle("STAFTest/DelayTest") 
            request = 'DELAY 5m'
          </script>
          <message>
            'DELAY: Created STAF handle: %s' % (myHandle.handle)
          </message>

          <!-- Use this handle to submit a "STAF TestMach DELAY DELAY 5m" request and
                while this request is waiting, unregister the handle that submitted this request 
                and verify that the request then fails with RC 56 (Request Cancelled) -->
          <parallel>

            <sequence>
              <script>
                # Use this handle to submit a STAF TestMach DELAY DELAY 5m request 
                result = myHandle.submit2(TestMach, 'DELAY', request) 
              </script>
              <call function="'STAXUtilCheckSuccess'">
                { 'result': result.rc == STAFRC.RequestCancelled,
                  'passMsg': 'DELAY: Cancelled DELAY request submitted by handle %s' % (myHandle.handle), 
                  'failMsg': "DELAY: myHandle.submit2(%s, 'DELAY', %s)" % (TestMach, request) + \
                               '\n  Expected RC: %s\n  Got RC: %s, STAFResult: %s' % \
                               (STAFRC.RequestCancelled, result.rc, result.result),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>
            </sequence>

            <sequence>
              <script>
                # Wait for 3 seconds and then unregister the STAF handle that submitted the DELAY WAIT request
                import time
                time.sleep(3)

                errMsg = None
                try:
                  myHandle.unRegister()
                except:
                  errMsg = 'Error unregistering STAF handle %s' % (myHandle.handle)
              </script>
              <if expr="errMsg == None">
                <message>
                  'DELAY: Unregistered STAF handle %s that submitted: STAF %s DELAY %s' % \
                  (myHandle.handle, TestMach, request)
                </message>
                <else>
                  <call function="'STAXUtilCheckSuccess'">
                    { 'result': 0 == 1,
                      'failMsg': 'DELAY: %s' % (errMsg),
                      'sendToMonitor': 1,
                      'recordStatus': 1 }
                  </call>
                </else>
              </if>
            </sequence>

          </parallel>

          <message>
            'DELAY: Verify when a static STAF handle is deleted, any pending DELAY WAIT ' + \
            'requests it submitted will fail with RC 56 (Request Cancelled)'
          </message>

          <stafcmd name="'Create a static STAF handle'">
            <location>'local'</location>
            <service>'HANDLE'</service>
            <request>'CREATE HANDLE NAME STAFTest/DelayTest/Static'</request>
          </stafcmd>

          <if expr="RC == STAFRC.Ok">
            <sequence>

              <script>
                # Get a STAFHandle for the static handle just created
                staticHandleNumber = int(STAFResult)
                staticHandle = STAFHandle(staticHandleNumber)
                request = 'DELAY 5m'
              </script>

              <!-- Use this static handle to submit a "STAF TestMach DELAY DELAY 5m" request and
                    while this request is waiting, unregister the handle that submitted this request 
                    and verify that the request then fails with RC 56 (Request Cancelled) -->
              <parallel>

                <sequence>
                  <message>
                    'DELAY: Created static STAF handle: %s' % (staticHandleNumber)
                  </message>
                  <script> 
                    # Use this static handle to submit a STAF TestMach DELAY DELAY 5m request 
                    result = staticHandle.submit2(TestMach, 'DELAY', request) 
                  </script>
                  <call function="'STAXUtilCheckSuccess'">
                    { 'result': result.rc == STAFRC.RequestCancelled,
                      'passMsg': 'DELAY: Cancelled DELAY request submitted by handle %s' % (staticHandleNumber), 
                      'failMsg': "DELAY: staticHandle.submit2('%s', 'DELAY', '%s')" % (TestMach, request) + \
                                    '\n  Expected RC: %s\n  Got RC: %s, STAFResult: %s' % \
                                    (STAFRC.RequestCancelled, result.rc, result.result),
                      'sendToMonitor': 1,
                      'recordStatus': 1 }
                  </call>
                </sequence>

                <sequence>
                  <script>
                    # Wait for 3 seconds and then delete the static STAF handle that submitted the DELAY WAIT request
                    import time
                    time.sleep(3)
                  </script>

                  <stafcmd name="'Delete static handle STAFTest/DelayTest/Static'">
                    <location>'local'</location>
                    <service>'HANDLE'</service>
                    <request>'DELETE HANDLE %s' % (staticHandleNumber)</request>
                  </stafcmd>

                  <call function="'STAXUtilCheckSuccess'">
                    { 'result': RC == STAFRC.Ok,
                      'failMsg': 'DELAY: STAF local HANDLE DELETE HANDLE %s' % (staticHandleNumber) + \
                                   '\n  Expected RC: %s\n  Got RC: %s, STAFResult: %s' % \
                                   (STAFRC.Ok, RC, STAFResult),
                      'sendToMonitor': 1,
                      'recordStatus': 1 }
                  </call>
                  
                  <message>
                    'DELAY: Unregistered static STAF handle %s that submitted:  STAF %s DELAY %s' % \
                    (staticHandleNumber, TestMach, request)
                  </message>
                </sequence>

              </parallel>

            </sequence>
            <else>
              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'DELAY: STAF local HANDLE CREATE HANDLE NAME STAFTest/DelayTest/Static' % + \
                               '\n  Expected RC: %s\n  Got RC: %s, STAFResult: %s' % \
                               (STAFRC.Ok, RC, STAFResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>
            </else>
          </if>

        </sequence>
      </testcase>

      <script>
      DELAYTests = [

        #
        # DELAY tests
        #

        [ 'STD:DELAY', 'SEM',  'REQUEST MUTEX STAFTest/DELAY',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DELAY', 'DELAY', 'HELP',
          [ STAFRC.Ok ], r'.*'
        ],
        
        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:DELAY', 'DELAY', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:DELAY', 'DELAY', 'DELAY 1000',
          [ STAFRC.Ok ], r'^$'
        ],

        # Test invalid request
        [ 'STD:DELAY', 'DELAY', 'INVALID',
          [ STAFRC.InvalidRequestString ], None
        ],
        
        # Test invalid request - The DELAY option requires a value
        [ 'STD:DELAY', 'DELAY', 'DELAY',
          [ STAFRC.InvalidRequestString ], None
        ],

        # Test invalid DELAY value -- doesn't follow format of Number[s | m | h | d | w]

        [ 'STD:DELAY', 'DELAY', 'DELAY x',
          [ STAFRC.InvalidValue ], None
        ],
        
        [ 'STD:DELAY', 'DELAY', 'DELAY 1y',
          [ STAFRC.InvalidValue ], None
        ],

       # Test invalid DELAY values -- too large

        [ 'STD:DELAY', 'DELAY', 'DELAY 9999999999999999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:DELAY', 'DELAY', 'DELAY 9999999w',
          [ STAFRC.InvalidValue ], None
        ],

        # Test valid DELAY values

        [ 'STD:DELAY', 'DELAY', 'DELAY 1s',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:DELAY', 'DELAY', 'DELAY 0000000000000000000000000',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:DELAY', 'DELAY', 'DELAY 0000000000000000000000000w',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:DELAY', 'SEM',  'RELEASE MUTEX STAFTest/DELAY',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>DELAYTests</return>

    </sequence>
  </function>


  <!-- ================================================================================ -->
  <!-- InitSHUTDOWNTests - This function initializes all the SHUTDOWN test information  -->
  <!-- ================================================================================ -->

  <function name="InitSHUTDOWNTests" scope="local">
    <sequence>

      <script>

      SHUTDOWNTests = [

        #
        # SHUTDOWN tests
        #

        [ 'STD:SHUTDOWN', 'SEM',      'REQUEST MUTEX STAFTest/SHUTDOWN',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'HELP',
          [ STAFRC.Ok ], r'.*'
        ],
        
        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY REGISTER MACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'.*'
        ],

        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['priority'] == '5' and " +
          "STAFResult[0]['machine'] and " +
          "STAFResult[0]['notifyBy'] == 'Handle' and " +
          "string.atoi(STAFResult[0]['notifiee']) > 0"
        ],

        # Make sure that the values for MACHINE, NAME, and PRIORITY are being resolved for STAF variables correctly
        [ 'STD:SHUTDOWN', 'VAR',      'SET VAR STAFTest/Shutdown/Machine=%s VAR STAFTest/Shutdown/Name=ShutdownCatcher VAR STAFTest/Shutdown/Priority=3' % (STAXMachine),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY REGISTER MACHINE {STAFTest/Shutdown/Machine} NAME {STAFTest/Shutdown/Name} PRIORITY {STAFTest/Shutdown/Priority}',
          [ STAFRC.Ok ], r'.*'
        ],

        # If an invalid value is specified for handle#, verify that an InvalidValue is returned
        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY REGISTER HANDLE 0',
          [ STAFRC.InvalidValue], r'.*'
        ],
        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY REGISTER HANDLE 2147483648',
          [ STAFRC.InvalidValue], r'.*'
        ],
        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY REGISTER HANDLE -1',
          [ STAFRC.InvalidValue], r'.*'
        ],

        # If an invalid value is specified for priority#, verify that an InvalidValue is returned
        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY REGISTER PRIORITY -1',
          [ STAFRC.InvalidValue], r'.*'
        ],
        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY REGISTER HANDLE 9999999999',
          [ STAFRC.InvalidValue], r'.*'
        ],

        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[1]['priority'] == '3' and " +
          "STAFResult[1]['machine'] and " +
          "STAFResult[1]['notifyBy'] == 'Name' and " +
          "STAFResult[1]['notifiee'] == 'ShutdownCatcher'"
        ],

        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY UNREGISTER MACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SHUTDOWN', 'SHUTDOWN', 'NOTIFY UNREGISTER MACHINE {STAFTest/Shutdown/Machine} NAME {STAFTest/Shutdown/Name} PRIORITY {STAFTest/Shutdown/Priority}',
          [ STAFRC.Ok ], r'^$'
        ],

        # Clean-up
        [ 'STD:SHUTDOWN', 'VAR',      'DELETE VAR STAFTest/Shutdown/Machine VAR STAFTest/Shutdown/Name VAR STAFTest/Shutdown/Priority',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SHUTDOWN', 'SEM',      'RELEASE MUTEX STAFTest/SHUTDOWN',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>SHUTDOWNTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitDIAGTests - This function initializes all the DIAG test information  -->
  <!-- ========================================================================== -->

  <function name="InitDIAGTests" scope="local">
    <sequence>

      <script>
      if testMachineIsLocal:
        recordRCIfNotEnabled = STAFRC.DiagnosticsNotEnabled  # Diagnostics not enabled
      else:
        recordRCIfNotEnabled = STAFRC.AccessDenied  # Insufficient Trust
      </script>

      <script>

      DIAGTests = [

        #
        # DIAG tests
        #

        [ 'STD:DIAG', 'SEM',  'REQUEST MUTEX STAFTest/DIAG',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],
        
        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:DIAG', 'DIAG', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:DIAG', 'DIAG', 'DISABLE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['diagnostics'] == 'Disabled' and " +
          "(STAFResult['lastResetTimestamp'] == None or " +
          " STAFResult['lastResetTimestamp']) and " +
          "STAFResult['lastDisabledTimestamp']"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST',
          [ STAFRC.Ok ], None,
          "(STAFResult['fromTimestamp'] == None or " +
          " STAFResult['fromTimestamp']) and " +
          "STAFResult['toTimestamp'] and " +
          "(STAFResult['elapsedTime'] == None or " +
          " STAFResult['elapsedTime']) and " +
          "STAFResult['numberOfTriggers'] and " +
          "STAFResult['numberOfSources'] and " +
          "len(STAFResult['comboList']) == 0"
        ],

        # Make sure get "Diagnostics Not Enabled" error when try to record with
        # diagnostics disabled or trust error if not local machine
        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER abc SOURCE myApp;myMachine;25',
          [ recordRCIfNotEnabled ], None
        ],

        [ 'STD:DIAG', 'DIAG', 'ENABLE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['diagnostics'] == 'Enabled' and " +
          "STAFResult['lastDisabledTimestamp'] and " +
          "STAFResult['lastResetTimestamp']"
        ],

        [ 'STD:DIAG', 'DIAG', 'RESET FORCE',
          [ STAFRC.Ok ], r'^$'
        ]

        ]
      </script>

      <!--  Only can record diagnostics if local machine -->
      <if expr="testMachineIsLocal">
        <script>

        DIAGTests = DIAGTests + [

        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER abc SOURCE myApp;myMachine;25',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST',
          [ STAFRC.Ok ], None,
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfTriggers'] and " +
          "STAFResult['numberOfSources'] and " +
          "len(STAFResult['comboList']) > 0 and " +
          "STAFResult['comboList'][0]['count'] == '1' and " +
          "STAFResult['comboList'][0]['trigger'] == 'abc' and " +
          "STAFResult['comboList'][0]['source'] == 'myApp;myMachine;25'"
        ],

        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER abc SOURCE myApp;myMachine;25',
          [ STAFRC.Ok ], r'^$'
        ],

        # Make sure that the values for TRIGGER and SOURCE are being resolved for STAF variables correctly
        [ 'STD:DIAG', 'VAR',  'SET VAR STAFTest/trigger=aaa VAR "STAFTest/source=yourApp;myMachine;43"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER {STAFTest/trigger} SOURCE {STAFTest/source}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'VAR',  'DELETE VAR STAFTest/trigger VAR STAFTest/source',
          [ STAFRC.Ok ], r'^$'
        ],

        # Make sure an error is returned if specify a STAF variable that doesn't exist
        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER {nonExistingVar} SOURCE myMachine',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],

        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER xyz SOURCE {nonExistingVar}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],

        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER abb SOURCE yourApp;myMachine;43',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER abb SOURCE yourApp;myMachine;43',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER abb SOURCE yourApp;myMachine;43',
         [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'RECORD TRIGGER abb SOURCE myApp;myMachine;25',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SORTBYCOUNT',
          [ STAFRC.Ok ], None,
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfTriggers'] == '3' and " +
          "STAFResult['numberOfSources'] == '2' and " +
          "len(STAFResult['comboList']) > 0 and " +
          "STAFResult['comboList'][0]['count'] == '3' and " +
          "STAFResult['comboList'][0]['trigger'] == 'abb' and " +
          "STAFResult['comboList'][0]['source'] == 'yourApp;myMachine;43' and " +
          "STAFResult['comboList'][1]['count'] == '2' and " +
          "STAFResult['comboList'][1]['trigger'] == 'abc' and " +
          "STAFResult['comboList'][1]['source'] == 'myApp;myMachine;25' and " +
          "STAFResult['comboList'][2]['count'] == '1' and " +
          "STAFResult['comboList'][2]['trigger'] == 'aaa' and " +
          "STAFResult['comboList'][2]['source'] == 'yourApp;myMachine;43' and " +
          "STAFResult['comboList'][3]['count'] == '1' and " +
          "STAFResult['comboList'][3]['trigger'] == 'abb' and " +
          "STAFResult['comboList'][3]['source'] == 'myApp;myMachine;25'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SORTBYTRIGGER',
          [ STAFRC.Ok ], None,
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfTriggers'] == '3' and " +
          "STAFResult['numberOfSources'] == '2' and " +
          "STAFResult['comboList'][0]['count'] == '1' and " +
          "STAFResult['comboList'][0]['trigger'] == 'aaa' and " +
          "STAFResult['comboList'][0]['source'] == 'yourApp;myMachine;43' and " +
          "STAFResult['comboList'][1]['count'] == '1' and " +
          "STAFResult['comboList'][1]['trigger'] == 'abb' and " +
          "STAFResult['comboList'][1]['source'] == 'myApp;myMachine;25' and " +
          "STAFResult['comboList'][2]['count'] == '3' and " +
          "STAFResult['comboList'][2]['trigger'] == 'abb' and " +
          "STAFResult['comboList'][2]['source'] == 'yourApp;myMachine;43' and " +
          "STAFResult['comboList'][3]['count'] == '2' and " +
          "STAFResult['comboList'][3]['trigger'] == 'abc' and " +
          "STAFResult['comboList'][3]['source'] == 'myApp;myMachine;25'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SORTBYSOURCE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfTriggers'] == '3' and " +
          "STAFResult['numberOfSources'] == '2' and " +
          "STAFResult['comboList'][0]['count'] == '1' and " +
          "STAFResult['comboList'][0]['trigger'] == 'abb' and " +
          "STAFResult['comboList'][0]['source'] == 'myApp;myMachine;25' and " +
          "STAFResult['comboList'][1]['count'] == '2' and " +
          "STAFResult['comboList'][1]['trigger'] == 'abc' and " +
          "STAFResult['comboList'][1]['source'] == 'myApp;myMachine;25' and " +
          "STAFResult['comboList'][2]['count'] == '1' and " +
          "STAFResult['comboList'][2]['trigger'] == 'aaa' and " +
          "STAFResult['comboList'][2]['source'] == 'yourApp;myMachine;43' and " +
          "STAFResult['comboList'][3]['count'] == '3' and " +
          "STAFResult['comboList'][3]['trigger'] == 'abb' and " +
          "STAFResult['comboList'][3]['source'] == 'yourApp;myMachine;43'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST TRIGGERS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfTriggers'] == '3' and " +
          "STAFResult['triggerList'][0]['count'] == '4' and " +
          "STAFResult['triggerList'][0]['trigger'] == 'abb' and " +
          "STAFResult['triggerList'][1]['count'] == '2' and " +
          "STAFResult['triggerList'][1]['trigger'] == 'abc' and " +
          "STAFResult['triggerList'][2]['count'] == '1' and " +
          "STAFResult['triggerList'][2]['trigger'] == 'aaa'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST TRIGGERS SORTBYCOUNT',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfTriggers'] == '3' and " +
          "STAFResult['triggerList'][0]['count'] == '4' and " +
          "STAFResult['triggerList'][0]['trigger'] == 'abb' and " +
          "STAFResult['triggerList'][1]['count'] == '2' and " +
          "STAFResult['triggerList'][1]['trigger'] == 'abc' and " +
          "STAFResult['triggerList'][2]['count'] == '1' and " +
          "STAFResult['triggerList'][2]['trigger'] == 'aaa'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST TRIGGERS SORTBYTRIGGER',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfTriggers'] == '3' and " +
          "STAFResult['triggerList'][0]['count'] == '1' and " +
          "STAFResult['triggerList'][0]['trigger'] == 'aaa' and " +
          "STAFResult['triggerList'][1]['count'] == '4' and " +
          "STAFResult['triggerList'][1]['trigger'] == 'abb' and " +
          "STAFResult['triggerList'][2]['count'] == '2' and " +
          "STAFResult['triggerList'][2]['trigger'] == 'abc'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SOURCES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfSources'] == '2' and " +
          "STAFResult['sourceList'][0]['count'] == '4' and " +
          "STAFResult['sourceList'][0]['source'] == 'yourApp;myMachine;43' and " +
          "STAFResult['sourceList'][1]['count'] == '3' and " +
          "STAFResult['sourceList'][1]['source'] == 'myApp;myMachine;25'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SOURCES SORTBYCOUNT',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfSources'] == '2' and " +
          "STAFResult['sourceList'][0]['count'] == '4' and " +
          "STAFResult['sourceList'][0]['source'] == 'yourApp;myMachine;43' and " +
          "STAFResult['sourceList'][1]['count'] == '3' and " +
          "STAFResult['sourceList'][1]['source'] == 'myApp;myMachine;25'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SOURCES SORTBYSOURCE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['numberOfSources'] == '2' and " +
          "STAFResult['sourceList'][0]['count'] == '3' and " +
          "STAFResult['sourceList'][0]['source'] == 'myApp;myMachine;25' and " +
          "STAFResult['sourceList'][1]['count'] == '4' and " +
          "STAFResult['sourceList'][1]['source'] == 'yourApp;myMachine;43'"
        ],

        # Make sure an error is returned if specify a STAF variable that doesn't exist
        [ 'STD:DIAG', 'DIAG', 'LIST TRIGGER {nonExistingVar}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SOURCE {nonExistingVar}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],

        # Make sure that the values for TRIGGER and SOURCE are being resolved for STAF variables correctly
        [ 'STD:DIAG', 'VAR',  'SET VAR STAFTest/trigger=abb VAR "STAFTest/source=myApp;myMachine;25"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST TRIGGER {STAFTest/trigger}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['trigger'] == 'abb' and " +
          "STAFResult['numberOfSources'] == '2' and " +
          "STAFResult['sourceList'][0]['count'] == '3' and " +
          "STAFResult['sourceList'][0]['source'] == 'yourApp;myMachine;43' and " +
          "STAFResult['sourceList'][1]['count'] == '1' and " +
          "STAFResult['sourceList'][1]['source'] == 'myApp;myMachine;25'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST TRIGGER abb SORTBYCOUNT',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['trigger'] == 'abb' and " +
          "STAFResult['numberOfSources'] == '2' and " +
          "STAFResult['sourceList'][0]['count'] == '3' and " +
          "STAFResult['sourceList'][0]['source'] == 'yourApp;myMachine;43' and " +
          "STAFResult['sourceList'][1]['count'] == '1' and " +
          "STAFResult['sourceList'][1]['source'] == 'myApp;myMachine;25'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST TRIGGER abb SORTBYSOURCE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['trigger'] == 'abb' and " +
          "STAFResult['numberOfSources'] == '2' and " +
          "STAFResult['sourceList'][0]['count'] == '1' and " +
          "STAFResult['sourceList'][0]['source'] == 'myApp;myMachine;25' and " +
          "STAFResult['sourceList'][1]['count'] == '3' and " +
          "STAFResult['sourceList'][1]['source'] == 'yourApp;myMachine;43'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SOURCE {STAFTest/source}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['source'] == 'myApp;myMachine;25' and " +
          "STAFResult['numberOfTriggers'] == '2' and " +
          "STAFResult['triggerList'][0]['count'] == '2' and " +
          "STAFResult['triggerList'][0]['trigger'] == 'abc' and " +
          "STAFResult['triggerList'][1]['count'] == '1' and " +
          "STAFResult['triggerList'][1]['trigger'] == 'abb'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SOURCE myApp;myMachine;25 SORTBYCOUNT',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['source'] == 'myApp;myMachine;25' and " +
          "STAFResult['numberOfTriggers'] == '2' and " +
          "STAFResult['triggerList'][0]['count'] == '2' and " +
          "STAFResult['triggerList'][0]['trigger'] == 'abc' and " +
          "STAFResult['triggerList'][1]['count'] == '1' and " +
          "STAFResult['triggerList'][1]['trigger'] == 'abb'"
        ],

        [ 'STD:DIAG', 'DIAG', 'LIST SOURCE myApp;myMachine;25 SORTBYTRIGGER',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['fromTimestamp'] and " +
          "STAFResult['toTimestamp'] and " +
          "STAFResult['elapsedTime'] and " +
          "STAFResult['source'] == 'myApp;myMachine;25' and " +
          "STAFResult['numberOfTriggers'] == '2' and " +
          "STAFResult['triggerList'][0]['count'] == '1' and " +
          "STAFResult['triggerList'][0]['trigger'] == 'abb' and " +
          "STAFResult['triggerList'][1]['count'] == '2' and " +
          "STAFResult['triggerList'][1]['trigger'] == 'abc'"
        ],

        [ 'STD:DIAG', 'VAR',  'DELETE VAR STAFTest/trigger VAR STAFTest/source',
          [ STAFRC.Ok ], r'^$'
        ]

        ]
      </script>
      </if>

      <script>

        DIAGTests = DIAGTests + [

        # Perform clean-up
        [ 'STD:DIAG', 'DIAG', 'DISABLE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'DIAG', 'RESET FORCE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:DIAG', 'SEM',  'RELEASE MUTEX STAFTest/DIAG',
          [ STAFRC.Ok ], r'^$'
        ]

        ]

      </script>

      <return>DIAGTests</return>

    </sequence>
  </function>


  <!-- ============================================================================== -->
  <!-- InitServiceTests - This function initializes all the SERVICE test information  -->
  <!-- ============================================================================== -->

  <function name="InitSERVICETests" scope="local">
    <sequence>

      <testcase name="'SERVICE'">
        <sequence>

          <script>
            TestMachEventJarFile = '{STAF/Config/STAFRoot}/bin/STAFEvent.jar'
            fromMachine = 'local'
            request = 'COPY FILE %s TOFILE %s TOMACHINE %s' % (EventJarFile, TestMachEventJarFile, TestMach)
          </script>

          <message log="1">
            'Copy STAFEvent.jar file to test machine: STAF %s FS %s' % (fromMachine, request)
          </message>

          <stafcmd>
            <location>fromMachine</location>
            <service>'FS'</service>
            <request>request</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == 0,
              'failMsg': 'Error copying STAFEvent.jar file to testmachine: STAF %s FS %s.  RC=%s Result=%s' % \
                         (fromMachine, request, RC, STAFResult),
              'sendToMonitor': 1,
              'recordStatus': 1 }
          </call>

        </sequence>
      </testcase>

      <script>

      SERVICETests = [

        #
        # SERVICE tests
        #

        [ 'STD:SERVICE', 'SEM', 'REQUEST MUTEX STAFTest/SERVICE',
          [ STAFRC.Ok ], r'^$' ],

        [ 'STD:SERVICE', 'SERVICE', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:SERVICE', 'SERVICE', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] and " +
          "STAFResult[0]['library'] and " +
          "STAFResult[0]['executable'] or STAFResult[0]['executable'] == None"
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST SERVICELOADERS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] and " +
          "STAFResult[0]['library'] and " +
          "STAFResult[0]['executable'] or STAFResult[0]['executable'] == None"
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST AUTHENTICATORS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['name'] and " +
          " STAFResult[0]['library'] and " +
          " STAFResult[0]['executable'] or STAFResult[0]['executable'] == None)"
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "string.atoi(STAFResult[0]['requestNumber']) > 0 and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['service'] and " +
          "STAFResult[0]['request']"
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "string.atoi(STAFResult[0]['requestNumber']) > 0 and " +
          "STAFResult[0]['sourceMachine'] and " +
          "STAFResult[0]['sourceHandleName'] and " +
          "int(STAFResult[0]['sourceHandle']) > 0 and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['targetMachine'] and " +
          "STAFResult[0]['service'] and " +
          "STAFResult[0]['request']"
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS PENDING',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "string.atoi(STAFResult[0]['requestNumber']) > 0 and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['service'] and " +
          "STAFResult[0]['request']"
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS COMPLETE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          "string.atoi(STAFResult[0]['requestNumber']) > 0 and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['service'] and " +
          "STAFResult[0]['request'])"
        ],
        
        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS COMPLETE LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          "string.atoi(STAFResult[0]['requestNumber']) > 0 and " +
          "STAFResult[0]['sourceMachine'] and " +
          "STAFResult[0]['sourceHandleName'] and " +
          "int(STAFResult[0]['sourceHandle']) > 0 and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['targetMachine'] and " +
          "STAFResult[0]['service'] and " +
          "STAFResult[0]['request'] and " +
          "STAFResult[0]['rc'] and " +
          "(STAFResult[0]['result'] == '' or STAFResult[0]['result']))"
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS PENDING COMPLETE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "string.atoi(STAFResult[0]['requestNumber']) > 0 and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['service'] and " +
          "STAFResult[0]['request']"
        ],
        
        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS PENDING COMPLETE LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "string.atoi(STAFResult[0]['requestNumber']) > 0 and " +
          "(STAFResult[0]['state'] == 'Pending' or STAFResult[0]['state'] == 'Complete') and " +
          "STAFResult[0]['sourceMachine'] and " +
          "STAFResult[0]['sourceHandleName'] and " +
          "int(STAFResult[0]['sourceHandle']) > 0 and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['targetMachine'] and " +
          "STAFResult[0]['service'] and " +
          "STAFResult[0]['request'] and " +
          "(STAFResult[0]['rc'] == None or STAFResult[0]['rc']) and " +
          "(STAFResult[0]['result'] == None or STAFResult[0]['result'])"
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS SUMMARY LONG',
          [ STAFRC.InvalidRequestString ], None
        ],
        
        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS SUMMARY PENDING',
          [ STAFRC.InvalidRequestString ], None
        ],
        
        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS SUMMARY COMPLETE',
          [ STAFRC.InvalidRequestString ], None
        ],
        
        [ 'STD:SERVICE', 'SERVICE', 'LIST REQUESTS SUMMARY',
          [ STAFRC.Ok ], None,
          "long(STAFResult['activeRequests']) > 0 and " +
          "long(STAFResult['totalRequests']) > 5 and " +
          "long(STAFResult['resetCount']) >= 0 and " +
          "STAFResult['requestNumberRange'] and " +
          "long(STAFResult['maxActiveRequests']) >= 2147483647"
        ],

        [ 'STD:SERVICE', 'VAR',     'SET VAR STAFTest/testServiceName=testLog VAR STAFTest/testLib=STAFLog',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:SERVICE', 'SERVICE', 'REMOVE SERVICE {STAFTest/testServiceName}',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],
        
        [ 'STD:SERVICE', 'SERVICE', 'ADD SERVICE {STAFTest/testServiceName} LIBRARY {STAFTest/testLib}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SERVICE', 'TESTLOG', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'LIST SERVICES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] and " +
          "STAFResult[0]['library'] and " +
          "STAFResult[0]['executable'] or STAFResult[0]['executable'] == None"
        ],

        [ 'STD:SERVICE', 'SERVICE', 'ADD SERVICE TESTlog LIBRARY STAFLog',
          [ STAFRC.AlreadyExists ], r'^TESTlog'
        ],

        [ 'STD:SERVICE', 'VAR',     'SET VAR STAFTest/testServiceNameCaps=TESTLOG',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'REMOVE SERVICE {STAFTest/testServiceNameCaps}',
          [ STAFRC.Ok ], r'^$'
        ]

       ]
     </script>

     <if expr="TestMachJavaSupport"> 
        <script>
       SERVICETests = SERVICETests + [
       
        [ 'STD:SERVICE', 'VAR',     'SET VAR STAFTest/testLib2=JSTAF',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'ADD SERVICE testEvent LIBRARY {STAFTest/testLib2} EXECUTE %s OPTION JVMName=MyJVM OPTION J2=-Xmx128m %s' % (TestMachEventJarFile, RequiredJVMOptions),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'ADD SERVICE testEvent2 LIBRARY JSTAF EXECUTE %s OPTION JVMName=MyJVM' % (TestMachEventJarFile),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'ADD SERVICE XYZ LIBRARY JSTAF EXECUTE %s OPTION JVMName=XYZ OPTION JVM=/DoesNotExist/java %s' % (TestMachEventJarFile, RequiredJVMOptions),
          [ STAFRC.ServiceConfigurationError ], r'^.'
        ],

        [ 'STD:SERVICE', 'TESTEvent', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:SERVICE', 'TESTEvent2', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'REMOVE SERVICE testEvent',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'REMOVE SERVICE testEvent2',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'REMOVE SERVICE XYZ',
          [ STAFRC.DoesNotExist ], 'XYZ'
        ],

        [ 'STD:SERVICE', 'VAR', 'DELETE VAR STAFTest/testLib2',
          [ STAFRC.Ok ], r'^$'
        ]

       ]
       </script>
     </if>

     <script>
       SERVICETests = SERVICETests + [

        [ 'STD:SERVICE', 'SERVICE', 'QUERY REQUEST 1',
          [ STAFRC.RequestNumberNotFound ], r'^.'
        ],
        
        # Verify get an InvalidValue error if specify a request number not in range 1 to 2147483647
        [ 'STD:SERVICE', 'SERVICE', 'QUERY REQUEST abc',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        [ 'STD:SERVICE', 'SERVICE', 'QUERY REQUEST 0',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        [ 'STD:SERVICE', 'SERVICE', 'QUERY REQUEST 2147483648',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'FREE REQUEST 1',
          [ STAFRC.RequestNumberNotFound ], r'^.'
        ],

        [ 'STD:SERVICE', 'SERVICE', 'FREE REQUEST 1 FORCE',
          [ STAFRC.RequestNumberNotFound ], r'^.'
        ],

        # Verify get an InvalidValue error if specify a request number not in range 1 to 2147483647
        [ 'STD:SERVICE', 'SERVICE', 'FREE REQUEST abc',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        [ 'STD:SERVICE', 'SERVICE', 'FREE REQUEST 0',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        [ 'STD:SERVICE', 'SERVICE', 'FREE REQUEST 2147483648',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:SERVICE', 'VAR', 'DELETE VAR STAFTest/testServiceName VAR STAFTest/testServiceNameCaps VAR STAFTest/testLib',
          [ STAFRC.Ok ], r'^$'
        ],

        # List a jar file. STAFEvent.jar, that was created without using Java jar cf
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (TestMachEventJarFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['length'] and STAFResult[0]['method'] and " +
          "STAFResult[0]['size'] and STAFResult[0]['ratio'] and " +
          "STAFResult[0]['date'] and STAFResult[0]['time'] and " +
          "STAFResult[0]['crc-32'] and STAFResult[0]['name']"
        ],

        # Clean up
        [ 'STD:SERVICE', 'FS', 'DELETE ENTRY %s CONFIRM' % (TestMachEventJarFile),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:SERVICE', 'SEM', 'RELEASE MUTEX STAFTest/SERVICE',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>SERVICETests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitMISCTests - This function initializes all the MISC test information    -->
  <!-- ========================================================================== -->

  <function name="InitMISCTests" scope="local">

    <sequence>

        <testcase name="'MISC'">
          <sequence>

            <script>
              # localhost aliases for a IPv4 machine (assumes not testing on a IPv6 only machine
              localhostList = ['localhost', '127.0.0.1']
            </script>

            <iterate var="machine" in="localhostList">
              <sequence>

                <message log="1">
                  'STAF %s MISC WHOAMI' % (machine)
                </message>

                <stafcmd>
                  <location>machine</location>
                  <service>'MISC'</service>
                  <request>'WHOAMI'</request>
                </stafcmd>

                <call function="'STAXUtilCheckSuccess'">
                  { 'result': RC == 0 and STAFResult['isLocalRequest'] == 'Yes',
                    'failMsg': 'Error:  STAF %s MISC WHOAMI did not return isLocalRequest=Yes, RC=%s Result=%s' % \
                               (machine, RC, STAFResult),
                    'sendToMonitor': 1,
                    'recordStatus': 1 }
                </call>

              </sequence>
            </iterate>

          </sequence>
        </testcase>

      <script>

      MISCTests = [

        #
        # MISC tests
        #

        [ 'STD:MISC', 'SEM',  'REQUEST MUTEX STAFTest/MISC',
          [ STAFRC.Ok ], r'^$' ],

        [ 'STD:MISC', 'MISC', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:MISC', 'MISC', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:MISC', 'MISC', 'VERSION',
          [ STAFRC.Ok ], '3.\d+.\d+.*?'
        ],

        # Note:  THREAD INFO is an undocumented request to the MISC service
        [ 'STD:MISC', 'MISC', 'THREAD INFO',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['totalThreads']) > 1 and " +
          "string.atoi(STAFResult['workingThreads']) >= 0 and " +
          "string.atoi(STAFResult['idleThreads']) >= 0"
        ],

        [ 'STD:MISC', 'MISC', 'WHOAMI',
          [ STAFRC.Ok ], None,
          "STAFResult['instanceName'] and " +
          "STAFResult['instanceUUID'] and " +
          "STAFResult['requestNumber'] and " +
          "STAFResult['interface'] and " +
          "STAFResult['logicalID'] and " +
          "STAFResult['physicalID'] and " +
          "STAFResult['endpoint'].find('://') != -1 and " +
          "STAFResult['machine'] and " +
          "STAFResult['machineNickname'] and " +
          "(STAFResult['isLocalRequest'] == 'Yes' or STAFResult['isLocalRequest'] == 'No') and " +
          "STAFResult['handle'] and " +
          "STAFResult['handleName'] and " +
          "STAFResult['user'] == 'none://anonymous' and " +
          "string.atoi(STAFResult['trustLevel']) >= 0 and " +
          "string.atoi(STAFResult['trustLevel']) &lt;= 5"
        ],

        [ 'STD:MISC', 'MISC', 'WHOAREYOU',
          [ STAFRC.Ok ], None,
          "STAFResult['instanceName'] and " +
          "STAFResult['instanceUUID'] and " +
          "STAFResult['machine'] and " +
          "STAFResult['machineNickname'] and " +
          "(STAFResult['isLocalRequest'] == 'Yes' or STAFResult['isLocalRequest'] == 'No') and " +
          "STAFResult['currentTimestamp']"
        ],

        [ 'STD:MISC', 'MISC', 'LIST INTERFACES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] and " +
          "STAFResult[0]['library'] and " +
          "STAFResult[0]['optionMap']"
        ],

        # Verify that an InvalidValue error is returned if set CONNECTRETRYDELAY or MAXQUEUESIZE
        # to a value not in range 0 to UINT_MAX
        [ 'STD:MISC', 'MISC', 'SET CONNECTRETRYDELAY -1',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        [ 'STD:MISC', 'MISC', 'SET CONNECTRETRYDELAY 4294967296',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        [ 'STD:MISC', 'MISC', 'SET CONNECTRETRYDELAY 1000000d',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        [ 'STD:MISC', 'MISC', 'SET MAXQUEUESIZE -1',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        [ 'STD:MISC', 'MISC', 'SET MAXQUEUESIZE 4294967296',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        # Verify that an InvalidValue error is returned if set CONNECTATTEMPTS to a value not in
        # range 1 to UINT_MAX
        [ 'STD:MISC', 'MISC', 'SET CONNECTATTEMPTS 0',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        [ 'STD:MISC', 'MISC', 'SET CONNECTATTEMPTS 9999999999',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:MISC', 'MISC', 'SET CONNECTATTEMPTS 2 CONNECTRETRYDELAY 1s MAXQUEUESIZE 10000',
          [ STAFRC.Ok ], r'^$'
        ],
 
        [ 'STD:MISC', 'MISC', 'SET RESULTCOMPATIBILITYMODE NoNe',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:MISC', 'MISC', 'SET RESULTCOMPATIBILITYMODE Invalid',
          [ STAFRC.InvalidValue], r'^.'
        ],

        [ 'STD:MISC', 'VAR',  'SET VAR STAFTest/ResultCompatibilityMode=Verbose', [ STAFRC.Ok ], r'^$' ],
  
        [ 'STD:MISC', 'MISC', 'SET RESULTCOMPATIBILITYMODE {STAFTest/ResultCompatibilityMode}',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:MISC', 'MISC', 'SET INTERFACECYCLING Invalid',
          [ STAFRC.InvalidValue], r'^.'
        ],

        [ 'STD:MISC', 'VAR',  'SET VAR STAFTest/InterfaceCycling=Enabled', [ STAFRC.Ok ], r'^$' ],
  
        [ 'STD:MISC', 'MISC', 'SET INTERFACECYCLING {STAFTest/InterfaceCycling}',
          [ STAFRC.Ok ], r'^$'
        ],
        
        # The HANDLEGCINTERVAL must be between 5 seconds and 24 hours
        [ 'STD:MISC', 'MISC', 'SET HANDLEGCINTERVAL 4999',
          [ STAFRC.InvalidValue], r'^.'
        ],
        [ 'STD:MISC', 'MISC', 'SET HANDLEGCINTERVAL 86400001',
          [ STAFRC.InvalidValue], r'^.'
        ],
        [ 'STD:MISC', 'MISC', 'SET HANDLEGCINTERVAL 25h',
          [ STAFRC.InvalidValue], r'^.'
        ],
        [ 'STD:MISC', 'MISC', 'SET HANDLEGCINTERVAL 1w',
          [ STAFRC.InvalidValue], r'^.'
        ],
        [ 'STD:MISC', 'MISC', 'SET HANDLEGCINTERVAL 50s',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MISC', 'MISC', 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "int(STAFResult['connectAttempts']) > 0 and " +
          "int(STAFResult['connectRetryDelay']) > 0 and " +
          "int(STAFResult['maxQueueSize']) > 0 and " +
          "int(STAFResult['maxReturnFileSize']) >= 0 and " +
          "int(STAFResult['handleGCInterval']) == 50000 and " +
          "int(STAFResult['initialThreads']) == 10 and " +
          "int(STAFResult['threadGrowthDelta']) == 1 and " +
          "STAFResult['dataDir'] and " +
          "STAFResult['defaultInterface'] and " +
          "STAFResult['defaultAuthenticator'] and " +
          "STAFResult['resultCompatibilityMode'] == 'Verbose' and " +
          "STAFResult['interfaceCycling'] == 'Enabled'"
        ],

        [ 'STD:MISC', 'VAR',  'DELETE VAR STAFTest/ResultCompatibilityMode VAR STAFTest/InterfaceCycling', [ STAFRC.Ok ], r'^$' ],

        [ 'STD:MISC', 'MISC', 'QUERY INTERFACE tcp',
           [ STAFRC.Ok ], None,
          "STAFResult['name'] == 'tcp' and " +
          "STAFResult['library'] == 'STAFTCP' and " +
          "int(STAFResult['optionMap']['Port']) > 0 and " +
          "STAFResult['optionMap']['Protocol'].find('IPv') == 0 and " +
          "int(STAFResult['optionMap']['ConnectTimeout']) > 0"
        ],

        [ 'STD:MISC', 'VAR',  'SET VAR STAFTest/interface=local', [ STAFRC.Ok ], r'^$' ],

        [ 'STD:MISC', 'MISC', 'QUERY INTERFACE {STAFTest/interface}', [ STAFRC.Ok ], None,
          "STAFResult['name'] == 'local' and " +
          "STAFResult['library'] == 'STAFLIPC' and " +
          "STAFResult['optionMap']['IPCName']"
        ],

        ['STD:MISC', 'MISC', 'LIST ENDPOINTCACHE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          "STAFResult[0]['endpoint'] and " +
          "STAFResult[0]['interface'] and " +
          "STAFResult[0]['createdTimestamp'])"
        ],
          
        ['STD:MISC', 'MISC', 'PURGE ENDPOINTCACHE ENDPOINT Invalid1 ENDPOINT Invalid2',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['numPurged']) == 0 and " +
          "string.atoi(STAFResult['numRemaining']) >= 0"
        ],
        
        ['STD:MISC', 'MISC', 'PURGE ENDPOINTCACHE CONFIRM',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['numPurged']) >= 0 and " +
          "string.atoi(STAFResult['numRemaining']) == 0"
        ],

        [ 'STD:MISC', 'VAR', 'DELETE VAR STAFTest/interface',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MISC', 'SEM', 'RELEASE MUTEX STAFTest/MISC',
          [ STAFRC.Ok ], r'^$'
        ],

      ]

      </script>

      <return>MISCTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitHELPTests - This function initializes all the HELP test information    -->
  <!-- ========================================================================== -->

  <function name="InitHELPTests" scope="local">
    <sequence>

      <script>

      HELPTests = [

        #
        # HELP tests
        #
        [ 'STD:HELP', 'SEM',  'REQUEST MUTEX STAFTest/HELP',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HELP', 'HELP', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:HELP', 'HELP', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:HELP', 'VAR',  'SET VAR STAFTest/Errornum=37',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HELP', 'HELP', 'ERROR {STAFTest/Errornum}',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'Timeout' and " +
          "STAFResult['details'].find('This indicates that you') == 0"
        ],
        
        [ 'STD:HELP', 'HELP', 'ERROR 57',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'Create Thread Error' and " +
          "STAFResult['details'].find('This indicates that ') == 0"
        ],
        
        [ 'STD:HELP', 'HELP', 'ERROR 58',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'Maximum Size Exceeded' and " +
          "STAFResult['details'].find('This indicates that the size of a file') == 0"
        ],
        
        [ 'STD:HELP', 'HELP', 'ERROR 59',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'Maximum Handles Exceeded' and " +
          "STAFResult['details'].find('This indicates that a new handle could not be created/registered') == 0"
        ],

        [ 'STD:HELP', 'HELP', 'ERROR 989898',
          [ STAFRC.DoesNotExist ], r'^989898'
        ],

        # Submit a request to the LOG service to make sure it has been loaded by the default service loader
        [ 'STD:HELP', 'LOG', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Make sure you get RC 7 when you specify the SERVICE option without the ERROR option
        [ 'STD:HELP', 'HELP', 'SERVICE LOG',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:HELP', 'HELP', 'SERVICE LOG ERROR 4004',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] and " +
          "STAFResult['details']"
        ],

        [ 'STD:HELP', 'HELP', 'LIST SERVICES',
          [ STAFRC.Ok ], None
        ],

        # Make a request to the log service to make sure that it's been registered by the Default Service Loader
        [ 'STD:HELP', LogService,  'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:HELP', 'HELP', 'LIST SERVICE LOG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['returnCode'].find('400') == 0 and STAFResult[0]['description']"
        ],

        [ 'STD:HELP', 'VAR',  'SET VAR STAFTest/service=Log VAR STAFTest/errno=9999',
          [ STAFRC.Ok ], r'^$'
        ],

        # Note:  Register/Unregister requests are only valid if issued from local machine
        [ 'STD:HELP', 'HELP', 'REGISTER SERVICE {STAFTest/service} ERROR {STAFTest/errno} INFO "Test Error" DESCRIPTION "This is the text for a test error"',
          [ STAFRC.Ok, STAFRC.AccessDenied ], r'.*'
        ],

        [ 'STD:HELP', 'HELP', 'LIST ERRORS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 57 and " +
          "STAFResult[0]['returnCode'] and STAFResult[0]['description']"
        ],

        [ 'STD:HELP', 'HELP', 'LIST SERVICE {STAFTest/service} ERRORS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['returnCode'].find('400') == 0 and STAFResult[0]['description']"
        ],
        [ 'STD:HELP', 'HELP', 'SERVICE {STAFTest/service} ERROR {STAFTest/errno}',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:HELP', 'HELP', 'ERROR 4004',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['service'] and " +
          "STAFResult[0]['description'] and " +
          "STAFResult[0]['details']"
        ],

        [ 'STD:HELP', 'HELP', 'ERROR 4004 SERVICE {STAFTest/service}',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'Invalid level' and " +
          "STAFResult['details'].find('An invalid logging level was specified') == 0"
        ],

        [ 'STD:HELP', 'HELP', 'UNREGISTER SERVICE LOG ERROR 9999',
          [ STAFRC.Ok, STAFRC.AccessDenied ], r'.*'
        ],

        [ 'STD:HELP', 'VAR',  'DELETE VAR STAFTest/Errornum VAR STAFTest/service VAR STAFTest/errno',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HELP', 'SEM',  'RELEASE MUTEX STAFTest/HELP',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>HELPTests</return>

    </sequence>
  </function>

 <!-- ========================================================================== -->
  <!-- InitTRACETests - This function initializes all the MISC test information    -->
  <!-- ========================================================================== -->

  <function name="InitTRACETests" scope="local">
    <sequence>

      <script>

        TRACETests = [

        #
        # TRACE tests
        #

        [ 'STD:TRACE', 'SEM',  'REQUEST MUTEX STAFTest/TRACE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:TRACE', 'TRACE', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        # SET Tests
        [ 'STD:TRACE', 'TRACE', 'DISABLE ALL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO STDOUT',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'] == 'Stdout' and " +
          "STAFResult['fileMode'] == None"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO STDERR',
          [ STAFRC.Ok ], r'^$'],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'] == 'Stderr' and " +
          "STAFResult['fileMode'] == None"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO STDOUT FILE {STAF/DataDir}/user/staf.out',
          [ STAFRC.Ok ], r'^$'],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "len(STAFResult['tracingTo']) == 2 and " +
          "STAFResult['tracingTo'][0] == 'Stdout' and " +
          "STAFResult['tracingTo'][1].find('/user/staf.out') > 0 and " +
          "STAFResult['fileMode'] == 'Replace'"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO STDERR FILE {STAF/DataDir}/user/staf.err APPEND',
          [ STAFRC.Ok ], r'^$'],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "len(STAFResult['tracingTo']) == 2 and " +
          "STAFResult['tracingTo'][0] == 'Stderr' and " +
          "STAFResult['tracingTo'][1].find('/user/staf.err') > 0 and " +
          "STAFResult['fileMode'] == 'Append'"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO STDOUT STDERR',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        # ENABLE ALL output tests

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO FILE {STAF/DataDir}/user/staf.trc',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE ALL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE ALL SERVICES',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE ALL SERVICES TRACEPOINTS',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE ALL TRACEPOINTS',
          [ STAFRC.Ok ], r'^$'
        ],

        # ENABLE [SERVICES | TRACEPOINTS] Tests

        [ 'STD:TRACE', 'TRACE', 'PURGE',
          [ STAFRC.Ok ] , r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DEFAULTSERVICESTATE Disabled',
          [ STAFRC.Ok ] , r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'SET VAR STAFTest/Trace/Disabled=DiSabled',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DEFAULTSERVICESTATE {STAFTest/Trace/Disabled}',
          [ STAFRC.Ok ] , r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'DELETE VAR STAFTest/Trace/Disabled',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DEFAULTSERVICESTATE Blahblahblah',
          [ STAFRC.InvalidRequestString ] , r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE ALL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE SERVICES "SEM"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'SET VAR STAFTest/Trace/Myservices="QUEUE VAR TRUST"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE SERVICES {STAFTest/Trace/Myservices}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE SERVICES ""',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE SERVICES "BOGUSSERVICE"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINTS "DEPRECATED"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINTS "WARNING INFO ERROR REGISTRATION"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINTS ""',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINTS "SERVICEERROR NOTATRACEPOINT"',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Replace' and " +
          "STAFResult['defaultServiceState']== 'Disabled' and " +
          "STAFResult['maxServiceResultSize']== '0' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Enabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Enabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Enabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['BOGUSSERVICE'] == 'Enabled (Not registered)' and " +
          "STAFResult['services']['DELAY'] == 'Disabled' and " +
          "STAFResult['services']['DIAG'] == 'Disabled' and " +
          "STAFResult['services']['ECHO'] == 'Disabled' and " +
          "STAFResult['services']['FS'] == 'Disabled' and " +
          "STAFResult['services']['HANDLE'] == 'Disabled' and " +
          "STAFResult['services']['HELP'] == 'Disabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Disabled') and " +
          "STAFResult['services']['MISC'] == 'Disabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Disabled') and " +
          "STAFResult['services']['PROCESS'] == 'Disabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Disabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Disabled' and " +
          "STAFResult['services']['TRACE'] == 'Disabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        # ENABLE SERVICE service TRACEPOINT tracepoint tests

        [ 'STD:TRACE', 'TRACE', 'PURGE',
          [ STAFRC.Ok ] , r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DEFAULTSERVICESTATE Enabled',
          [ STAFRC.Ok ] , r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE ALL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE SERVICE DIAG',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'SET VAR STAFTest/Trace/MyService="DELAY"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE SERVICE {STAFTest/Trace/MyService} SERVICE FS SERVICE ECHO SERVICE PING',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'DELETE VAR STAFTest/Trace/MyService',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINT SERVICEREQUEST',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'SET VAR STAFTest/Trace/MyTracePoint="SERVICEERROR"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINT SERVICEACCESSDENIED TRACEPOINT {STAFTest/Trace/MyTracePoint} TRACEPOINT REMOTEREQUESTS',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'DELETE VAR STAFTest/Trace/MyTracePoint',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINT WARNING SERVICE HELP TRACEPOINT SERVICERESULT SERVICE HANDLE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE SERVICE',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINT SERVICE',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINT SERVICE',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO FILE {STAF/DataDir}/user/staf3.trc',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf3.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Replace' and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '0' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Enabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Enabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Enabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Enabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Disabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Enabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Disabled') and " +
          "STAFResult['services']['MISC'] == 'Disabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Disabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Disabled' and " +
          "STAFResult['services']['QUEUE'] == 'Disabled' and " +
          "STAFResult['services']['SEM'] == 'Disabled' and " +
          "STAFResult['services']['SERVICE'] == 'Disabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Disabled' and " +
          "STAFResult['services']['TRACE'] == 'Disabled' and " +
          "STAFResult['services']['TRUST'] == 'Disabled' and " +
          "STAFResult['services']['VAR'] == 'Disabled'"
        ],

        # DISABLE ALL output tests

        [ 'STD:TRACE', 'TRACE', 'PURGE',
          [ STAFRC.Ok ] , r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE ALL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE ALL SERVICES',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE ALL SERVICES TRACEPOINTS',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE ALL TRACEPOINTS',
          [ STAFRC.Ok ], r'^$'
        ],

        # DISABLE [SERVICES | TRACEPOINTS] Tests
        [ 'STD:TRACE', 'TRACE', 'PURGE',
          [ STAFRC.Ok ] , r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE ALL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICES "MISC"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'SET VAR STAFTest/Trace/MyServices="PROCESS QUEUE"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICES "PING {STAFTest/Trace/MyServices} SERVICE"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'DELETE VAR STAFTest/Trace/MyServices',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICES ""',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICES "NOTASERVICE"',
          [ STAFRC.Ok ],r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINTS "SERVICEMANAGEMENT"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'SET VAR STAFTest/Trace/MyTracepoints="SERVICERESULT REMOTEREQUESTS"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINTS "SERVICEERROR {STAFTest/Trace/MyTracepoints}"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'VAR',   'DELETE VAR STAFTest/Trace/MyTracepoints',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINTS ""',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINTS "BOGUSTRACEPOINT"',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINTS "INFO BOGUSTRACEPOINT2"',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINTS "BOGUSTRACEPOINT WARNING BOGUSTRACEPOINT3"',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINTS "WARNING BOGUSTRACEPOINT3 ERROR"',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO FILE {STAF/DataDir}/user/staf4.trc',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf4.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Replace' and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '0' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Enabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Enabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Enabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Enabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Enabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Disabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['NOTASERVICE'] == 'Disabled (Not registered)' and " +
          "STAFResult['services']['PING'] == 'Disabled' and " +
          "STAFResult['services']['PROCESS'] == 'Disabled' and " +
          "STAFResult['services']['QUEUE'] == 'Disabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Disabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Enabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        # DISABLE SERVICE service TRACEPOINT tracepoint tests

        [ 'STD:TRACE', 'TRACE', 'PURGE',
          [ STAFRC.Ok ] , r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE ALL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICE HELP',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICE VAR SERVICE TRUST SERVICE SHUTDOWN',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINT INFO',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINT ERROR TRACEPOINT REGISTRATION TRACEPOINT SERVICERESULT',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICE FS TRACEPOINT DEPRECATED SERVICE WRONG SERVICE TRUST TRACEPOINT SERVICEACCESSDENIED SERVICE FAKE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICE',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINT SERVICE',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINT SERVICE',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO FILE {STAF/DataDir}/user/staf2.trc',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf2.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Replace' and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '0' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Enabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Enabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Enabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Disabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FAKE'] == 'Disabled (Not registered)' and " +
          "STAFResult['services']['FS'] == 'Disabled' and " +
          "STAFResult['services']['HANDLE'] == 'Enabled' and " +
          "STAFResult['services']['HELP'] == 'Disabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Enabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Enabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Disabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Disabled' and " +
          "STAFResult['services']['VAR'] == 'Disabled' and " +
          "STAFResult['services']['WRONG'] == 'Disabled (Not registered)'"
        ],

        # Test Interactions with combined test

        [ 'STD:TRACE', 'TRACE', 'PURGE',
          [ STAFRC.Ok ] , r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE ALL SERVICES',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE ALL TRACEPOINTS',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICES "QUEUE VAR TRUST"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE SERVICES "QUEUE TRUST"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE SERVICE MISC SERVICE HANDLE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE SERVICE VAR SERVICE MISC',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINT SERVICEMANAGEMENT TRACEPOINT SERVICERESULT TRACEPOINT ERROR',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINTS "SERVICEMANAGEMENT"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINTS "INFO DEPRECATED WARNING"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE TRACEPOINT SERVICERESULT TRACEPOINT INFO TRACEPOINT WARNING',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO FILE {STAF/DataDir}/user/staf5.trc',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf5.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Replace' and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '0' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Disabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Disabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Enabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Enabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Enabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET MAXSERVICERESULTSIZE 100000',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf5.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Replace' and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '100000' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Disabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Disabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Enabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Enabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Enabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET MAXSERVICERESULTSIZE 4k',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf5.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Replace' and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '4096' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Disabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Disabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Enabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Enabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Enabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET MAXSERVICERESULTSIZE 1m',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf5.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Replace' and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '1048576' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Disabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Disabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Enabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Enabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Enabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET MAXSERVICERESULTSIZE 10kb',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO STDOUT',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'] == 'Stdout' and " +
          "STAFResult['fileMode'] == None and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '1048576' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Disabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Disabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Enabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Enabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Enabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO STDERR',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'] == 'Stderr' and " +
          "STAFResult['fileMode'] == None and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '1048576' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Disabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Disabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Enabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Enabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Enabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO FILE {STAF/DataDir}/user/staf6.trc APPEND',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf6.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Append' and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '1048576' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Disabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Disabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Enabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Enabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Enabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO FILE {STAF/DataDir}/user/staf6.trc',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult['tracingTo'].find('/user/staf6.trc') > 0 and " +
          "STAFResult['fileMode'] == 'Replace' and " +
          "STAFResult['defaultServiceState']== 'Enabled' and " +
          "STAFResult['maxServiceResultSize']== '1048576' and " +
          "STAFResult['tracePoints']['SERVICEREQUEST'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICERESULT'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEERROR'] == 'Disabled' and " +
          "STAFResult['tracePoints']['SERVICEACCESSDENIED'] == 'Disabled' and " +
          "STAFResult['tracePoints']['REMOTEREQUESTS'] == 'Disabled' and " +
          "STAFResult['tracePoints']['ERROR'] == 'Enabled' and " +
          "STAFResult['tracePoints']['REGISTRATION'] == 'Disabled' and " +
          "STAFResult['tracePoints']['WARNING'] == 'Disabled' and " +
          "STAFResult['tracePoints']['INFO'] == 'Disabled' and " +
          "STAFResult['tracePoints']['DEPRECATED'] == 'Enabled' and " +
          "STAFResult['services']['DELAY'] == 'Enabled' and " +
          "STAFResult['services']['DIAG'] == 'Enabled' and " +
          "STAFResult['services']['ECHO'] == 'Enabled' and " +
          "STAFResult['services']['FS'] == 'Enabled' and " +
          "STAFResult['services']['HANDLE'] == 'Disabled' and " +
          "STAFResult['services']['HELP'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('LOG') or STAFResult['services']['LOG'] == 'Enabled') and " +
          "STAFResult['services']['MISC'] == 'Enabled' and " +
          "(not STAFResult['services'].has_key('MONITOR') or STAFResult['services']['MONITOR'] == 'Enabled') and " +
          "STAFResult['services']['PING'] == 'Enabled' and " +
          "STAFResult['services']['PROCESS'] == 'Enabled' and " +
          "STAFResult['services']['QUEUE'] == 'Enabled' and " +
          "STAFResult['services']['SEM'] == 'Enabled' and " +
          "STAFResult['services']['SERVICE'] == 'Enabled' and " +
          "STAFResult['services']['SHUTDOWN'] == 'Enabled' and " +
          "STAFResult['services']['TRACE'] == 'Enabled' and " +
          "STAFResult['services']['TRUST'] == 'Enabled' and " +
          "STAFResult['services']['VAR'] == 'Enabled'"
        ],

        # CLEANUP AND RESET TO DEFAULTS
        [ 'STD:TRACE', 'TRACE', 'SET DESTINATION TO STDOUT',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'SET MAXSERVICERESULTSIZE 0',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'FS', 'DELETE ENTRY {STAF/DataDir}/user/staf.trc CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:TRACE', 'FS', 'DELETE ENTRY {STAF/DataDir}/user/staf2.trc CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:TRACE', 'FS', 'DELETE ENTRY {STAF/DataDir}/user/staf3.trc CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:TRACE', 'FS', 'DELETE ENTRY {STAF/DataDir}/user/staf4.trc CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:TRACE', 'FS', 'DELETE ENTRY {STAF/DataDir}/user/staf5.trc CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:TRACE', 'TRACE', 'DISABLE ALL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE ALL SERVICES',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'ENABLE TRACEPOINTS "ERROR DEPRECATED"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRACE', 'TRACE', 'LIST',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:TRACE', 'SEM', 'RELEASE MUTEX STAFTest/TRACE',
          [ STAFRC.Ok ], r'^$'
        ],

        ]

        </script>

        <return>TRACETests</return>

        </sequence>
  </function>

  <!-- ========================================================================== -->
  <!-- InitTRUSTTests - This function initializes all the TRUST test information  -->
  <!-- ========================================================================== -->

  <function name="InitTRUSTTests" scope="local">
    <sequence>

      <script>

      TRUSTTests = [

        #
        #Trust tests
        #

        [ 'STD:TRUST', 'SEM', 'REQUEST MUTEX STAFTest/TRUST',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'TRUST', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:TRUST', 'TRUST', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:TRUST', 'TRUST', 'SET DEFAULT LEVEL 5',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'TRUST', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 1 and STAFResult[0]['type'] == 'Default' and " +
          "STAFResult[0]['entry'] == None and STAFResult[0]['trustLevel'] == '5'"
        ],

        [ 'STD:TRUST', 'TRUST', 'SET MACHINE STAFTestMachine LEVEL 2',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'TRUST', 'GET MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '2'
        ],

        [ 'STD:TRUST', 'TRUST', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 1 and " +
          "STAFResult[0]['type'] == 'Default' and STAFResult[0]['trustLevel'] == '5' and "
          "STAFResult[1]['type'] == 'Machine'"
        ],

        [ 'STD:TRUST', 'TRUST', 'SET USER John@company.com LEVEL 1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'TRUST', 'GET USER John@company.com MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '1'
        ],

        # XXX: STAF is lower-casing the machine name.  Should it?
        [ 'STD:TRUST', 'TRUST', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 1 and " +
          "STAFResult[0]['type'] == 'Default' and STAFResult[0]['trustLevel'] == '5' and "
          "STAFResult[len(STAFResult) - 1]['type'] == 'User'"
        ],

        [ 'STD:TRUST', 'TRUST', 'SET MACHINE STAFTestMachine LEVEL 0',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'TRUST', 'GET MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '0'
        ],

        # Verify that STAF variables are resolved in the MACHINE and LEVEL options

        [ 'STD:TRUST', 'VAR',   'SET VAR STAFTest/Trust/Machine=STAFTestMachine VAR STAFTest/Trust/Level=1',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:TRUST', 'TRUST', 'SET MACHINE {STAFTest/Trust/Machine} LEVEL {STAFTest/Trust/Level}',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:TRUST', 'TRUST', 'GET MACHINE {STAFTest/Trust/Machine}',
          [ STAFRC.Ok ], '1'
        ],
        [ 'STD:TRUST', 'TRUST', 'SET MACHINE {STAFTest/NoExist} LEVEL {STAFTest/Trust/Level}',
          [ STAFRC.VariableDoesNotExist ], None
        ], 
        [ 'STD:TRUST', 'TRUST', 'SET MACHINE {STAFTest/Trust/Machine} LEVEL {STAFTest/NoExist}',
          [ STAFRC.VariableDoesNotExist ], None
        ], 

        [ 'STD:TRUST', 'TRUST', 'DELETE MACHINE STAFTestDoesNotExist',
          [ STAFRC.TrusteeDoesNotExist ], r'^$'
        ],

        # Verify get an InvalidTrustLevel error if specify a level not in range 0 to 5
        [ 'STD:TRUST', 'TRUST', 'SET MACHINE STAFTestMachine LEVEL 99',
          [ STAFRC.InvalidValue ], r'^.'     # Used to be STAFRC.InvalidTrustLevel
        ],
        [ 'STD:TRUST', 'TRUST', 'SET MACHINE STAFTestMachine LEVEL x',
          [ STAFRC.InvalidValue ], r'^.'     # Used to be STAFRC.InvalidTrustLevel
        ],
        [ 'STD:TRUST', 'TRUST', 'SET MACHINE STAFTestMachine LEVEL 999999999999',
          [ STAFRC.InvalidValue ], r'^.'     # Used to be STAFRC.InvalidTrustLevel
        ],

        [ 'STD:TRUST', 'TRUST', 'GET MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '1'
        ],

        [ 'STD:TRUST', 'TRUST', 'DELETE MACHINE {STAFTest/Trust/Machine}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'TRUST', 'SET USER John@company.com LEVEL 1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'TRUST', 'GET USER John@company.com MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '1'
        ],

        # Verify that STAF variables are resolved in the USER option

        [ 'STD:TRUST', 'VAR',   'SET VAR STAFTest/Trust/User=John@company.com',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:TRUST', 'TRUST', 'SET USER {STAFTest/Trust/User} LEVEL 2',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:TRUST', 'TRUST', 'GET USER {STAFTest/Trust/User} MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '2'
        ],
        [ 'STD:TRUST', 'TRUST', 'SET USER {STAFTest/NoExist} LEVEL 1',
          [ STAFRC.VariableDoesNotExist ], None
        ], 

        [ 'STD:TRUST', 'TRUST', 'DELETE USER STAFTestDoesNotExist',
          [ STAFRC.TrusteeDoesNotExist ], r'^$'
        ],

        [ 'STD:TRUST', 'TRUST', 'SET USER John@company.com LEVEL 99',
          [ STAFRC.InvalidValue ], r'^.'    # Used to be STAFRC.InvalidTrustLevel
        ],

        [ 'STD:TRUST', 'TRUST', 'GET USER John@company.com MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '2'
        ],

        [ 'STD:TRUST', 'TRUST', 'DELETE USER {STAFTest/Trust/User}',
          [ STAFRC.Ok ], r'^$'
        ],

        # Verify that the default trust is returned now that a matching entry for specified user/machine does not exist
        [ 'STD:TRUST', 'TRUST', 'GET USER John@company.com MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '5'
        ],

        # Verify that using wildcards in the user works
        [ 'STD:TRUST', 'TRUST', 'SET USER IBM*://*@us.ibm.com LEVEL 4',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'TRUST', 'GET USER IBMIntraAuth://JaneDoe@us.ibm.com MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '4'
        ],

        # Verify that the authenticator value is not case-sensitive
        [ 'STD:TRUST', 'TRUST', 'GET USER ibmauth://JaneDoe@us.ibm.com MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '4'
        ],

        # Verify that the user value is case-sensitive
        [ 'STD:TRUST', 'TRUST', 'GET USER ibmauth://JaneDoe@us.IBM.com MACHINE STAFTestMachine',
          [ STAFRC.Ok ], '5'
        ],

        # Wildcard characters are not allowed in the user value on a TRUST GET command
        [ 'STD:TRUST', 'TRUST', 'GET USER IBM*://*@us.ibm.com MACHINE STAFTestMachine',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:TRUST', 'TRUST', 'DELETE USER IBM*://*@us.ibm.com',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'VAR',   'DELETE VAR STAFTest/Trust/Machine VAR STAFTest/Trust/Level VAR STAFTest/Trust/User',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:TRUST', 'SEM', 'RELEASE MUTEX STAFTest/TRUST',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>TRUSTTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitFSTests - This function initializes all the FS test information        -->
  <!-- ========================================================================== -->

  <function name="InitFSTests" scope="local">
    <sequence>

      <testcase name="'FS'">
        <sequence>

          <log message="1">'Create directory %s on STAX machine for test machine %s' % (STAXMachTestDir, TestMach)</log>

          <stafcmd name="'Create directory %s on STAX machine' % (STAXMachTestDir)">
            <location>'local'</location>
            <service>'FS'</service>
            <request>'CREATE DIRECTORY %s' % (STAXMachTestDir)</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
              'failMsg': 'STAF local FS CREATE DIRECTORY %s failed.  RC=%s Result=%s' % \
                         (STAXMachTestDir, RC, STAFResult),
              'sendToMonitor': 1,
              'recordStatus': 1 }
          </call>

        </sequence>
      </testcase>

      <!-- FS creation of test files on STAX Machine -->

      <script>
        # Create a file called STAFTest.txt in '{STAF/DataDir}/tmp/%s' % (TestMach) on the
        # STAX (local) machine with line-endings appropriate for the STAX machine's platform

        textFileName1 = '%s/STAFTest.txt' % (STAXMachTestDir)

        # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
        textFile = open(textFileName1, 'wt')

        textFile.writelines([ 'This is line 1.\n',
                              'This is line 2.\n',
                              'Finally, line 3.\n' ])
        textFile.close()

        textResultWindows = r"""(?mx)
                                ^This\ is\ line\ 1.\r\n
                                ^This\ is\ line\ 2.\r\n
                                ^Finally,\ line\ 3.\r\n"""
        textResultUnix    = r"""(?mx)
                                ^This\ is\ line\ 1.\n
                                ^This\ is\ line\ 2.\n
                                ^Finally,\ line\ 3.\n"""

        textResultWindowsHex = r'54686973206973206C696E6520312E0D0A54686973206973206C696E6520322E0D0A46696E616C6C792C206C696E6520332E0D0A'
        textResultUnixHex    = r'54686973206973206C696E6520312E0A54686973206973206C696E6520322E0A46696E616C6C792C206C696E6520332E0A'

        EBCDICResultWindowsHex    = r'E38889A24089A2409389958540F14B0D15E38889A24089A2409389958540F24B0D15C68995819393A86B409389958540F34B0D15'
        EBCDICResultUnixHex  = r'E38889A24089A2409389958540F14B15E38889A24089A2409389958540F24B15C68995819393A86B409389958540F34B15'

        textResultSpace      = r'^This is line 1. This is line 2. Finally, line 3. '
        textResultOther      = r'^This is line 1.##>This is line 2.##>Finally, line 3.##>'

        # Create a file called STAFTestLarge.txt in '{STAF/DataDir}/tmp/%s' % (TestMach) on the STAX (local) machine with
        # line-endings appropriate for the STAX machine's platform

        textFileName2 = '%s/STAFTestLarge.txt' % (STAXMachTestDir)

        # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
        textFile2 = open(textFileName2, 'wt')

        for i in range(5):
          for j in range(299):
            textFile2.writelines([ 'xxxxxxxxxb' ])
          textFile2.writelines([ 'xxxxxxxa\n' ])
          for j in range(299):
            textFile2.writelines([ 'xxxxxxxxxb' ])
          textFile2.writelines([ 'xxxxxxxxa\n' ])
          for j in range(300):
            textFile2.writelines([ 'xxxxxxxxxb' ])
          textFile2.writelines([ '\n' ])

        textFile2.close()

        # Create a file called STAFTestLargeEOL.txt in '{STAF/DataDir}/tmp/%s' % (TestMach) on the
        # STAX (local) machine with line-endings appropriate for the STAX machine's platform

        textFileName3 = '%s/STAFTestLargeEOL.txt' % (STAXMachTestDir)

        # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
        textFile3 = open(textFileName3, 'wt')

        for i in range(5):
          for j in range(300):
            textFile3.writelines([ '\n\n\n\n\n\n\n\n\n\n' ])

        textFile3.close()

        # Create an empty file called STAFTestEmpty.txt in '{STAF/DataDir}/tmp/%s' % (TestMach) on the
        # STAX (local) machine
        emptyTextFileName = '%s/STAFTestEmpty.txt' % (STAXMachTestDir)

        # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
        emptyTextFile = open(emptyTextFileName, 'wt')
        emptyTextFile.close()
      </script>

      <testcase name="'FS'">
        <sequence>

          <script>

          if STAXMachOSType.find('Win') == 0 or STAXMachOSType.find('Unknown Win') == 0:
              textResultNative    = textResultWindows
              textResultNativeHex = textResultWindowsHex
          else:
              textResultNative    = textResultUnix
              textResultNativeHex = textResultUnixHex

          # z/OS uses EBCDIC; all other platforms use ASCII
          if TestMachOSType.find('OS/390') == 0:
            binResultWindows = EBCDICResultWindowsHex
            binResultUnix    = EBCDICResultUnixHex
          else:
            binResultWindows = textResultWindowsHex
            binResultUnix    = textResultUnixHex

          if TestMachOSType.find('Win') == 0 or TestMachOSType.find('Unknown Win') == 0:
              TestMachTextResult    = textResultWindows
              TestMachTextResultHex = textResultWindowsHex
              binResult = textResultWindowsHex
              TestMachSmallTextSize = textSmallWinSize
              TestMachLargeTextSize = textLargeWinSize
              TestMachEOLTextSize   = textEOLWinSize
              TestMachPathSep = '\\\\'
          else:
              TestMachTextResult    = textResultUnix
              TestMachTextResultHex = textResultUnixHex

              # z/OS users EBCDIC; all other platforms use ASCII
              if TestMachOSType.find('OS/390') == 0:
                binResult = EBCDICResultUnixHex
              else:
                binResult = textResultUnixHex

              TestMachSmallTextSize = textSmallUnixSize
              TestMachLargeTextSize = textLargeUnixSize
              TestMachEOLTextSize   = textEOLUnixSize
              TestMachPathSep = '/'

          if TestMachOSType.find('Win') == 0 or TestMachOSType.find('Unknown Win') == 0:
              testDirectoryNameList = [
                 '{STAF/Config/BootDrive}',     # e.g.  C:
                 '{STAF/Config/BootDrive}\\',   # e.g.  C:\
                 '{STAF/Config/BootDrive}/'     # e.g.  C:/
              ]
              
              # Test using an absolute path that doesn't begin with a drive letter and relative paths
              if TestMachSTAFRoot.find(':\\') == 1:
                  absolutePathNoDriveLetter = TestMachSTAFRoot[2:]
                  testDirectoryNameList.append(absolutePathNoDriveLetter)                      # e.g. \STAF
                  testDirectoryNameList.append('%s\\bin' % (absolutePathNoDriveLetter))   # e.g. \STAF\bin
          else:
              testDirectoryNameList = [ '{STAF/Config/BootDrive}' ]     # e.g. /
          </script>

          <message>
            'Copy text file %s created on the STAX machine to %s' % (textFileName1, TestMach)
          </message>

          <!-- Copy the text file, textFileName, created on the STAX machine to the TestMach -->
          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'COPY FILE %s TOFILE {STAF/DataDir}/user/STAFTest.txt TOMACHINE %s TEXT' % (textFileName1, TestMach)</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
              'failMsg': 'STAF local FS COPY FILE %s TOFILE {STAF/DataDir}/user/STAFTest.txt TOMACHINE %s TEXT failed.  RC=%s Result=%s' % \
                         (textFileName1, TestMach, RC, STAFResult),
              'sendToMonitor': 1,
              'recordStatus': 1 }
          </call>

          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'COPY FILE %s TOFILE {STAF/DataDir}/user/STAFTestLarge.txt TOMACHINE %s TEXT' % (textFileName2, TestMach)</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
              'failMsg': 'STAF local FS COPY FILE %s TOFILE {STAF/DataDir}/user/STAFTestLarge.txt TOMACHINE %s TEXT failed.  RC=%s Result=%s' % \
                         (textFileName2, TestMach, RC, STAFResult),
              'sendToMonitor': 1,
              'recordStatus': 1 }
          </call>

          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'COPY FILE %s TOFILE {STAF/DataDir}/user/STAFTestLargeEOL.txt TOMACHINE %s TEXT' % (textFileName3, TestMach)</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
              'failMsg': 'STAF local FS COPY FILE %s TOFILE {STAF/DataDir}/user/STAFTestLargeEOL.txt TOMACHINE %s TEXT failed.  RC=%s Result=%s' % \
                         (textFileName3, TestMach, RC, STAFResult),
              'sendToMonitor': 1,
              'recordStatus': 1 }
          </call>
          
          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'COPY FILE %s TOFILE {STAF/DataDir}/user/STAFTestEmpty.txt TOMACHINE %s TEXT' % (emptyTextFileName, TestMach)</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
              'failMsg': 'STAF local FS COPY FILE %s TOFILE {STAF/DataDir}/user/STAFTestEmpty.txt TOMACHINE %s TEXT failed.  RC=%s Result=%s' % \
                         (emptyTextFileName, TestMach, RC, STAFResult),
              'sendToMonitor': 1,
              'recordStatus': 1 }
          </call>

          <if expr="STAXMachHasSSL and TestMachHasSSL">
            <sequence>

              <!-- Copy a file in binary from STAX service machine to TestMach.  Then, for each supported checksum algorithm,
                    get the checksum for the file on the STAX service machine and get the checksum for the file on the TestMach
                    and verify that they match -->
              <!-- Removed MD2 from the list of supported checksum algorithms because not available on Mac OS X Universal -->

              <script>
                checksumList = [ '', 'MD4', 'MD5', 'RIPEMD160', 'SHA', 'SHA1' ]  # Supported checksum algorithms
                STAXMach_FileName = textFileName2
                TestMach_FileName = '{STAF/DataDir}/user/STAFTestChecksum.txt'
                request =  'COPY FILE %s TOFILE %s TOMACHINE %s' % (STAXMach_FileName, TestMach_FileName, TestMach)
              </script>

              <stafcmd>
                <location>'local'</location>
                <service>'FS'</service>
                <request>request</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF local FS %s failed.  RC=%s Result=%s' % (request, RC, STAFResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

              <iterate var="checksum" in="checksumList">
                <sequence>

                  <script>request = 'GET ENTRY %s CHECKSUM %s' % (STAXMach_FileName, checksum)</script>
              
                  <stafcmd>
                    <location>'local'</location>
                    <service>'FS'</service>
                    <request>request</request>
                  </stafcmd>

                  <call function="'STAXUtilCheckSuccess'">
                    { 'result': RC == STAFRC.Ok,
                      'failMsg': 'STAF local FS %s failed.  RC=%s Result=%s' % (request, RC, STAFResult),
                      'sendToMonitor': 1,
                      'recordStatus': 1 }
                  </call>

                  <script>
                    STAX_checksum = STAFResult
                    request = 'GET ENTRY %s CHECKSUM %s' % (TestMach_FileName, checksum)
                  </script>

                  <stafcmd>
                    <location>TestMach</location>
                    <service>'FS'</service>
                    <request>request</request>
                  </stafcmd>

                  <call function="'STAXUtilCheckSuccess'">
                    { 'result': RC == STAFRC.Ok,
                      'failMsg': 'STAF local FS %s failed.  RC=%s Result=%s' % (request, RC, STAFResult),
                      'sendToMonitor': 1,
                      'recordStatus': 1 }
                  </call>

                  <script>TestMach_checksum = STAFResult</script>

                  <message>
                    'FS: Comparing %s checksums: ' % (checksum) + \
                    '\n  STAX Machine (%s) checksum: %s, File: %s' % (STAXMachine, STAX_checksum, STAXMach_FileName) + \
                    '\n  Test Machine (%s) checksum: %s, File: %s' % (TestMach, TestMach_checksum, TestMach_FileName)
                  </message>

                  <call function="'STAXUtilCheckSuccess'">
                    { 'result': STAX_checksum == TestMach_checksum,
                      'failMsg': 'FS: Comparison of %s checksums failed:' % (checksum) + \
                                    '\n  STAX Machine (%s) checksum: %s, File: %s' % (STAXMachine, STAX_checksum, STAXMach_FileName) + \
                                    '\n  Test Machine (%s) checksum: %s, File: %s' % (TestMach, TestMach_checksum, TestMach_FileName),
                      'sendToMonitor': 1,
                      'recordStatus': 1 }
                  </call>

                </sequence>
              </iterate>

              <stafcmd>
                <location>TestMach</location>
                <service>'FS'</service>
                <request>'DELETE ENTRY {STAF/DataDir}/user/STAFTestChecksum.txt'</request>
              </stafcmd>

            </sequence>
          </if>

          <!-- On Unix machines, create a symbolic link called STAFTestSymlink.txt in '{STAF/DataDir}/tmp/%s' % (TestMach)
                on the STAX (local) machine and verify that the FS GET ENTRY LINKTARGET request works correctly -->

          <if expr="TestMachOSType.find('Win') != 0 and TestMachOSType.find('Unknown Win') != 0">
            <sequence>

              <script>
                symlinkFileName = '{STAF/DataDir}/user/STAFTestSymlink.txt'
                symlinkTarget = '{STAF/DataDir}/user/STAFTest.txt'
                command = 'ln -s %s %s' % (symlinkTarget, symlinkFileName)
              </script>

              <stafcmd>
                <location>TestMach</location>
                <service>'VAR'</service>
                <request>'RESOLVE STRING {STAF/DataDir}'</request>
              </stafcmd>

              <if expr="RC == STAFRC.Ok">
                <script>resSymlinkTarget = '%s/user/STAFTest.txt' % (STAFResult)</script>
                <else>
                  <script>resSymlinkTarget = symlinkTarget</script>
                </else>
              </if>
              
              <!-- Make sure the symlinkFileName file does not exist -->

              <stafcmd>
                <location>TestMach</location>
                <service>'FS'</service>
                <request>'DELETE ENTRY %s CONFIRM' % (symlinkFileName)</request>
              </stafcmd>
                            
              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok or RC == STAFRC.DoesNotExist,
                  'failMsg': 'STAF %s FS DELETE ENTRY %s CONFIRM failed.  RC=%s STAFResult=%s' % \
                               (TestMach, symlinkFileName, RC, STAFResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

              <log message="1">
                'Create a symbolic link:  STAF %s PROCESS START SHELL COMMAND %s RETURNSTDOUT STDERRTOSTDOUT WAIT' % \
                (TestMach, STAFUtil.wrapData(command))
              </log>

              <process>
                <location>TestMach</location>
                <command mode="'shell'">command</command>
                <workdir>'{STAF/DataDir}/user'</workdir>
                <stderr mode="'stdout'"/>
                <returnstdout/>
              </process>
              
              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'Creating a symbolic link failed.  RC=%s STAFResult=%s STAXResult=%s' % (RC, STAFResult, STAXResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

              <stafcmd>
                <location>TestMach</location>
                <service>'FS'</service>
                <request>'GET ENTRY %s LINKTARGET' % (symlinkFileName)</request>
              </stafcmd>
              
              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok and STAFResult == resSymlinkTarget,
                  'failMsg': 'STAF %s FS GET ENTRY %s LINKTARGET failed.  RC=%s STAFResult=%s Expected STAFResult=%s' % \
                             (TestMach, symlinkFileName, RC, STAFResult, resSymlinkTarget),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

              <stafcmd>
                <location>TestMach</location>
                <service>'FS'</service>
                <request>'QUERY ENTRY %s' % (symlinkFileName)</request>
              </stafcmd>
              
              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok and STAFResult['linkTarget'] == resSymlinkTarget,
                  'failMsg': 'STAF %s FS QUERY ENTRY %s failed.  RC=%s Result=%s Expected Result=%s' % \
                             (TestMach, symlinkFileName, RC, STAFResult, resSymlinkTarget),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>
              
              <stafcmd>
                <location>TestMach</location>
                <service>'FS'</service>
                <request>'LIST DIRECTORY {STAF/DataDir}/user NAME STAFTestSymlink EXT txt LONG'</request>
              </stafcmd>
              
              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok and len(STAFResult) == 1 and STAFResult[0]['linkTarget'] == resSymlinkTarget,
                  'failMsg': 'STAF %s FS LIST DIRECTORY {STAF/DataDir}/user NAME STAFTestSymlink EXT txt LONG failed.  RC=%s Result=%s Expected linkTarget=%s' % \
                             (TestMach, RC, STAFResult, resSymlinkTarget),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>
              
              <stafcmd>
                <location>TestMach</location>
                <service>'FS'</service>
                <request>'LIST DIRECTORY {STAF/DataDir}/user NAME STAFTestSymlink EXT txt LONG DETAILS'</request>
              </stafcmd>
              
              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok and len(STAFResult) == 1 and STAFResult[0]['linkTarget'] == resSymlinkTarget,
                  'failMsg': 'STAF %s FS LIST DIRECTORY {STAF/DataDir}/user NAME STAFTestSymlink EXT txt LONG DETAILSfailed.  RC=%s Result=%s Expected linkTarget=%s' % \
                             (TestMach, RC, STAFResult, resSymlinkTarget),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

            </sequence>
          </if>

          <!-- Test that when using FS LIST DIRECTORY to list each directory in testDirectoryNameList,
                the result contains at least 1 entry.  Note that on Windows, this list contains directory names
                like C:, C:\, C:/, \STAF, \STAF\bin and on Unix, this list contains directory names like /  -->
          <iterate var="dirName" in="testDirectoryNameList">
            <sequence>

              <script>request = 'LIST DIRECTORY %s' % (dirName)</script>
              <message>'Testing machine: %s service: FS request: %s' % (TestMach, request)</message>

              <stafcmd>
                <location>TestMach</location>
                <service>'FS'</service>
                <request>request</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok and len(STAFResult) > 0,
                  'failMsg': 'STAF %s FS %s failed.  RC=%s Result=%s' % \
                             (TestMach, request, RC, STAFResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

            </sequence>
          </iterate>

          <!-- Test the maximum return file size by setting the STAF/MaxReturnFileSize variable for this job -->

          <script>request = 'SET VAR "STAF/MaxReturnFileSize=10"'</script>
          <message>'Testing machine: %s service: FS request: %s' % ('local', request)</message>
        
          <stafcmd>
            <location>'local'</location>
            <service>'VAR'</service>
            <request>request</request>
          </stafcmd>
        
          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
            'failMsg': 'STAF %s FS %s failed.  RC=%s Result=%s' % \
            ('local', request, RC, STAFResult),
            'sendToMonitor': 1, 'recordStatus': 1 }
          </call>
        
          <script>request = 'GET FILE {STAF/Config/ConfigFile} TEXT FORMAT AsIs'</script>
          <message>'Testing machine: %s service: FS request: %s' % (TestMach, request)</message>
        
          <stafcmd>
            <location>TestMach</location>
            <service>'FS'</service>
            <request>request</request>
          </stafcmd>
        
          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.MaximumSizeExceeded,
            'failMsg': 'STAF %s FS %s failed.  RC=%s Result=%s' % \
            (TestMach, request, RC, STAFResult),
            'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <!-- Reset back to no maximum return file size -->

          <script>request = 'SET VAR "STAF/MaxReturnFileSize=0"'</script>
          <message>'Testing machine: %s service: FS request: %s' % ('local', request)</message>
        
          <stafcmd>
            <location>'local'</location>
            <service>'VAR'</service>
            <request>request</request>
          </stafcmd>
        
          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
            'failMsg': 'STAF %s FS %s failed.  RC=%s Result=%s' % \
            ('local', request, RC, STAFResult),
            'sendToMonitor': 1, 'recordStatus': 1 }
          </call>
        
          <!-- Verify that no longer get an error retrieving the stdout file due to exceeded the maximum return file size -->

          <script>request = 'GET FILE {STAF/Config/ConfigFile} TEXT FORMAT AsIs'</script>
          <message>'Testing machine: %s service: FS request: %s' % (TestMach, request)</message>
        
          <stafcmd>
            <location>TestMach</location>
            <service>'FS'</service>
            <request>request</request>
          </stafcmd>
        
          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok and len(STAFResult) > 10,
            'failMsg': 'STAF %s FS %s failed.  RC=%s Result=%s' % \
            (TestMach, request, RC, STAFResult),
            'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <!-- On Windows, test that if "FS LIST DIRECTORY C:\ NAME pagefile EXT sys TYPE F"
                includes a file named pagefile.sys, that a FS QUERY ENTRY C:\pagefile.sys request
                successfully returns 0 -->

          <if expr="TestMachOSType.find('Win') == 0">
            <sequence>

                <script>request = 'LIST DIRECTORY {STAF/Config/BootDrive}\ NAME pagefile EXT sys TYPE F'</script>
                <message>'Testing machine: %s service: FS request: %s' % (TestMach, request)</message>

                <stafcmd>
                  <location>TestMach</location>
                  <service>'FS'</service>
                  <request>request</request>
                </stafcmd>

                <if expr="RC == STAFRC.Ok and len(STAFResult) == 1">
                  <sequence>

                    <script>request = 'QUERY ENTRY {STAF/Config/BootDrive}\pagefile.sys'</script>
                    <message>'Testing machine: %s service: FS request: %s' % (TestMach, request)</message>

                    <stafcmd>
                      <location>TestMach</location>
                      <service>'FS'</service>
                      <request>request</request>
                    </stafcmd>

                    <call function="'STAXUtilCheckSuccess'">
                      { 'result': RC == STAFRC.Ok,
                        'failMsg': 'STAF %s FS %s failed.  RC=%s Result=%s' % \
                                   (TestMach, request, RC, STAFResult),
                        'sendToMonitor': 1,
                        'recordStatus': 1 }
                    </call>

                  </sequence>
                </if>

            </sequence>
          </if>

        </sequence>
      </testcase>

      <script>

      FSTests = [

        #
        #FS tests
        #

        [ 'STD:FS', 'SEM', 'REQUEST MUTEX STAFTest/FS',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:FS', 'FS', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],
        
        # Test SET and LIST SETTINGS commands
        
        [ 'STD:FS', 'FS', 'SET STRICTFSCOPYTRUST Disabled',
          [ STAFRC.Ok ], r'^$',
        ],
        
        [ 'STD:FS', 'FS', 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['strictFSCopyTrust'] == 'Disabled'"
        ],

        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/FSStrictFSCopyTrust=Enabled',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS', 'SET STRICTFSCOPYTRUST {STAFTest/FSStrictFSCopyTrust}',
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:FS', 'FS', 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['strictFSCopyTrust'] == 'Enabled'"
        ],
        
        [ 'STD:FS', 'VAR', 'DELETE VAR STAFTest/FSStrictFSCopyTrust',
          [ STAFRC.Ok ], r'^$'
        ],

        # Test that specifying the name of a file instead of the name of a directory causes LIST DIRECTORY to fail
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/Config/ConfigFile}',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        
        # Test that specifying the name of an existing file instead of the name of a directory causes CREATE DIRECTORY to fail
        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/Config/ConfigFile}',
          [ STAFRC.AlreadyExists ], r'.*'
        ],

        # Test that trailing slash(es) in the directory name when creating a directory works
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest RECURSE CONFIRM',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest/',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest//',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest.XXX TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        # Test to make sure get error if try to copy a file over itself
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.XXX TOFILE {STAF/DataDir}/user/STAFTest.XXX TOMACHINE %s' % TestMach,
          [ STAFRC.FileWriteError ], None
        ],

        # Test to make sure get error if try to copy a file over itself
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.XXX TODIRECTORY {STAF/DataDir}/user TOMACHINE  %s' % TestMach,
          [ STAFRC.FileWriteError ], None
        ],

        # Test to make sure get error if try to copy a file to a directory that does not exist
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.XXX TODIRECTORY {STAF/DataDir}/DoesNotExist TOMACHINE  %s' % TestMach,
          [ STAFRC.FileOpenError ], None
        ]
      ]
      </script>

      <!--  Only can copy a file to a directory if the test machine is not the local STAX machine -->
      <if expr="not testMachineIsLocal">
       <script>
        # Create a value for TestMach that can be used as part of a file name (e.g. doesn't contain any slashes or colons)
        # Note:  Only win64 does not seem to allow colons in file names
        TestMachNoSlash = TestMach.replace('/', '-')
        TestMachNoSlash = TestMachNoSlash.replace(':', '-')

        FSTests = FSTests + [
        
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest_%s.XXX TOMACHINE %s' % (TestMachNoSlash, TestMach),
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest_%s TOMACHINE %s' % (TestMachNoSlash, TestMach),
          [ STAFRC.Ok ], r'^$'
        ],
        # Use TODIRECTORY to copy a file whose name has a extension from the test machine to the STAX machine's tmp directory
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest_%s.XXX TODIRECTORY {STAF/DataDir}/tmp' % (TestMachNoSlash),
          [ STAFRC.Ok ], None
        ],
        # Use TODIRECTORY to copy a file whose name has no extension from the test machine to the STAX machine's tmp directory
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest_%s TODIRECTORY {STAF/DataDir}/tmp' % (TestMachNoSlash),
          [ STAFRC.Ok ], None
        ],
        # Clean-up files on test machine from this test
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest_%s.XXX CONFIRM' % (TestMachNoSlash),
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest_%s CONFIRM' % (TestMachNoSlash),
          [ STAFRC.Ok ], None
        ]
      ]
       </script>
      </if>

      <script>
        FSTests = FSTests + [

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest.YYY TOMACHINE %s FAILIFNEW' % TestMach,
          [ STAFRC.FileOpenError ], None
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest.XXX TOMACHINE %s FAILIFEXISTS' % TestMach,
          [ STAFRC.FileOpenError ], None
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/STAFRoot}/nonexistent.xyz TOFILE {STAF/DataDir}/user/nonexistent.abc TOMACHINE %s' % TestMach,
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.noExist',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest.XXX TOMACHINE %s TEXT' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt',
          [ STAFRC.Ok ], textResultNative
        ],

        # Verify that if a trailing slash is specified in a GET FILE request that it still works
        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt/',
          [ STAFRC.Ok ], textResultNative
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT',
          [ STAFRC.Ok ], textResultNative
        ],

        # Use the undocumented TEST option to verify that the line-endings were converted correctly (in hex)

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEST',
          [ STAFRC.Ok ], textResultNativeHex
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT TEST',
          [ STAFRC.Ok ], textResultNativeHex
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT NaTiVe',
          [ STAFRC.Ok ], textResultNative
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT WIndOws',
          [ STAFRC.Ok ], textResultWindows
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT WIndOws TEST',
          [ STAFRC.Ok ], textResultWindowsHex
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT UNix',
          [ STAFRC.Ok ], textResultUnix
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT UNix TEST',
          [ STAFRC.Ok ], textResultUnixHex
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], TestMachTextResult
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT " "',
          [ STAFRC.Ok ], textResultSpace
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT "##>"',
          [ STAFRC.Ok ], textResultOther
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt BINARY',
          [ STAFRC.Ok ], binResult
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt BINARY FORMAT HEX',
          [ STAFRC.Ok ], binResult
        ],

        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/FSFormat=Native',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT {STAFTest/FSFormat}',
          [ STAFRC.Ok ], textResultNative
        ],

        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/FSFormat=AsIS',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT {STAFTest/FSFormat}',
          [ STAFRC.Ok ], TestMachTextResult
        ],

        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/FSFormat=Hex',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt BINARY FORMAT {STAFTest/FSFormat}',
          [ STAFRC.Ok ], binResult
        ],

        # Verify some parsing errors
        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT BINARY',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT BINARY FORMAT Native',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt FORMAT Native',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt BINARY FORMAT Native',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt BINARY FORMAT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX MODTIME',
          [ STAFRC.Ok ], r'\d\d\d\d\d\d\d\d-\d\d:\d\d:\d\d'
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX TYPE',
          [ STAFRC.Ok ], r'F'
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX SIZE',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['size']) > 0 and " +
          "string.atoi(STAFResult['upperSize']) == 0 and " +
          "string.atoi(STAFResult['lowerSize']) > 0"
        ],
        
        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX LINKTARGET',
          [ STAFRC.Ok ], None,
          "STAFResult == '&lt;None>'"
        ],

        # Verify that if a trailing slash is specified in a GET ENTRY request that it still works
        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/ MODTIME',
          [ STAFRC.Ok ], r'\d\d\d\d\d\d\d\d-\d\d:\d\d:\d\d' ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX/ SIZE',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['size']) > 0 and " +
          "string.atoi(STAFResult['upperSize']) == 0 and " +
          "string.atoi(STAFResult['lowerSize']) > 0"
        ]
      ]
      </script>
      
      <if expr="TestMachHasSSL">
        <script>
        FSTests = FSTests + [
        
          [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX CHECKSUM',
            [ STAFRC.Ok ], r'^.'
          ],
        
          [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX CHECKSUM MD5',
            [ STAFRC.Ok ], r'^.'
          ],
        
          [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX CHECKSUM SHA1',
            [ STAFRC.Ok ], r'^.'
          ],

          # Specify an invalid checksum value (e.g. XXX)
          [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX CHECKSUM XXX',
            [ STAFRC.InvalidValue ], r'^.'
          ],
          
          # Cannot get the checksum for a directory, only for a file
          [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user CHECKSUM',
            [ STAFRC.InvalidValue ], r'^.'
          ]
        ]
        </script>
        <else>
          <script>
          FSTests = FSTests + [
            [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTest.XXX CHECKSUM',
              [ STAFRC.InvalidRequestString ], r'^.'
            ]
          ]
          </script>
        </else>
      </if>

      <script>
       FSTests = FSTests + [

        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest.XXX',
          [ STAFRC.Ok ], None,
          "STAFResult['name'].endswith('STAFTest.XXX') and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) > 0 and " +
          "int(STAFResult['upperSize']) == 0 and " +
          "int(STAFResult['lowerSize']) > 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ],

        # Verify that if a trailing slash is specified in a file name in a QUERY ENTRY request that it still works.
        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest.XXX/',
          [ STAFRC.Ok ], None,
          "STAFResult['name'].endswith('STAFTest.XXX') and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) > 0 and " +
          "int(STAFResult['upperSize']) == 0 and " +
          "int(STAFResult['lowerSize']) > 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ],

        # Verify that if a trailing slash is specified in a directory name in a QUERY ENTRY request that it still works.
        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/',
          [ STAFRC.Ok ], None,
          "STAFResult['name'].endswith('user') and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'D' and " +
          "int(STAFResult['size']) >= 0 and " +
          "int(STAFResult['upperSize']) == 0 and " +
          "int(STAFResult['lowerSize']) >= 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ],

        # Verify that specifying an empty string for the NAME and XXX for EXT doesn't delete any files (since no entries exist named .XXX)
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user CHILDREN NAME :0: EXT XXX CONFIRM',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest.XXX',
          [ STAFRC.Ok ], None
        ],
        
        # Verify that specifying an empty string for the EXT and STAFTest for NAME doesn't delete any files (since no entries exist named STAFTest)
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user CHILDREN NAME STAFTest EXT :0: CONFIRM',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest.XXX',
          [ STAFRC.Ok ], None
        ],

        # Verify that if a trailing slash is specified in the ENTRY name that the delete still works.
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest.XXX/ CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest.YYY CONFIRM',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.YYY TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        # Verify that if a trailing slash is specified in the FILE name that the copy still works.
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile}/ TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYY TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        # Verify that if a trailing slash is specified in the TOFILE name (when the tofile already exists) that the copy still works.
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYY/ TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Verify copy fails with RC 13 if specify TOFILE name STAFTest{NotAVar}.XXX where NotAVar does not represent a STAF variable
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest{NotAVar}.XXX/ TOMACHINE %s' % (TestMach),
          [ STAFRC.VariableDoesNotExist ], r'^.*'
        ],

        # Verify copy works if specify TOFILE name. STAFTest^{NotAVar}.XXX, where we escape the { with a caret
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest^{NotAVar}.XXX/ TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0] == 'STAFTest.XYY' and STAFResult[1] == 'STAFTest.YYY' and STAFResult[2] == 'STAFTest{NotAVar}.XXX'"
        ],
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest/STAFTest^{NotAVar}.XXX CONFIRM',
          [ STAFRC.Ok ], None
        ],

        # Verify that if a trailing slash is specified in the DIRECTORY name that the LIST DIRECTORY still works.
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest/',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and STAFResult[1] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/fileType=F VAR STAFTest/types=DF',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/namePattern=STAF* VAR STAFTest/extPattern=*yy',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME {STAFTest/namePattern} EXT X* TYPE {STAFTest/fileType}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest EXT {STAFTest/extPattern} TYPE F SORTBYNAME CASEINSENSITIVE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME staf* EXT X* TYPE F CASEINSENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME staf* TYPE F CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME ?TAFTes? EXT YYY TYPE F SORTBYMODTIME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME ?TAFTes? EXT YYY TYPE F SORTBYSIZE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.YYY'"
        ],
        
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME :0:',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest EXT :0:',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAF* LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'].find('STAFTest.') >= 0 and " +
          "STAFResult[0]['linkTarget'] == None and " +
          "STAFResult[0]['type'] == 'F' and " +
          "int(STAFResult[0]['size']) > 0 and " +
          "STAFResult[0]['lastModifiedTimestamp']"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest LONG DETAILS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['type'] == 'F' and " +
          "STAFResult[0]['name'] and " +
          "STAFResult[0]['linkTarget'] == None and " +
          "int(STAFResult[0]['size']) > 0 and " +
          "int(STAFResult[0]['upperSize']) == 0 and " +
          "int(STAFResult[0]['lowerSize']) > 0 and " +
          "STAFResult[0]['lastModifiedTimestamp']"
        ],
        
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest LONG DETAILS RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['type'] == 'F' and " +
          "STAFResult[0]['name'] and " +
          "STAFResult[0]['linkTarget'] == None and " +
          "int(STAFResult[0]['size']) > 0 and " +
          "int(STAFResult[0]['upperSize']) == 0 and " +
          "int(STAFResult[0]['lowerSize']) > 0 and " +
          "STAFResult[0]['lastModifiedTimestamp']"
        ],
        
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest SUMMARY TYPE F NAME STAF* EXT *',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "int(STAFResult['size']) > 0 and " +
          "int(STAFResult['numFiles']) == 2 and " +
          "int(STAFResult['numDirectories']) == 0"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest SUMMARY',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "int(STAFResult['size']) > 0 and " +
          "int(STAFResult['numFiles']) == 2 and " +
          "int(STAFResult['numDirectories']) == 0"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest SUMMARY RECURSE',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "int(STAFResult['size']) > 0 and " +
          "int(STAFResult['numFiles']) == 2 and " +
          "int(STAFResult['numDirectories']) == 0"
        ],

        # Check some LIST parsing errors

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest LONG SUMMARY',
          [ STAFRC.InvalidRequestString ], r'^.*'
        ],
        
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest DETAILS SUMMARY',
          [ STAFRC.InvalidRequestString ], r'^.*'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME staf* EXT X* TYPE F CASEINSENSITIVE CASESENSITIVE',
          [ STAFRC.InvalidRequestString ], r'^.*'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest TYPE F TYPE D',
          [ STAFRC.InvalidRequestString ], r'^.*'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest SORTBYNAME SOTRTBYMODTIME SORTBYSIZE',
          [ STAFRC.InvalidRequestString ], r'^.*'
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest FAILIFEXISTS',
          [ STAFRC.AlreadyExists ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest/subdir1/subdir2',
          [ STAFRC.BaseOSError ], None
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest/subdir1/subdir2 FULLPATH',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest TYPE {STAFTest/types} SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYY' and " +
          "STAFResult[2] == 'subdir1'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest/subdir1 TYPE {STAFTest/types}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'subdir2'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest TYPE {STAFTest/types} SORTBYNAME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 4 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYY' and " +
          "STAFResult[2] == 'subdir1' and " +
          "STAFResult[3] == 'subdir1%ssubdir2'" % (TestMachPathSep)
        ],
        
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME subdir* CASESENSITIVE SORTBYSIZE RECURSE',
          [ STAFRC.Ok ], None,
          # Note that on SLES 10 machines, the size of a directory increase when you add subdirectories so the size 
          # of subdir1/subdir2 is less than the size of subdir1.
          "len(STAFResult) == 2 and " +
          "(STAFResult[0] == 'subdir1' and STAFResult[1] == 'subdir1%ssubdir2') or " % (TestMachPathSep) +
          "(STAFResult[0] == 'subdir1%ssubdir2' and STAFResult[1] == 'subdir1')" % (TestMachPathSep)
        ],
        
        # Directories subdir1 and subdir1/subdir2 may have the same timestamp so could be in either order
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME subdir* TYPE D SORTBYMODTIME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) ==  2 and " +
          "(STAFResult[0] == 'subdir1' or STAFResult[0] == 'subdir1%ssubdir2') and " % (TestMachPathSep) +
          "(STAFResult[1] == 'subdir1%ssubdir2' or STAFResult[1] == 'subdir1')" % (TestMachPathSep)
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME subdir* TYPE F SORTBYNAME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) ==  0"
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest/subdir1 CONFIRM',
          [ STAFRC.DirectoryNotEmpty ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest/subdir1 RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        # Verify that if a trailing slash is specified in the path for a CREATE DIRECTORY FULLPATH request that it still works.
        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest/subdirA/subdirB/ FULLPATH',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest/subdirA/subdirB',
          [ STAFRC.Ok ], None,
          "STAFResult['name'].endswith('subdirB') and " +
          "STAFResult['type'] == 'D' and " +
          "int(STAFResult['size']) >= 0 and " +
          "int(STAFResult['upperSize']) == 0 and " +
          "int(STAFResult['lowerSize']) >= 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ],

        # Verify that if a trailing slash is specified in the ENTRY name that the delete still works.
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest/subdirA/ RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest/subdirA/subdirB',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYYY TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.YYX TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYYXYY TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYYYYY TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYYYXY TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYYYXX TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYYXYXY TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?Y? SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYX' and " +
          "STAFResult[2] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ??Y SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?YY SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ??? SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYX' and " +
          "STAFResult[2] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT Y*X? SORTBYNAME',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT Y*X*X? SORTBYNAME',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?? SORTBYNAME',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?Y*X*X? SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYXYXY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?Y*X*X SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYYXX'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?Y*X*Y SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYXYXY' and " +
          "STAFResult[1] == 'STAFTest.XYYXYY' and " +
          "STAFResult[2] == 'STAFTest.XYYYXY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?Y*X*Y? SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYXYY'"
        ],

        # OK that XYYXYXY is not included in following request's list since backtracking is not done
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT *Y*X? SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYYXX' and " +
          "STAFResult[1] == 'STAFTest.XYYYXY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT *Y*X* SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYXYXY' and " +
          "STAFResult[1] == 'STAFTest.XYYXYY' and " +
          "STAFResult[2] == 'STAFTest.XYYYXX' and " +
          "STAFResult[3] == 'STAFTest.XYYYXY' and " +
          "STAFResult[4] == 'STAFTest.YYX'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT *Y*X SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYYXX' and " +
          "STAFResult[1] == 'STAFTest.YYX'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?Y*X* SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYXYXY' and " +
          "STAFResult[1] == 'STAFTest.XYYXYY' and " +
          "STAFResult[2] == 'STAFTest.XYYYXX' and " +
          "STAFResult[3] == 'STAFTest.XYYYXY' and " +
          "STAFResult[4] == 'STAFTest.YYX'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?Y*X SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYYXX' and " +
          "STAFResult[1] == 'STAFTest.YYX'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?Y* SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.XYYXYXY' and " +
          "STAFResult[2] == 'STAFTest.XYYXYY' and " +
          "STAFResult[3] == 'STAFTest.XYYY' and " +
          "STAFResult[4] == 'STAFTest.XYYYXX' and " +
          "STAFResult[5] == 'STAFTest.XYYYXY' and " +
          "STAFResult[6] == 'STAFTest.XYYYYY' and " +
          "STAFResult[7] == 'STAFTest.YYX' and " +
          "STAFResult[8] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ?Y?* SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.XYYXYXY' and " +
          "STAFResult[2] == 'STAFTest.XYYXYY' and " +
          "STAFResult[3] == 'STAFTest.XYYY' and " +
          "STAFResult[4] == 'STAFTest.XYYYXX' and " +
          "STAFResult[5] == 'STAFTest.XYYYXY' and " +
          "STAFResult[6] == 'STAFTest.XYYYYY' and " +
          "STAFResult[7] == 'STAFTest.YYX' and " +
          "STAFResult[8] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ??* SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.XYYXYXY' and " +
          "STAFResult[2] == 'STAFTest.XYYXYY' and " +
          "STAFResult[3] == 'STAFTest.XYYY' and " +
          "STAFResult[4] == 'STAFTest.XYYYXX' and " +
          "STAFResult[5] == 'STAFTest.XYYYXY' and " +
          "STAFResult[6] == 'STAFTest.XYYYYY' and " +
          "STAFResult[7] == 'STAFTest.YYX' and " +
          "STAFResult[8] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT *?? SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.XYYXYXY' and " +
          "STAFResult[2] == 'STAFTest.XYYXYY' and " +
          "STAFResult[3] == 'STAFTest.XYYY' and " +
          "STAFResult[4] == 'STAFTest.XYYYXX' and " +
          "STAFResult[5] == 'STAFTest.XYYYXY' and " +
          "STAFResult[6] == 'STAFTest.XYYYYY' and " +
          "STAFResult[7] == 'STAFTest.YYX' and " +
          "STAFResult[8] == 'STAFTest.YYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ??*?? SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYXYXY' and " +
          "STAFResult[1] == 'STAFTest.XYYXYY' and " +
          "STAFResult[2] == 'STAFTest.XYYY' and " +
          "STAFResult[3] == 'STAFTest.XYYYXX' and " +
          "STAFResult[4] == 'STAFTest.XYYYXY' and " +
          "STAFResult[5] == 'STAFTest.XYYYYY'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest NAME STAFTest EXT ???? SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest.XYYY'"
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest CHILDREN CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir1/subDir1.1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir2',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir2/subDir2.1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.YYY TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYY TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/subDir1/STAFTestSub1.XXX TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/subDir1/STAFTestSub1.YXX TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/subDir2/STAFTestSub2.XXY TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/subDir2/STAFTestSub2.YYX TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/Config/ConfigFile} TOFILE {STAF/DataDir}/user/STAFTest/subDir2/subDir2.1/XXX TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        ###Non-Recurse w/ ext
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestDest RECURSE CONFIRM',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTestDest TOMACHINE %s EXT XXX CASESENSITIVE' %TestMach,
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestDest',
          [ STAFRC.Ok ], None
        ],

        ###FailIfNew/FailIfExists
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTestDest TOMACHINE %s FAILIFEXISTS' % TestMach,
          [ STAFRC.AlreadyExists ], None
        ],

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTestNew TOMACHINE %s FAILIFNEW' % TestMach,
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestDest CONFIRM',
          [ STAFRC.Ok ], None
        ],
        
        # Test to make sure get a DirectoryCopyError if try to copy a directory over itself using the RECURSE option
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTest TOMACHINE %s RECURSE' % TestMach,
          [ STAFRC.FileWriteError ], None
        ],
        
        # Test to make sure get error if try to copy a directory to a directory that includes the from directory on the
        # same machine using the RECURSE option (e.g. a cyclic copy)
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTest/JJJ TOMACHINE %s RECURSE' % TestMach,
          [ STAFRC.DirectoryCopyError ], None
        ],

        # Verify copy fails with RC 13 if specify TODIRECTORY name, STAFTest{NotAVar}, where NotAVar does not represent a STAF variable
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTest{NotAVar} TOMACHINE %s RECURSE' % (TestMach),
          [ STAFRC.VariableDoesNotExist ], r'^.*'
        ],

        # Verify copy works if specify TODIRECTORY name, STAFTest^{NotAVar}, where we escape the { with a caret
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest^{NotAVar} CONFIRM RECURSE',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTest^{NotAVar} TOMACHINE %s RECURSE' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTest^{NotAVar} CASESENSITIVE SORTBYNAME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 10 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYY' and " +
          "STAFResult[2] == 'subDir1' and " +
          "STAFResult[3] == 'subDir1%sSTAFTestSub1.XXX' and " % (TestMachPathSep)+
          "STAFResult[4] == 'subDir1%sSTAFTestSub1.YXX' and " % (TestMachPathSep) +
          "STAFResult[5] == 'subDir2' and " +
          "STAFResult[6] == 'subDir2%sSTAFTestSub2.XXY' and " % (TestMachPathSep) +
          "STAFResult[7] == 'subDir2%sSTAFTestSub2.YYX' and " % (TestMachPathSep) +
          "STAFResult[8] == 'subDir2%ssubDir2.1' and " % (TestMachPathSep) +
          "STAFResult[9] == 'subDir2%ssubDir2.1%sXXX'" % (TestMachPathSep, TestMachPathSep)
        ],
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest^{NotAVar} CONFIRM RECURSE',
          [ STAFRC.Ok ], None
        ],

        ###recurse w/ no option
        # Verify that if a trailing slash is specified in the DIRECTORY name that the copy still works correctly.
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest/ TODIRECTORY {STAF/DataDir}/user/STAFTestDest TOMACHINE %s RECURSE' %TestMach,
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestDest CASESENSITIVE SORTBYNAME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 10 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYY' and " +
          "STAFResult[2] == 'subDir1' and " +
          "STAFResult[3] == 'subDir1%sSTAFTestSub1.XXX' and " % (TestMachPathSep)+
          "STAFResult[4] == 'subDir1%sSTAFTestSub1.YXX' and " % (TestMachPathSep) +
          "STAFResult[5] == 'subDir2' and " +
          "STAFResult[6] == 'subDir2%sSTAFTestSub2.XXY' and " % (TestMachPathSep) +
          "STAFResult[7] == 'subDir2%sSTAFTestSub2.YYX' and " % (TestMachPathSep) +
          "STAFResult[8] == 'subDir2%ssubDir2.1' and " % (TestMachPathSep) +
          "STAFResult[9] == 'subDir2%ssubDir2.1%sXXX'" % (TestMachPathSep, TestMachPathSep)
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestDest RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        ###Recurse w/ name
        # Verify that if a trailing slash is specified in the DIRECTORY and TODIRECTORY names that the copy still works correctly.
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest/ TODIRECTORY {STAF/DataDir}/user/STAFTestDest/ TOMACHINE %s NAME XXX CASESENSITIVE RECURSE' %TestMach,
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestDest CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'subDir2'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestDest/subDir2 CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'subDir2.1'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestDest/subDir2/subDir2.1 CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0].find('XXX') >=0"
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestDest RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        ###Recurse w/ name, caseinsensitive
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTestDest TOMACHINE %s NAME staf* CASEINSENSITIVE RECURSE' %TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestDest CASESENSITIVE SORTBYNAME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 8 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYY' and " +
          "STAFResult[2] == 'subDir1' and " +
          "STAFResult[3] == 'subDir1%sSTAFTestSub1.XXX' and " % (TestMachPathSep) +
          "STAFResult[4] == 'subDir1%sSTAFTestSub1.YXX' and " % (TestMachPathSep) +
          "STAFResult[5] == 'subDir2' and " +
          "STAFResult[6] == 'subDir2%sSTAFTestSub2.XXY' and " % (TestMachPathSep) +
          "STAFResult[7] == 'subDir2%sSTAFTestSub2.YYX'" % (TestMachPathSep)
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestDest RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        ###Onlydirectories
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTestOnlyDir TOMACHINE %s RECURSE ONLYDIRECTORIES' %TestMach,
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestOnlyDir CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'subDir1' and " +
          "STAFResult[1] == 'subDir2'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestOnlyDir/subDir1 CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'subDir1.1'"
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestOnlyDir/subDir2 CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'subDir2.1'"
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestOnlyDir RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        ###Recurse w/ name, casesensitive, keepemptydirectories
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestDest RECURSE CONFIRM',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTest TODIRECTORY {STAF/DataDir}/user/STAFTestDest TOMACHINE %s NAME staf* CASEINSENSITIVE RECURSE KEEPEMPTYDIRECTORIES' %TestMach,
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestDest CASESENSITIVE SORTBYNAME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 10 and " +
          "STAFResult[0] == 'STAFTest.XYY' and " +
          "STAFResult[1] == 'STAFTest.YYY' and " +
          "STAFResult[2] == 'subDir1' and " +
          "STAFResult[3] == 'subDir1%sSTAFTestSub1.XXX' and " % (TestMachPathSep) +
          "STAFResult[4] == 'subDir1%sSTAFTestSub1.YXX' and " % (TestMachPathSep) +
          "STAFResult[5] == 'subDir1%ssubDir1.1' and " % (TestMachPathSep) +
          "STAFResult[6] == 'subDir2' and " +
          "STAFResult[7] == 'subDir2%sSTAFTestSub2.XXY' and " % (TestMachPathSep) +
          "STAFResult[8] == 'subDir2%sSTAFTestSub2.YYX' and " % (TestMachPathSep) +
          "STAFResult[9] == 'subDir2%ssubDir2.1'" % (TestMachPathSep)
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestDest/subDir1/subDir1.1 CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestDest/subDir2/subDir2.1 CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestDest RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        ### COPY FILE TEXT FORMAT CONVERT Tests

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestText RECURSE CONFIRM',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTestText',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestText CASESENSITIVE SORTBYNAME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0] == 'STAFTest.txt'"
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], TestMachTextResult
        ],

        # Now know we have a file on the TestMach with Native Line-endings that match the TestMach's platform
        # Use GET FILE TEXT FORMAT ASIS to verify that the file copied has the correct line-endings

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], TestMachTextResult
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], TestMachTextResult
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt FORMAT NaTiVe TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], TestMachTextResult
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT WiNdows TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultWindows
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT UnIx TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultUnix
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT " " TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultSpace
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt FORMAT "##>" TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultOther
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTestLarge.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTestLarge.txt FORMAT Windows TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestText/STAFTestLarge.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == textLargeWinSize"
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTestLarge.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTestLarge.txt FORMAT unix TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestText/STAFTestLarge.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == textLargeUnixSize"
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTestLargeEOL.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTestLargeEOL.txt FORMAT Windows TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestText/STAFTestLargeEOL.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == textEOLWinSize"
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTestLargeEOL.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTestLargeEOL.txt FORMAT unix TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestText/STAFTestLargeEOL.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == textEOLUnixSize"
        ],

        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/FSFormat=Unix',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT {STAFTest/FSFormat} TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultUnix
        ],

        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/FSFormat=Windows',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT {STAFTest/FSFormat} TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultWindows
        ],


        # Verify some parsing errors
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest.txt FORMAT Native TOMACHINE %s' % TestMach,
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestText RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        ### COPY DIRECTORY TEXTEXT FORMAT CONVERT Tests

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestText RECURSE CONFIRM',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTestText',
          [ STAFRC.Ok ], r'^$'
        ],

        # Same machine copy tests

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest1.bin TEXT FORMAT Unix TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest2.bin TEXT FORMAT Unix TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest1.txt TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest2.txt TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest2Unix.TXT TEXT FORMAT Unix TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest2Win.txT TEXT FORMAT Windows TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest3.html TEXT FORMAT Native TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTest3.htm TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestText CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest1.bin' and " +
          "STAFResult[1] == 'STAFTest1.txt' and " +
          "STAFResult[2] == 'STAFTest2.bin' and " +
          "STAFResult[3] == 'STAFTest2.txt' and " +
          "STAFResult[4] == 'STAFTest2Unix.TXT' and " +
          "STAFResult[5] == 'STAFTest2Win.txT' and " +
          "STAFResult[6] == 'STAFTest3.htm' and " +
          "STAFResult[7] == 'STAFTest3.html'"
        ],

        # Let's treat the .bin files as binary and the .txt files as text in a COPY DIRECTORY
        # Use GET FILE TEXT FORMAT ASIS to verify that the file copied has the correct line-endings

        # Copy from one directory to another on same system, files with name STAFTest1 and copy files with extension txt as text with native line-endings
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestTextCopy RECURSE CONFIRM', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],
        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/FSTextExt=txt', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy NAME STAFTest1 TEXTEXT {STAFTest/FSTextExt} TOMACHINE %s' % TestMach, [ STAFRC.Ok ], None ],
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestTextCopy CASESENSITIVE SORTBYNAME', [ STAFRC.Ok ],
          None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest1.bin' and " +
          "STAFResult[1] == 'STAFTest1.txt'"
        ],
        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest1.txt TEXT FORMAT AsIs', [ STAFRC.Ok ], TestMachTextResult ],
        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest1.bin TEXT FORMAT AsIs', [ STAFRC.Ok ], textResultUnix ],

        # Copy from one directory to another on same system, copying only files whose name starts with STAFTest
        # and copy files with extension txt as text with Windows line-endings
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestTextCopy RECURSE CONFIRM', [ STAFRC.Ok ], None ],
        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/FSFormat=WiNdows', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy NAME STAFTest2* TEXTEXT txt CASESENSITIVE FORMAT {STAFTest/FSFormat} TOMACHINE %s' % TestMach, [ STAFRC.Ok ], None ],
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestTextCopy CASESENSITIVE SORTBYNAME', [ STAFRC.Ok ],
          None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest2.bin' and " +
          "STAFResult[1] == 'STAFTest2.txt' and " +
          "STAFResult[2] == 'STAFTest2Unix.TXT' and " +
          "STAFResult[3] == 'STAFTest2Win.txT'"
        ],
        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2.txt TEXT FORMAT AsIs', [ STAFRC.Ok ], textResultWindows ],
        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2.bin BINARY', [ STAFRC.Ok ], binResultUnix ],
        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2Unix.TXT BINARY', [ STAFRC.Ok ], binResultUnix ],
        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2Win.txT BINARY', [ STAFRC.Ok ], binResultWindows ],

        # Copy from one directory to another on same system, copying only files whose name starts with STAFTest
        # and copy files with extension txt as text with Unix line-endings
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestTextCopy RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'VAR', 'SET VAR STAFTest/FSFormat=UniX',
          [ STAFRC.Ok ], r'^$'
        ],

        # Verfy that specifying an empty name works correctly (doesn't copy all entries, only entries with a blank name

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy NAME :0: TEXTEXT txt CASESENSITIVE FORMAT {STAFTest/FSFormat} TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], None
        ],
        
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestTextCopy',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        # Verfy that specifying an empty extension works correctly (doesn't copy all entries, only entries with a blank extension

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy EXT :0: TEXTEXT txt CASESENSITIVE FORMAT {STAFTest/FSFormat} TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], None
        ],
        
        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestTextCopy',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy NAME STAFTest2* TEXTEXT txt CASESENSITIVE FORMAT {STAFTest/FSFormat} TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestTextCopy CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest2.bin' and " +
          "STAFResult[1] == 'STAFTest2.txt' and " +
          "STAFResult[2] == 'STAFTest2Unix.TXT' and " +
          "STAFResult[3] == 'STAFTest2Win.txT'"
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultUnix
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2.bin BINARY',
          [ STAFRC.Ok ], binResultUnix
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2Unix.TXT BINARY',
          [ STAFRC.Ok ], binResultUnix
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2Win.txT BINARY',
          [ STAFRC.Ok ], binResultWindows
        ],

        # Copy from one directory to another on same system, copying only files whose extension is txt, case-insensitive
        # and copy files with extension T* as text with Native line-endings (but since case-insensitive, matches t* as well).
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestTextCopy RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy CASEINSENSITIVE EXT txt TEXTEXT T* FORMAT Native TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestTextCopy CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTest1.txt' and " +
          "STAFResult[1] == 'STAFTest2.txt' and " +
          "STAFResult[2] == 'STAFTest2Unix.TXT' and " +
          "STAFResult[3] == 'STAFTest2Win.txT'"
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest1.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], TestMachTextResult
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], TestMachTextResult
        ],

        # Verify some parsing errors
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy FORMAT Native TOMACHINE %s' % TestMach,
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy TEXT FORMAT Native FORMAT Unix TOMACHINE %s' % TestMach,
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        # Add some subdirectories for RECURSE with TEXTEXT testing
        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTestText/subdir1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/subdir1/STAFTest4.txt TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/subdir1/STAFTest5.TXT TEXT FORMAT UNIX TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTestText/subdir2',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestText CASESENSITIVE SORTBYNAME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 12 and " +
          "STAFResult[0] == 'STAFTest1.bin' and " +
          "STAFResult[1] == 'STAFTest1.txt' and " +
          "STAFResult[2] == 'STAFTest2.bin' and " +
          "STAFResult[3] == 'STAFTest2.txt' and " +
          "STAFResult[4] == 'STAFTest2Unix.TXT' and " +
          "STAFResult[5] == 'STAFTest2Win.txT' and " +
          "STAFResult[6] == 'STAFTest3.htm' and " +
          "STAFResult[7] == 'STAFTest3.html' and " +
          "STAFResult[8] == 'subdir1' and " +
          "STAFResult[9] == 'subdir1%sSTAFTest4.txt' and " % (TestMachPathSep) +
          "STAFResult[10] == 'subdir1%sSTAFTest5.TXT' and " % (TestMachPathSep) +
          "STAFResult[11] == 'subdir2'"
        ],

        # Copy recursively from one directory to another on same system, copying all files, and copy files with extension txt or htm* (case-sensitive)
        # as text using "##>" for the line-endings.
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestTextCopy RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy CASESENSITIVE TEXTEXT txt FORMAT "##>" TEXTEXT "htm*" RECURSE TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestTextCopy CASESENSITIVE SORTBYNAME RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 11 and " +
          "STAFResult[0] == 'STAFTest1.bin' and " +
          "STAFResult[1] == 'STAFTest1.txt' and " +
          "STAFResult[2] == 'STAFTest2.bin' and " +
          "STAFResult[3] == 'STAFTest2.txt' and " +
          "STAFResult[4] == 'STAFTest2Unix.TXT' and " +
          "STAFResult[5] == 'STAFTest2Win.txT' and " +
          "STAFResult[6] == 'STAFTest3.htm' and " +
          "STAFResult[7] == 'STAFTest3.html' and " +
          "STAFResult[8] == 'subdir1' and " +
          "STAFResult[9] == 'subdir1%sSTAFTest4.txt' and " % (TestMachPathSep) +
          "STAFResult[10] == 'subdir1%sSTAFTest5.TXT'" % (TestMachPathSep)
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest1.bin BINARY',
          [ STAFRC.Ok ], binResultUnix
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest1.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultOther
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultOther
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2.bin BINARY',
          [ STAFRC.Ok ], binResultUnix
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2Unix.TXT BINARY',
          [ STAFRC.Ok ], binResultUnix
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest2Win.txT BINARY',
          [ STAFRC.Ok ], binResultWindows
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest3.htm TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultOther
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/STAFTest3.html TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultOther
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/subdir1/STAFTest4.txt TEXT FORMAT AsIs',
          [ STAFRC.Ok ], textResultOther
        ],

        [ 'STD:FS', 'FS',  'GET FILE {STAF/DataDir}/user/STAFTestTextCopy/subdir1/STAFTest5.TXT BINARY',
          [ STAFRC.Ok ], binResultUnix
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestTextCopy RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestText RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        ###Buffer tests for textext dir copy
        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTestText',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTestSmall.txt TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTestLarge.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTestLarge.txt TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTestLargeEOL.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTestLargeEOL.txt TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestText CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0] == 'STAFTestLarge.txt' and " +
          "STAFResult[1] == 'STAFTestLargeEOL.txt' and " +
          "STAFResult[2] == 'STAFTestSmall.txt'"
        ],

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy TEXTEXT "*" format unix TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestTextCopy/STAFTestLargeEOL.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == textEOLUnixSize"
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestTextCopy/STAFTestLarge.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == textLargeUnixSize"
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestTextCopy/STAFTestSmall.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == textSmallUnixSize"
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestTextCopy RECURSE CONFIRM', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy TEXTEXT "*" format windows TOMACHINE %s' % TestMach, [ STAFRC.Ok ], None ],
        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestTextCopy/STAFTestLargeEOL.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == textEOLWinSize"
        ],

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestTextCopy/STAFTestLarge.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == textLargeWinSize"
        ],

        # Test copying a file with length 0 in binary mode
        
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTestEmpty.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTestEmpty.txt TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        # Verify that the file was copied successfully and has length 0

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestText/STAFTestEmpty.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == 0"
        ],

        # Delete the copied file
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestText/STAFTestEmpty.txt CONFIRM', [ STAFRC.Ok ], None ],

        # Test copying a file with length 0 in text mode

        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTestEmpty.txt TOFILE {STAF/DataDir}/user/STAFTestText/STAFTestEmpty.txt TEXT TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], r'^$'
        ],

        # Verify that the file was copied successfully and has length 0

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestText/STAFTestEmpty.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == 0"
        ],

        # Test copying a directory that contains a file with length 0 in binary mode
        
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTestEmpty.txt TODIRECTORY {STAF/DataDir}/user/STAFTestText TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy RECURSE TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], None
        ],

        # Verify that the file was copied successfully and has length 0

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestTextCopy/STAFTestEmpty.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == 0"
        ],

        # Delete the copied file
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestTextCopy/STAFTestEmpty.txt CONFIRM', [ STAFRC.Ok ], None ],

        # Test copying a file with length 0 in text mode
     
        [ 'STD:FS', 'FS',  'COPY DIRECTORY {STAF/DataDir}/user/STAFTestText TODIRECTORY {STAF/DataDir}/user/STAFTestTextCopy RECURSE TEXTEXT txt TOMACHINE %s' % TestMach,
          [ STAFRC.Ok ], None
        ],

        # Verify that the file was copied successfully and has length 0

        [ 'STD:FS', 'FS',  'GET ENTRY {STAF/DataDir}/user/STAFTestTextCopy/STAFTestEmpty.txt SIZE',
          [ STAFRC.Ok ], None,
          "int(STAFResult['size']) == 0"
        ],

        # Test DELETE ENTRY using CHILDREN TYPE ALL and RECURSE to delete all children in a directory but not the directory itself

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestText RECURSE CHILDREN TYPE ALL CONFIRM',
          [ STAFRC.Ok ], None
        ],

        # Verify that the directory still exists but is empty

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestText RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0" 
        ],
                
        # Test DELETE ENTRY using CHILDREN TYPE ALL and RECURSE to delete all children in an empty directory but not the directory itself

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestText RECURSE CHILDREN TYPE ALL CONFIRM',
          [ STAFRC.Ok ], None
        ],

        # Verify that the directory still exists but is empty

        [ 'STD:FS', 'FS',  'LIST DIRECTORY {STAF/DataDir}/user/STAFTestText RECURSE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0" 
        ],

        # Test MOVE requests

        # Verify that renaming a file and specifying a non-existing path in the new file name fails
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.XYY TOFILE {STAF/DataDir}/user/STAFTest/NoExist/STAFTest.XXX',
          [ STAFRC.MoveError ], r'^.'
        ],
        
        # Verify that renaming a non-existing file fails
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/NoExist.XYY TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XXX',
          [ STAFRC.DoesNotExist ], r'^.'
        ],

        # Verify that renaming a file and specifying the same file name fails or is successful (depending on the OS) but doesn't change the file
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.XYY TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XYY',
          [ STAFRC.MoveError, STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest/STAFTest.XYY',
          [ STAFRC.Ok ], None,
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) >= 10"
        ],

        # Verify that renaming a file and specifying an existing directory for the TOFILE option fails
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.XYY TOFILE {STAF/DataDir}/user/STAFTest',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        
        # Verify that renaming a file and specifying an existing directory for the FILE option fails
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XXX',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        # Verify renaming a file works
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.XYY TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XXX',
          [ STAFRC.Ok ], None
        ],

        # Verify renaming a file using the name of an existing file works (and it overwrites the file)
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.ZZZ TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.ZZZ TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.XXX',
          [ STAFRC.Ok ], None
        ],
        
        # Verify using spaces in the new name of a file works
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE {STAF/DataDir}/user/STAFTest/STAFTest.ZZZ TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.ZZZ TOFILE "{STAF/DataDir}/user/STAFTest/Test 1 2 3.txt"',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'CREATE DIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 1 2 3"',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'MOVE FILE "{STAF/DataDir}/user/STAFTest/Test 1 2 3.txt" TOFILE "{STAF/DataDir}/user/STAFTest/Dir 1 2 3/Test 1 2 3.txt"',
          [ STAFRC.Ok ], None
        ],
        
        # Verify using wildcards and spaces in a the name of a file being moved works
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TOFILE "{STAF/DataDir}/user/STAFTest/Dir 1 2 3/Test 1.txt" TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'CREATE DIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 4"',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'MOVE FILE "{STAF/DataDir}/user/STAFTest/Dir 1 2 3/Test 1*.txt" TODIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 4"',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'LIST DIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 4" CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0] == 'Test 1 2 3.txt' and " +
          "STAFResult[1] == 'Test 1.txt'"
        ],

        # Verify using multiple wildcards in a file name that contains spaces works

        [ 'STD:FS', 'FS',  'MOVE FILE "{STAF/DataDir}/user/STAFTest/Dir 4/T*** 1*.t*" TODIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 1 2 3"',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'LIST DIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 1 2 3" CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0] == 'Test 1 2 3.txt' and " +
          "STAFResult[1] == 'Test 1.txt'"
        ],
        [ 'STD:FS', 'FS',  'MOVE FILE "{STAF/DataDir}/user/STAFTest/Dir 1 2 3/Te***1*.txt" TODIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 4"',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'LIST DIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 4" CASESENSITIVE SORTBYNAME',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0] == 'Test 1 2 3.txt' and " +
          "STAFResult[1] == 'Test 1.txt'"
        ],

        # Verify moving a file to a non-existing directory fails
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.XXX TODIRECTORY {STAF/DataDir}/user/STAFTest/NoExist',
          [ STAFRC.DoesNotExist ], r'^.'
        ],
        
        # Verify moving a non-existing file to a directory fails
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/NoExist.XXX TODIRECTORY {STAF/DataDir}/user/STAFTest/subDir1',
          [ STAFRC.DoesNotExist ], r'^.'
        ],
        
        # Verify moving a file to the same directory where it already resides fails or is successful (depending on the OS) but doesn't change the file
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.XXX TODIRECTORY {STAF/DataDir}/user/STAFTest',
          [ STAFRC.Ok, STAFRC.MoveError ], None
        ],
        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest/STAFTest.XXX',
          [ STAFRC.Ok ], None,
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) >= 10"
        ],

        # Verify moving a file to an existing directory works
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.XXX TODIRECTORY {STAF/DataDir}/user/STAFTest/subDir1',
          [ STAFRC.Ok ], None
        ],
        
        # Verify moving a file to an existing directory works (when specify a trailing / in the directory name)
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/subDir1/STAFTest.XXX TODIRECTORY {STAF/DataDir}/user/STAFTest/',
          [ STAFRC.Ok ], None
        ],
        
        # Verify moving a file to a directory where a file with the same name exists works (and it overwrites the file)
        [ 'STD:FS', 'FS',  'COPY FILE {STAF/DataDir}/user/STAFTest.txt TODIRECTORY {STAF/DataDir}/user/STAFTest/subDir1 TOMACHINE %s' % (TestMach),
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.XXX TODIRECTORY {STAF/DataDir}/user/STAFTest/subDir1',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/subDir1/STAFTest.XXX TODIRECTORY {STAF/DataDir}/user/STAFTest',
          [ STAFRC.Ok ], None
        ],
        
        # Verify moving multiple files using a wildcard to an existing directory works
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/STAFTest.X* TODIRECTORY {STAF/DataDir}/user/STAFTest/subDir1',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'MOVE FILE {STAF/DataDir}/user/STAFTest/subDir1/STAFTest.X* TODIRECTORY {STAF/DataDir}/user/STAFTest',
          [ STAFRC.Ok ], None
        ],
        
        # Verify renaming a directory and specifying a non-existing path in the new directory name fails
        [ 'STD:FS', 'FS',  'MOVE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir2 TODIRECTORY {STAF/DataDir}/user/STAFTest/NoExist/STAFTest',
          [ STAFRC.MoveError ], r'^.'
        ],
        
        # Verify that renaming a non-existing directory fails
        [ 'STD:FS', 'FS',  'MOVE DIRECTORY {STAF/DataDir}/user/STAFTest/NoExist TODIRECTORY {STAF/DataDir}/user/STAFTest/subDir2x',
          [ STAFRC.DoesNotExist ], r'^.'
        ],

        # Verify that renaming a directory and specifying the same directory name fails or is successful (depending on the OS) but doesn't change the directory
        [ 'STD:FS', 'FS',  'MOVE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir2 TODIRECTORY {STAF/DataDir}/user/STAFTest',
          [ STAFRC.MoveError, STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest/subDir2',
          [ STAFRC.Ok ], None,
          "STAFResult['type'] == 'D'"
        ],

        # Verify renaming a directory works
        [ 'STD:FS', 'FS',  'MOVE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir2 TODIRECTORY {STAF/DataDir}/user/STAFTest/subDir2x',
          [ STAFRC.Ok ], None
        ],

        # Verify moving a directory to an existing directory works
        [ 'STD:FS', 'FS',  'MOVE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir2x TODIRECTORY {STAF/DataDir}/user/STAFTest/subDir1',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'QUERY ENTRY {STAF/DataDir}/user/STAFTest/subDir1/subDir2x',
          [ STAFRC.Ok ], None,
          "STAFResult['type'] == 'D'"
        ],

        # Verify renaming a directory and specifying a trailing / in the new directory name works
        [ 'STD:FS', 'FS',  'MOVE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir1/subDir2x TODIRECTORY {STAF/DataDir}/user/STAFTest/',
          [ STAFRC.Ok ], None
        ],
        
        # Verify renaming a directory to a directory that already exists fails
        [ 'STD:FS', 'FS',  'CREATE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir1/subDir2/subDir1 FULLPATH',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:FS', 'FS',  'MOVE DIRECTORY {STAF/DataDir}/user/STAFTest/subDir1 TODIRECTORY {STAF/DataDir}/user/STAFTest/subDir1/subDir2',
          [ STAFRC.MoveError ], r'^.'
        ],

        # Verify using spaces in the new name of a directory works
        
        [ 'STD:FS', 'FS',  'MOVE DIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 1 2 3" TODIRECTORY "{STAF/DataDir}/user/STAFTest/Dir 1"',
          [ STAFRC.Ok ], None
        ],

        # Test LIST COPYREQUESTS

        [ 'STD:FS', 'FS',  'LIST COPYREQUESTS',
          [ STAFRC.Ok ], None
        ],
        
        [ 'STD:FS', 'FS',  'LIST COPYREQUESTS INBOUND OUTBOUND FILE BINARY TEXT DIRECTORY',
          [ STAFRC.Ok ], None
        ],
        
        [ 'STD:FS', 'FS',  'LIST COPYREQUESTS INBOUND OUTBOUND FILE BINARY TEXT DIRECTORY LONG',
          [ STAFRC.Ok ], None
        ],
        
        [ 'STD:FS', 'FS',  'LIST COPYREQUESTS INBOUND FILE BINARY LONG',
          [ STAFRC.Ok ], None
        ],
        
        [ 'STD:FS', 'FS',  'LIST COPYREQUESTS INBOUND DIRECTORY BINARY',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:FS', 'FS',  'LIST COPYREQUESTS OUTBOUND TEXT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],
        
        ###Clean up on Source Tree
        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest.txt CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestLarge.txt CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestLargeEOL.txt CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestText RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTestTextCopy RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'FS',  'DELETE ENTRY {STAF/DataDir}/user/STAFTest RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:FS', 'VAR', 'DELETE VAR STAFTest/FSFormat VAR STAFTest/FSTextExt VAR STAFTest/fileType VAR STAFTest/types',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'VAR', 'DELETE VAR STAFTest/namePattern VAR STAFTest/extPattern',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FS', 'SEM', 'RELEASE MUTEX STAFTest/FS',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>FSTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitVARTests - This function initializes all the VAR test information      -->
  <!-- ========================================================================== -->

  <function name="InitVARTests" scope="local">
    <sequence>

      <stafcmd>
        <location>'local'</location>
        <service>'VAR'</service>
        <request>'SET HANDLE %s VAR STAFTest/When=Tomorrow' % (JobHandle)</request>
      </stafcmd>
      <if expr="RC">
        <message>"failed: SET HANDLE %s VAR STAFTest/When=Tomorrow RC=%s" % (JobHandle, RC)</message>
        <else>
          <sequence>
            <stafcmd>
              <location>'local'</location>
              <service>'VAR'</service>
              <request>'GET HANDLE %s VAR STAFTest/When' % (JobHandle)</request>
            </stafcmd>
            <message>"STAFTest/When=%s" % STAFResult</message>
          </sequence>
        </else>
      </if>

      <stafcmd>
        <location>'local'</location>
        <service>'VAR'</service>
        <request>'SET HANDLE %s VAR STAFTest/VarA={STAFTest/VarB} VAR STAFTest/VarB={STAFTest/VarA}' % (JobHandle)</request>
      </stafcmd>
      <if expr="RC">
        <message>"failed: 'SET HANDLE %s VAR STAFTest/VarA={STAFTest/VarB} VAR STAFTest/VarB={STAFTest/VarA} RC=%s" % (JobHandle, RC)</message>
      </if>

      <message log="1">"QHandle (remote) %s, JobHandle (local) %s" % (QHandle, JobHandle)</message>

      <script>

      VARTests = [

        #
        #VAR tests
        #

        [ 'STD:VAR', 'SEM', 'REQUEST MUTEX STAFTest/VAR',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:VAR', 'VAR', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:VAR', 'VAR', 'LIST',
          [ STAFRC.Ok ], None
        ],

        # Verify the SYSTEM variable requests work
        [ 'STD:VAR', 'VAR', 'GET SYSTEM VAR STAFTest/UNKNOWNVAR',
          [ STAFRC.VariableDoesNotExist ], r'^.'
        ],

        [ 'STD:VAR', 'VAR', 'SET SYSTEM VAR STAFTest/When=Now',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'GET SYSTEM VAR STAFTest/When',
          [ STAFRC.Ok ], 'Now'
        ],

        # Verify that if you specify the VAR option more than once on a GET request, you get an RC 7
        [ 'STD:VAR', 'VAR', 'GET SYSTEM VAR STAFTest/When VAR STAF/Config/Machine',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING {STAFTest/When}',
          [ STAFRC.Ok ], 'Now'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING {STAFTest/When} STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] == 'Now' and " +
          "STAFResult[1]['rc'] == '13' and " +
          "STAFResult[1]['result'].find('STAFTest/UNKNOWNVAR') >= 0"
        ],

        # Verify that when specifying the FAILIFEXISTS option when setting a variable that already exists, we
        # are getting the right RC and the value that the variable is already set to.
        [ 'STD:VAR', 'VAR', 'SET SYSTEM FAILIFEXISTS VAR STAFTest/When=Future',
          [ STAFRC.AlreadyExists ], 'Now'
        ],
        
        # Verify that when specifying the incorrect format (not Name=Value) for the VAR option's value,
        # get the right RC and an error message
        [ 'STD:VAR', 'VAR', 'SET SYSTEM VAR bad',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        
        # Verify that when specifying multiple variables to be set and an error occurs setting one or more
        # variables, we get the right RC and a list of the variables and the rc and result for setting each variable.
        [ 'STD:VAR', 'VAR', 'SET SYSTEM FAILIFEXISTS VAR STAFTest/When=Future VAR bad',
          [ STAFRC.AlreadyExists ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'STAFTest/When' and " +
          "STAFResult[0]['rc'] == '49' and " +
          "STAFResult[0]['result'] == 'Now' and " +
          "STAFResult[1]['name'] == 'bad' and " +
          "STAFResult[1]['rc'] == '47' and " +
          "len(STAFResult[1]['result']) > 0"
        ],

        [ 'STD:VAR', 'VAR', 'SET SYSTEM VAR STAFTest/VarA={STAFTest/VarB} VAR STAFTest/VarB={STAFTest/VarA}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING {STAFTest/VarA}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING {STAFTest/VarB}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING "{Not a STAF Variable"',
          [ STAFRC.InvalidResolveString ], None
        ],
       
        # Verify that when using the IGNOREERRORS option, don't get RC 13 or RC 15
        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING "{Not a STAF Variable - {STAFTest/When}" IGNOREERRORS',
          [ STAFRC.Ok ], '{Not a STAF Variable - Now'
        ],
        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING "{Not a STAF Variable} - {STAFTest/When}" IGNOREERRORS',
          [ STAFRC.Ok ], '{Not a STAF Variable} - Now'
        ],
        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING "^{Not a STAF Variable} - {STAFTest/When}" IGNOREERRORS',
          [ STAFRC.Ok ], '{Not a STAF Variable} - Now'
        ],

        [ 'STD:VAR', 'VAR', 'LIST SYSTEM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SYSTEM VAR STAFTest/VarA VAR STAFTest/VarB',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SYSTEM VAR STAFTest/UNKNOWNVAR VAR STAFTest/WHEN',
          [ STAFRC.VariableDoesNotExist], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'STAFTest/UNKNOWNVAR' and " +
          "STAFResult[0]['rc'] == '13' and " +
          "len(STAFResult[0]['result']) > 0 and " +
          "STAFResult[1]['name'] == 'STAFTest/WHEN' and " +
          "STAFResult[1]['rc'] == '0' and " +
          "len(STAFResult[1]['result']) == 0"
        ],

        # Make sure that this variable was deleted by the above request
        [ 'STD:VAR', 'VAR', 'GET SYSTEM VAR STAFTest/When',
          [ STAFRC.VariableDoesNotExist ], r'^.'
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SYSTEM VAR STAFTest/UNKNOWNVAR',
          [ STAFRC.VariableDoesNotExist ], r'^.'
        ],

        # Verify the SHARED variable requests work
        [ 'STD:VAR', 'VAR', 'GET SHARED VAR STAFTest/UNKNOWNVAR',
          [ STAFRC.VariableDoesNotExist ], r'^.'
        ],

        [ 'STD:VAR', 'VAR', 'SET SHARED VAR STAFTest/When=Now',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'GET SHARED VAR STAFTest/When',
          [ STAFRC.Ok ], 'Now'
        ],
        
        # Verify that if you specify the VAR option more than once on a GET request, you get an RC 7
        [ 'STD:VAR', 'VAR', 'GET SHARED VAR STAFTest/When VAR STAF/Config/Machine',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SHARED STRING {STAFTest/When}',
          [ STAFRC.Ok ], 'Now'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SHARED STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SHARED STRING {STAFTest/When} STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] == 'Now' and " +
          "STAFResult[1]['rc'] == '13' and " +
          "STAFResult[1]['result'].find('STAFTest/UNKNOWNVAR') >= 0"
        ],
        
        # Verify that when specifying the FAILIFEXISTS option when setting a variable that already exists, we
        # are getting the right RC and the value that the variable is already set to.
        [ 'STD:VAR', 'VAR', 'SET SHARED FAILIFEXISTS VAR STAFTest/When=Future',
          [ STAFRC.AlreadyExists ], 'Now'
        ],
        
        # Verify that when specifying the incorrect format (not Name=Value) for the VAR option's value,
        # get the right RC and an error message
        [ 'STD:VAR', 'VAR', 'SET SHARED VAR bad',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        
        # Verify that when specifying multiple variables to be set and an error occurs setting one or more
        # variables, we get the right RC and a list of the variables and the rc and result for setting each variable.
        [ 'STD:VAR', 'VAR', 'SET SHARED FAILIFEXISTS VAR STAFTest/When=Future VAR bad',
          [ STAFRC.AlreadyExists ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'STAFTest/When' and " +
          "STAFResult[0]['rc'] == '49' and " +
          "STAFResult[0]['result'] == 'Now' and " +
          "STAFResult[1]['name'] == 'bad' and " +
          "STAFResult[1]['rc'] == '47' and " +
          "len(STAFResult[1]['result']) > 0"
        ],

        [ 'STD:VAR', 'VAR', 'SET SHARED VAR STAFTest/VarA={STAFTest/VarB} VAR STAFTest/VarB={STAFTest/VarA}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SHARED STRING {STAFTest/VarA}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SHARED STRING {STAFTest/VarB}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SHARED STRING {STAFTest/BadVar',
          [ STAFRC.InvalidResolveString ], None
        ],

        [ 'STD:VAR', 'VAR', 'LIST SHARED',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SHARED VAR STAFTest/VarA VAR STAFTest/VarB VAR STAFTest/WHEN',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SHARED VAR STAFTest/UNKNOWNVAR',
          [ STAFRC.VariableDoesNotExist ], r'^.'
        ],

        # Verify the HANDLE variable requests work
        [ 'STD:VAR', 'VAR', 'GET HANDLE %s VAR STAFTest/UNKNOWNVAR' % (QHandle),
          [ STAFRC.VariableDoesNotExist ], r'^.'
        ],

        [ 'STD:VAR', 'VAR', 'SET HANDLE %s VAR STAFTest/When=Now' % (QHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'GET HANDLE %s VAR STAFTest/When' % (QHandle),
          [ STAFRC.Ok ], 'Now'
        ],

        # Verify that if you specify the VAR option more than once on a GET request, you get an RC 7
        [ 'STD:VAR', 'VAR', 'GET HANDLE %s VAR STAFTest/When VAR STAF/Config/Machine' % (QHandle),
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE %s STRING {STAFTest/When}' % (QHandle),
          [ STAFRC.Ok ], 'Now'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE %s STRING {STAFTest/UNKNOWNVAR}' % (QHandle),
          [ STAFRC.VariableDoesNotExist ], None
        ],
        
        # Verify that get an InvalidValue error if specify an invalid value for handle# (not in range 1 - 2147483647)
        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE 0 STRING Hi',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE 2147483648 STRING Hi',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE 009999999999 STRING Hi',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE -1 STRING Hi',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE 0 STRING Hi',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE 2147483648 STRING Hi',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE 009999999999 STRING Hi',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE -1 STRING Hi',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:VAR', 'VAR', 'LIST ASHANDLE 0',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE %s STRING {STAFTest/When} STRING {STAFTest/UNKNOWNVAR}' % (QHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] == 'Now' and " +
          "STAFResult[1]['rc'] == '13' and " +
          "STAFResult[1]['result'].find('STAFTest/UNKNOWNVAR') >= 0"
        ],

        # Verify that when specifying the FAILIFEXISTS option when setting a variable that already exists, we
        # are getting the right RC and the value that the variable is already set to.
        [ 'STD:VAR', 'VAR', 'SET HANDLE %s FAILIFEXISTS VAR STAFTest/When=Future' % (QHandle),
          [ STAFRC.AlreadyExists ], 'Now'
        ],
        
        # Verify that when specifying the incorrect format (not Name=Value) for the VAR option's value,
        # get the right RC and an error message
        [ 'STD:VAR', 'VAR', 'SET HANDLE %s VAR bad' % (QHandle),
          [ STAFRC.InvalidValue ], r'^.'
        ],
        
        # Verify that when specifying multiple variables to be set and an error occurs setting one or more
        # variables, we get the right RC and a list of the variables and the rc and result for setting each variable.
        [ 'STD:VAR', 'VAR', 'SET HANDLE %s FAILIFEXISTS VAR STAFTest/When=Future VAR bad' % (QHandle),
          [ STAFRC.AlreadyExists ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'STAFTest/When' and " +
          "STAFResult[0]['rc'] == '49' and " +
          "STAFResult[0]['result'] == 'Now' and " +
          "STAFResult[1]['name'] == 'bad' and " +
          "STAFResult[1]['rc'] == '47' and " +
          "len(STAFResult[1]['result']) > 0"
        ],

        [ 'STD:VAR', 'VAR', 'SET HANDLE %s VAR STAFTest/VarA={STAFTest/VarB} VAR STAFTest/VarB={STAFTest/VarA}' % (QHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE %s STRING {STAFTest/VarA}' % (QHandle),
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE %s STRING {STAFTest/VarB}' % (QHandle),
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE %s STRING {STAFTest/BadVar' % (QHandle),
          [ STAFRC.InvalidResolveString ], None
        ],

        [ 'STD:VAR', 'VAR', 'LIST HANDLE %s' % (QHandle),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:VAR', 'VAR', 'DELETE HANDLE %s VAR STAFTest/VarA VAR STAFTest/VarB VAR STAFTest/WHEN' % (QHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'DELETE HANDLE %s VAR STAFTest/UNKNOWNVAR' % (QHandle),
          [ STAFRC.VariableDoesNotExist ], None
        ],

        # Verify the ASHANDLE variable requests work
        [ 'STD:VAR', 'VAR', 'SET HANDLE %s VAR STAFTest/When=Now' % (QHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'SET SHARED VAR STAFTest/Who=Me',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'SET SYSTEM VAR STAFTest/Where=Here',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {STAFTest/When}' % (QHandle),
          [ STAFRC.Ok ], 'Now'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {STAFTest/Where}' % (QHandle),
          [ STAFRC.Ok ], 'Here'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {STAFTest/Who}' % (QHandle),
          [ STAFRC.Ok ], 'Me'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {STAFTest/UNKNOWNVAR}' % (QHandle),
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {STAFTest/When} STRING {STAFTest/UNKNOWNVAR}' % (QHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] == 'Now' and " +
          "STAFResult[1]['rc'] == '13' and " +
          "STAFResult[1]['result'].find('STAFTest/UNKNOWNVAR') >= 0"
        ],

        [ 'STD:VAR', 'VAR', 'SET HANDLE %s VAR STAFTest/VarA={STAFTest/VarB} VAR STAFTest/VarB={STAFTest/VarA}' % (QHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {STAFTest/VarA}' % (QHandle),
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {STAFTest/VarB}' % (QHandle),
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {STAFTest/BadVar' % (QHandle),
          [ STAFRC.InvalidResolveString ], None
        ],

        [ 'STD:VAR', 'VAR', 'LIST ASHANDLE %s' % (QHandle),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:VAR', 'VAR', 'DELETE HANDLE %s VAR STAFTest/VarA VAR STAFTest/VarB VAR STAFTest/WHEN' % (QHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SYSTEM VAR STAFTest/Where',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SHARED VAR STAFTest/Who',
          [ STAFRC.Ok ], r'^$'
        ],

        # Verify the REQUEST variable requests work
        #[ 'STD:VAR', 'VAR', 'SET HANDLE %s VAR STAFTest/When=Now' % (QHandle),
        #  [ STAFRC.Ok ], r'^$'
        #],

        [ 'STD:VAR', 'VAR', 'RESOLVE REQUEST STRING {STAFTest/When}',
          [ STAFRC.Ok ], 'Tomorrow'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE REQUEST STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE REQUEST STRING {STAFTest/When} STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] == 'Tomorrow' and " +
          "STAFResult[1]['rc'] == '13' and " +
          "STAFResult[1]['result'].find('STAFTest/UNKNOWNVAR') >= 0"
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE REQUEST STRING {STAFTest/VarA}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE REQUEST STRING {STAFTest/VarB}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE REQUEST STRING {STAFTest/BadVar',
          [ STAFRC.InvalidResolveString ], None
        ],

        [ 'STD:VAR', 'VAR', 'LIST REQUEST',
          [ STAFRC.Ok ], None
        ],

        #[ 'STD:VAR', 'VAR', 'DELETE HANDLE %s VAR STAFTest/VarA' % (QHandle),
        #  [ STAFRC.Ok ], r'^$'
        #],

        #[ 'STD:VAR', 'VAR', 'DELETE HANDLE %s VAR STAFTest/VarB' % (QHandle),
        #  [ STAFRC.Ok ], r'^$'
        #],

        #[ 'STD:VAR', 'VAR', 'DELETE HANDLE %s VAR STAFTest/WHEN' % (QHandle),
        #  [ STAFRC.Ok ], r'^$'
        #],

        # Test the use of a caret (^) as an escape character for "{" and "^"
        [ 'STD:VAR', 'VAR', 'SET SYSTEM VAR h=Hi VAR Hi=HI VAR "^Hi=Hello"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING "^{{h}, ^{{h}}, {{h}}, ^^{{h}}, ^{^{h}}, and {^{h}}"',
          [ STAFRC.Ok ],
           r'\{Hi,\ \{Hi\},\ HI,\ \^HI,\ \{\{h\}\},\ and Hello'
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SYSTEM VAR h VAR Hi VAR "^Hi"',
          [ STAFRC.Ok ], r'^$'
        ],

        # Verify {STAF/Config/Mem/Physical/xxx} variable values > 0 if the OS is not OS/390 or AIX V4 or lower
        [ 'STD:VAR', 'VAR', "RESOLVE STRING {STAF/Config/Mem/Physical/Bytes} " +
          "STRING {STAF/Config/Mem/Physical/KB} " +
          "STRING {STAF/Config/Mem/Physical/MB}", 
          [ STAFRC.Ok ], None,
          "TestMachOSType == 'OS/390' or " +
          "(TestMachOSType == 'AIX' and int(TestMachOSMinorVersion) &lt; 5) or " +
          "(len(STAFResult) == 3 and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[1]['rc'] == '0' and " +
          "STAFResult[2]['rc'] == '0' and " +
          "long(STAFResult[0]['result']) > 0 and " +
          "(long(long(STAFResult[0]['result'])/1024) == long(STAFResult[1]['result'])) and " +
          "(long(long(STAFResult[1]['result'])/1024) == long(STAFResult[2]['result'])))"
        ],

        # Verify {STAF/Config/Processor/NumAvail} variable value > 0 if the OS is not OS/390 or AIX V4 or lower
        [ 'STD:VAR', 'VAR', "RESOLVE STRING {STAF/Config/Processor/NumAvail}", 
          [ STAFRC.Ok ], None,
          "((TestMachOSType == 'OS/390' and int(STAFResult) == 0) or " +
          " (TestMachOSType == 'AIX' and int(TestMachOSMinorVersion) &lt; 5 and int(STAFResult) == 0) or " +
          " int(STAFResult) > 0)"
        ]
      ]
      </script>

      <if expr="testMachineIsLocal">
      <script>
        VARTests = VARTests + [
        # Can only do the following VAR tests if TestMach is local or specify a TestMach of 'local' so comment out.

        # Verify that when not specifying SYSTEM/HANDLE/SHARED/REQUEST, variable requests work
        [ 'STD:VAR', 'VAR', 'GET VAR STAFTest/UNKNOWNVAR',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:VAR', 'VAR', 'SET VAR STAFTest/When=Now',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'GET VAR STAFTest/When',
          [ STAFRC.Ok ], 'Now'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/When}',
          [ STAFRC.Ok ], 'Now'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.VariableDoesNotExist ], r'^.'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/When} STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] == 'Now' and " +
          "STAFResult[1]['rc'] == '13' and " +
          "STAFResult[1]['result'].find('STAFTest/UNKNOWNVAR') >= 0"
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/VarA}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/VarB}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/BadVar',
          [ STAFRC.InvalidResolveString ], None
        ],

        [ 'STD:VAR', 'VAR', 'LIST',
          [ STAFRC.Ok ], None
        ],

        # Test that the handle variables override the system variables, etc.
        [ 'STD:VAR', 'VAR', 'SET SYSTEM VAR 12=Fun VAR a=You VAR b=Me VAR c=1 VAR d=2 VAR e=a VAR f={a} VAR g=Travis',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'SET SHARED VAR a=David VAR b=Sharon VAR g=Joef',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'SET HANDLE %s VAR a=Don VAR b=Charles' % (JobHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING {a}',
          [ STAFRC.Ok ], 'You'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SYSTEM STRING "{a} and {b}"',
          [ STAFRC.Ok ], r'You\ and\ Me'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SHARED STRING {a}',
          [ STAFRC.Ok ], 'David'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE SHARED STRING "{a} and {b}"',
          [ STAFRC.Ok ], r'David\ and\ Sharon'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING "{a} and {b} and {g} are {12}"',
          [ STAFRC.Ok ], r'Don\ and\ Charles\ and\ Joef\ are\ Fun'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE HANDLE %s STRING "{a} and {b}"' % (JobHandle),
          [ STAFRC.Ok ], r'Don\ and\ Charles'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE REQUEST STRING "{a} and {b} and {g} are {12}"',
          [ STAFRC.Ok ], r'Don\ and\ Charles\ and\ Joef\ are\ Fun'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING "{a} and {b} and {g} are {12}"' % (JobHandle),
          [ STAFRC.Ok ], r'Don\ and\ Charles\ and\ Joef\ are\ Fun'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {c}{d}',
          [ STAFRC.Ok ], r'12'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {c}{d}' % (JobHandle),
          [ STAFRC.Ok ], r'12'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {1{d}}' % (JobHandle),
          [ STAFRC.Ok ], r'Fun'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {{c}{d}}' % (JobHandle),
          [ STAFRC.Ok ], r'Fun'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {{e}}' % (JobHandle),
          [ STAFRC.Ok ], r'Don'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {f}' % (JobHandle),
          [ STAFRC.Ok ], r'Don'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE ASHANDLE %s STRING {a} STRING {b} STRING {q}' % (JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] == 'Don' and " +
          "STAFResult[1]['rc'] == '0' and " +
          "STAFResult[1]['result'] == 'Charles' and " +
          "STAFResult[2]['rc'] == '13' and " +
          "STAFResult[2]['result'].find('q') >= 0"
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SYSTEM VAR 12 VAR a VAR b VAR c VAR d VAR e VAR f VAR g',
          [ STAFRC.Ok ], r'$'
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SHARED VAR a VAR b VAR g',
          [ STAFRC.Ok ], r'$'
        ],

        [ 'STD:VAR', 'VAR', 'DELETE HANDLE %s VAR a VAR b' % (JobHandle),
          [ STAFRC.Ok ], r'$'
        ],

        [ 'STD:VAR', 'SEM', 'RELEASE MUTEX STAFTest/VAR',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>
      <else>
      <script>
        VARTests = VARTests + [
        # Can only do the following VAR tests if TestMach is remote.

        # Verify that when not specifying SYSTEM/HANDLE/SHARED/REQUEST, variable requests work
        [ 'STD:VAR', 'VAR', 'GET VAR STAFTest/UNKNOWNVAR',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:VAR', 'VAR', 'SET VAR STAFTest/When=Now',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:VAR', 'VAR', 'GET VAR STAFTest/When',
          [ STAFRC.Ok ], 'Now'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/When}',
          [ STAFRC.Ok ], 'Tomorrow'
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/When} STRING {STAFTest/UNKNOWNVAR}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] == 'Tomorrow' and " +
          "STAFResult[1]['rc'] == '13' and " +
          "STAFResult[1]['result'].find('STAFTest/UNKNOWNVAR') >= 0"
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/VarA}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/VarB}',
          [ STAFRC.UnResolvableString ], None
        ],

        [ 'STD:VAR', 'VAR', 'RESOLVE STRING {STAFTest/BadVar',
          [ STAFRC.InvalidResolveString ], None
        ],

        [ 'STD:VAR', 'VAR', 'LIST',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:VAR', 'VAR', 'DELETE SYSTEM VAR STAFTest/When',
          [ STAFRC.Ok ], r'$'
        ],

      ]
      </script>
      </else>
      </if>

      <return>VARTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitQUEUETests - This function initializes all the QUEUE test information  -->
  <!-- ========================================================================== -->

  <function name="InitQUEUETests" scope="local">
    <sequence>

      <!-- Test fix for Bug #2861597 "Killed queue get wait request leaves file descriptor open"
             - First test using a regular STAF handle
             - Then test using a static STAF handle
         -->
     
      <if expr="testMachineIsLocal">
        <testcase name="'QUEUE'">
        <sequence>

          <message>
            'QUEUE: Verify when a STAF handle is unregistered, any pending QUEUE GET ' + \
            'WAIT requests it submitted will fail with RC 56 (Request Cancelled)'
          </message>

          <script> 
            # Create a STAF handle 
            from com.ibm.staf import STAFHandle 
            myHandle = STAFHandle("STAFTest/QueueTest") 
          </script>

          <!-- Use this handle to submit a "STAF local QUEUE GET WAIT 60s" request and
                while this request is waiting, unregister the handle that submitted this request 
                and verify that the request then fails with RC 56 (RequestCancelled) -->
          <parallel>

            <sequence>
              <script> 
                # Use this handle to submit a STAF local QUEUE GET WAIT 30s request 
                request = 'GET WAIT 30s'
                result = myHandle.submit2('local', 'QUEUE', request) 
              </script>
              <call function="'STAXUtilCheckSuccess'">
                { 'result': result.rc == STAFRC.RequestCancelled,
                  'failMsg': "myHandle.submit2('local', 'QUEUE', %s)" % (request) + \
                               '\n  Expected RC: %s\n  Got RC: %s, STAFResult: %s' % \
                               (STAFRC.RequestCancelled, result.rc, result.result),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>
            </sequence>

            <script>
              # Wait for 3 seconds and then unregister the STAF handle that submitted the QUEUE GET WAIT request
              import time
              time.sleep(3)
              myHandle.unRegister()
            </script>

          </parallel>

          <!-- Now perform the same test, except use a static handle this time -->

          <message>
            'QUEUE: Verify when a static STAF handle is deleted, any pending QUEUE GET ' + \
            'WAIT requests it submitted will fail with RC 56 (Request Cancelled)'
          </message>

          <stafcmd name="'Create a static STAF handle'">
            <location>'local'</location>
            <service>'HANDLE'</service>
            <request>'CREATE HANDLE NAME STAFTest/QueueTest/Static'</request>
          </stafcmd>

          <if expr="RC == STAFRC.Ok">
            <sequence>

              <script>
                # Get a STAFHandle for the static handle just created
                staticHandleNumber = int(STAFResult)
                staticHandle = STAFHandle(staticHandleNumber)
              </script>

              <!-- Use this handle to submit a "STAF local QUEUE GET WAIT 30s" request and
                    while this request is waiting, unregister the handle that submitted this request 
                    and verify that the request then fails with RC 56 (Request Cancelled) -->
              <parallel>

                <sequence>
                  <script> 
                      # Use this handle to submit a STAF local QUEUE GET WAIT 30s request 
                      request = 'GET WAIT 30s'
                      result = staticHandle.submit2('local', 'QUEUE', request) 
                  </script>
                  <call function="'STAXUtilCheckSuccess'">
                    { 'result': result.rc == STAFRC.RequestCancelled,
                      'failMsg': "QUEUE: staticHandle.submit2('local', 'QUEUE', %s)" % (request) + \
                                    '\n  Expected RC: %s\n  Got RC: %s, STAFResult: %s' % \
                                    (STAFRC.RequestCancelled, result.rc, result.result),
                      'sendToMonitor': 1,
                      'recordStatus': 1 }
                  </call>
                </sequence>

                <script>
                  # Wait for 3 seconds and then delete the static STAF handle that submitted the QUEUE GET WAIT request
                  import time
                  time.sleep(3)
                </script>

                <stafcmd name="'Delete static handle STAFTest/QueueTest/Static'">
                  <location>'local'</location>
                  <service>'HANDLE'</service>
                  <request>'DELETE HANDLE %s' % (staticHandleNumber)</request>
                </stafcmd>

                <call function="'STAXUtilCheckSuccess'">
                  { 'result': RC == STAFRC.Ok,
                    'failMsg': 'QUEUE: STAF local HANDLE DELETE HANDLE %s' % (staticHandleNumber) + \
                                 '\n  Expected RC: %s\n  Got RC: %s, STAFResult: %s' % \
                                 (STAFRC.Ok, RC, STAFResult),
                    'sendToMonitor': 1,
                    'recordStatus': 1 }
                </call>

              </parallel>

            </sequence>
            <else>
              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'QUEUE: STAF local HANDLE CREATE HANDLE NAME STAFTest/QueueTest/Static' + \
                               '\n  Expected RC: %s\n  Got RC: %s, STAFResult: %s' % \
                               (STAFRC.Ok, RC, STAFResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>
            </else>
          </if>

        </sequence>
        </testcase>
      </if>

      <script>

      QUEUETests = [

        #
        #QUEUE tests
        #

        [ 'STD:QUEUE', 'SEM',   'REQUEST MUTEX STAFTest/QUEUE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:QUEUE', 'QUEUE', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:QUEUE', 'QUEUE', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE %s MESSAGE "%s/DefaultTest"' % (QHandle, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE %s PRIORITY 1 MESSAGE "%s/Priority-1-Test"' % (QHandle, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE %s PRIORITY 10 TYPE "MyType" MESSAGE "%s/QueueTest"' % (QHandle, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE %s PRIORITY 5000 MESSAGE "%s/QueueTest"' % (QHandle, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:QUEUE', 'QUEUE', 'LIST HANDLE %s' % (QHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 4 or " +
          "(len(STAFResult) == 4 and " +
          "int(STAFResult[0]['priority']) == 1 and " +
          "STAFResult[0]['machine'].find('://') != -1 and " +
          "STAFResult[0]['handleName'] == 'STAX/Job/%s' and " % (STAXJobID) +
          "STAFResult[0]['type'] == None and " +
          "STAFResult[0]['message'].find('Priority-1-Test') != -1 and " +
          "int(STAFResult[1]['priority']) == 5 and " +
          "STAFResult[1]['handleName'] == 'STAX/Job/%s' and " % (STAXJobID) +
          "STAFResult[1]['type'] == None and " +
          "STAFResult[1]['message'].find('DefaultTest') != -1 and " +
          "int(STAFResult[2]['priority']) == 10 and " +
          "STAFResult[2]['handleName'] == 'STAX/Job/%s' and "  % (STAXJobID) +
          "STAFResult[2]['type'] == 'MyType' and " +
          "STAFResult[2]['message'].find('QueueTest') != -1 and " +
          "int(STAFResult[3]['priority']) == 5000 and " +
          "STAFResult[3]['handleName'] == 'STAX/Job/%s' and "  % (STAXJobID) +
          "STAFResult[3]['type'] == None and " +
          "STAFResult[3]['message'].find('QueueTest') != -1)"
        ],

        # XXX: Can only peek/get handle if own it - Need to figure out how to test
        #[ 'STD:QUEUE', 'QUEUE', 'PEEK HANDLE %s' % (QHandle), [ STAFRC.Ok ], r'^.' ],
        #[ 'STD:QUEUE', 'QUEUE', 'PEEK HANDLE %s CONTAINS Queue' % (QHandle), [ STAFRC.Ok ], r'^.' ],
        #[ 'STD:QUEUE', 'QUEUE', 'PEEK HANDLE %s CONTAINS Queue CONTAINS Test' % (QHandle), [ STAFRC.Ok ], r'^.' ],
        #[ 'STD:QUEUE', 'QUEUE', 'PEEK HANDLE %s PRIORITY 1' % (QHandle), [ STAFRC.Ok ], r'^.' ],
        #[ 'STD:QUEUE', 'QUEUE', 'GET HANDLE %s PRIORITY 1' % (QHandle), [ STAFRC.Ok ], r'^.' ],
        #[ 'STD:QUEUE', 'QUEUE', 'GET HANDLE %s CONTAINS Default' % (QHandle), [ STAFRC.Ok ], r'^.' ],

        # Verify get an InvalidValue error (or AccessDenied if not local) if specify an invalid handle # or invalid priority #
        [ 'STD:QUEUE', 'QUEUE', 'GET HANDLE 999999999999999',
          [ STAFRC.InvalidValue, STAFRC.AccessDenied ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET HANDLE 0',
          [ STAFRC.InvalidValue, STAFRC.AccessDenied ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET HANDLE 2147483648',
          [ STAFRC.InvalidValue, STAFRC.AccessDenied ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET HANDLE 1 PRIORITY -1',
          [ STAFRC.InvalidValue, STAFRC.AccessDenied ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET HANDLE 1 PRIORITY 9999999999',
          [ STAFRC.InvalidValue, STAFRC.AccessDenied ], None
        ],

        #[ 'STD:QUEUE', 'QUEUE', 'GET HANDLE %s' % (QHandle),
        #  [ STAFRC.Ok ], r'^.'
        #],

        # Verify get a NoQueueElement error (or AccessDenied if not local) if specify a 
        # valid handle # for which there are no matching entries
        [ 'STD:QUEUE', 'QUEUE', 'GET HANDLE %s' % (QHandle),
          [ STAFRC.NoQueueElement, STAFRC.AccessDenied ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET HANDLE 2147483647',
          [ STAFRC.NoQueueElement, STAFRC.AccessDenied ], None
        ],

        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE %s PRIORITY 5 MESSAGE %s/QueueTest' % (QHandle, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:QUEUE', 'QUEUE', 'DELETE HANDLE %s' % (QHandle),
          [ STAFRC.Ok, STAFRC.AccessDenied ], None
        ],

        #[ 'STD:QUEUE', 'QUEUE', 'PEEK HANDLE %s' % (QHandle),
        #  [ STAFRC.NoQueueElement ], None
        #],

        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE %s PRIORITY 1 MESSAGE "STAF/Queue"' % (QHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE %s PRIORITY 2 MESSAGE "%s/QueueTest"' % (QHandle, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE %s PRIORITY 2 MESSAGE "%s/QueueTest"' % (QHandle, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$' ],

        [ 'STD:QUEUE', 'QUEUE', 'LIST HANDLE %s' % (QHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:QUEUE', 'QUEUE', 'LIST',
          [ STAFRC.Ok, STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:QUEUE', 'QUEUE', 'DELETE HANDLE %s CONTAINS Test' % (QHandle),
          [ STAFRC.Ok, STAFRC.AccessDenied ], None
        ],

        [ 'STD:QUEUE', 'QUEUE', 'DELETE HANDLE %s TYPE MyType CONTAINS Test' % (QHandle),
          [ STAFRC.Ok, STAFRC.AccessDenied ], None
        ],

        #[ 'STD:QUEUE', 'QUEUE', 'PEEK HANDLE %s' % (QHandle),
        #  [ STAFRC.NoQueueElement ], None
        #],
        
        # Verify that specifying a handle number that doesn't exist (and is less than maximum handle size) 
        # returns a HandleDoesNotExist error
        
        [ 'STD:QUEUE', 'QUEUE', 'LIST HANDLE 2147483647' % (QHandle),
          [ STAFRC.HandleDoesNotExist ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE 2147483647 MESSAGE "This is a test"',
          [ STAFRC.HandleDoesNotExist ], None
        ],
        
        # Verify that specifying a handle number greater than maximum handle size returns a InvalidValue error
        
        [ 'STD:QUEUE', 'QUEUE', 'LIST HANDLE 9999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE 999999999999999 MESSAGE "This is a test"',
          [ STAFRC.InvalidValue ], None
        ],

        # Verify that specifying an invalid priority number (not between 0 and 4294967295) returns a InvalidValue error
        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE 1 PRIORITY -1 MESSAGE "This is a test"',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'QUEUE HANDLE 1 PRIORITY 9999999999 MESSAGE "This is a test"',
          [ STAFRC.InvalidValue ], None
        ],
        
        # Verify that specifying a handle name that doesn't exist returns a HandleDoesNotExist error
        [ 'STD:QUEUE', 'QUEUE', 'QUEUE NAME DoesNotExistXXXX MESSAGE "This is a test"',
          [ STAFRC.HandleDoesNotExist ], None
        ],
      ]
      </script>

      <!--  Only can get/peek if local machine  -->

      <if expr="testMachineIsLocal">
        <script>
        QUEUETests = QUEUETests + [

        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT XXX',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET WAIT XXX',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT 99999999999999999999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT 9999999w',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT 1sec',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET WAIT {STAFTest/InvalidValue}',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT 00000000000000',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT 0s',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT 0d',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT 00h',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT 00000000000000000000d',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK WAIT 0w',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK ALL WAIT 0000000001s',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET ALL WAIT 1s',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK FIRST 1 WAIT 1s',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET FIRST 1 WAIT 1s',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK FIRST 0',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET FIRST 0',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK FIRST -1',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET FIRST -1',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'GET FIRST 1 ALL WAIT 1s',
          [ STAFRC.Ok, STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:QUEUE', 'QUEUE', 'PEEK HANDLE 0',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK HANDLE 2147483648',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK PRIORITY -1',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:QUEUE', 'QUEUE', 'PEEK PRIORITY 9999999999',
          [ STAFRC.InvalidValue ], None
        ]

        ]
        </script>
      </if>

      <script>
        QUEUETests = QUEUETests + [

        [ 'STD:QUEUE', 'SEM',   'RELEASE MUTEX STAFTest/QUEUE',
          [ STAFRC.Ok ], r'^$'
        ]

        ]

      </script>

      <return>QUEUETests</return>

    </sequence>
  </function>


  <!-- ============================================================================== -->
  <!-- InitPROCESSTests - This function initializes all the PROCESS test information  -->
  <!-- ============================================================================== -->

  <function name="InitPROCESSTests" scope="local">
    <testcase name="'PROCESS'">
    <sequence>

      <!-- Test the maximum return file size by setting the STAF/MaxReturnFileSize variable for this job -->

      <script>request = 'SET VAR "STAF/MaxReturnFileSize=10"'</script>
      <message>'Testing machine: %s service: VAR request: %s' % ('local', request)</message>

      <stafcmd>
        <location>'local'</location>
        <service>'VAR'</service>
        <request>request</request>
      </stafcmd>

      <call function="'STAXUtilCheckSuccess'">
        { 'result': RC == STAFRC.Ok,
          'failMsg': 'STAF %s VAR %s failed.  RC=%s Result=%s' % \
          ('local', request, RC, STAFResult),
          'sendToMonitor': 1, 'recordStatus': 1 }
      </call>

      <script>request = 'START SHELL COMMAND "STAF local MISC WHOAMI" RETURNSTDOUT STDERRTOSTDOUT'</script>
      <message>'Testing machine: %s service: PROCESS request: %s' % (TestMach, request)</message>

      <process>
        <location>TestMach</location>
        <command mode="'shell'">'STAF local MISC WHOAMI'</command>
        <stderr mode="'stdout'"/>
        <returnstdout/>
      </process>

      <call function="'STAXUtilCheckSuccess'">
        { 'result': RC == STAFRC.Ok and len(STAXResult) == 1 and STAXResult[0][0] == STAFRC.MaximumSizeExceeded,
          'failMsg': 'STAF %s PROCESS %s failed.  RC=%s STAFResult=%s STAXResult=%s' % \
          (TestMach, request, RC, STAFResult, STAXResult),
          'sendToMonitor': 1, 'recordStatus': 1 }
      </call>

      <script>request = 'START SHELL COMMAND "STAF local MISC WHOAMI" RETURNSTDOUT STDERRTOSTDOUT WAIT'</script>
      <message>'Testing machine: %s service: PROCESS request: %s' % (TestMach, request)</message>

      <stafcmd>
        <location>TestMach</location>
        <service>'PROCESS'</service>
        <request>request</request>
      </stafcmd>

      <call function="'STAXUtilCheckSuccess'">
        { 'result': RC == STAFRC.Ok and len(STAFResult['fileList']) == 1 and string.atoi(STAFResult['fileList'][0]['rc']) == STAFRC.MaximumSizeExceeded and len(STAFResult['fileList'][0]['data']) > 0,
          'failMsg': 'STAF %s FS %s failed.  RC=%s Result=%s' % \
          (TestMach, request, RC, STAFResult),
          'sendToMonitor': 1, 'recordStatus': 1 }
      </call>

      <!-- Reset back to no maximum return file size -->

      <script>request = 'SET VAR "STAF/MaxReturnFileSize=0"'</script>
      <message>'Testing machine: %s service: VAR request: %s' % ('local', request)</message>

      <stafcmd>
        <location>'local'</location>
        <service>'VAR'</service>
        <request>request</request>
      </stafcmd>

      <call function="'STAXUtilCheckSuccess'">
        { 'result': RC == STAFRC.Ok,
          'failMsg': 'STAF %s VAR %s failed.  RC=%s Result=%s' % \
          ('local', request, RC, STAFResult),
          'sendToMonitor': 1, 'recordStatus': 1 }
      </call>

      <!--  Verify that no longer get an error retrieving the stdout file due to exceeded the maximum return file size -->

      <script>request = 'START SHELL COMMAND "STAF local MISC WHOAMI" RETURNSTDOUT STDERRTOSTDOUT'</script>
      <message>'Testing machine: %s service: PROCESS request: %s' % (TestMach, request)</message>

      <process>
        <location>TestMach</location>
        <command mode="'shell'">'STAF local MISC WHOAMI'</command>
        <stderr mode="'stdout'"/>
        <returnstdout/>
      </process>

      <call function="'STAXUtilCheckSuccess'">
        { 'result': RC == STAFRC.Ok and len(STAXResult) == 1 and STAXResult[0][0] == STAFRC.Ok and len(STAXResult[0][1]) > 10,
          'failMsg': 'STAF %s PROCESS %s failed.  RC=%s STAFResult=%s STAXResult=%s' % \
          (TestMach, request, RC, STAFResult, STAXResult),
          'sendToMonitor': 1, 'recordStatus': 1 }
      </call>


      <script>
        if TestMachOSType.find('Win') == 0 or TestMachOSType.find('Unknown Win') == 0:
          invalidStopMethodForOS = 'SigIntAll'

          validStopMethodForOS_1 = 'SigKillAll'
          validStopMethodForOS_2 = 'SigTerm'
          validStopMethodForOS_3 = 'SigInt'
          validStopMethodForOS_4 = 'WM_Close'
          validStopMethodForOS_5 = 'SigKillAll'
        else:
          invalidStopMethodForOS = 'WM_Close'

          validStopMethodForOS_1 = 'SigKillAll'
          validStopMethodForOS_2 = 'SigTerm'
          validStopMethodForOS_4 = 'SigInt'
          validStopMethodForOS_3 = 'SigTermAll'
          validStopMethodForOS_5 = 'SigIntAll'
      </script>
      
      <script>
      PROCESSTests = [

        #
        #PROCESS tests
        #

        [ 'STD:PROCESS', 'SEM',     'REQUEST MUTEX STAFTest/PROCESS',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:PROCESS', 'PROCESS', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'FREE ALL',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['freedProcesses']) >= 0 and " +
          "string.atoi(STAFResult['totalProcesses']) > 0"
        ],
        
        [ 'STD:PROCESS', 'VAR',     'SET VAR STAFTest/Process/Disabled=Disabled VAR STAFTest/Process/Empty=%s VAR STAFTest/Process/Min=Minimized' % (''),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTSTOPUSING %s' % (invalidStopMethodForOS),
          [ STAFRC.InvalidValue ], r'.*',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTSTOPUSING %s' % (validStopMethodForOS_1),
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTSTOPUSING %s' % (validStopMethodForOS_2),
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTSTOPUSING %s' % (validStopMethodForOS_3),
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTSTOPUSING %s' % (validStopMethodForOS_4),
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTSTOPUSING %s' % (validStopMethodForOS_5),
          [ STAFRC.Ok ], r'^$',
        ],

        # Set back to default stop using method
        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTSTOPUSING %s' % (validStopMethodForOS_1),
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET PROCESSAUTHMODE {STAFTest/Process/Disabled}',
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTAUTHUSERNAME {STAFTest/Process/Empty}',
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTAUTHPASSWORD {STAFTest/Process/Empty}',
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTAUTHDISABLEDACTION IgNore',
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTSHELL {STAFTest/Process/Empty}',
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTNEWCONSOLESHELL {STAFTest/Process/Empty}',
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTSAMECONSOLESHELL {STAFTest/Process/Empty}',
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTFOCUS {STAFTest/Process/Min}',
          [ STAFRC.Ok ], r'^$',
        ],
        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTFOCUS foreground',
          [ STAFRC.Ok ], r'^$',
        ],
        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTFOCUS xxx',
          [ STAFRC.InvalidValue], r'.*',
        ],
        [ 'STD:PROCESS', 'PROCESS', 'SET DEFAULTFOCUS BackGround',
          [ STAFRC.Ok ], r'^$',
        ],

        [ 'STD:PROCESS', 'VAR',     'DELETE VAR STAFTest/Process/Disabled VAR STAFTest/Process/Empty',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['defaultStopUsing'] and " +
          "(STAFResult['defaultConsoleMode'] == 'New' or STAFResult['defaultConsoleMode'] == 'Same') and " +
          "STAFResult['defaultFocus'] == 'Background' and " +
          "STAFResult['processAuthMode'] == 'Disabled' and " +
          "STAFResult['defaultAuthUsername'] == None and " +
          "STAFResult['defaultAuthPassword'] == None and " +
          "STAFResult['defaultAuthDisabledAction'] == 'Ignore' and " +
          "STAFResult['defaultShell'] == None and " +
          "STAFResult['defaultNewConsoleShell'] == None and " +
          "STAFResult['defaultSameConsoleShell'] == None"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and STAFResult[0]['handle'] and STAFResult[0]['command'] and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['endTimestamp'] == None and STAFResult[0]['rc'] == None"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'LIST HANDLES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and STAFResult[0]['handle'] and STAFResult[0]['command'] and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['endTimestamp'] == None and STAFResult[0]['rc'] == None"
        ],
        
        [ 'STD:PROCESS', 'PROCESS', 'LIST HANDLES LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and STAFResult[0]['handle'] and STAFResult[0]['command'] and " +
          "int(STAFResult[0]['pid']) > 0 and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['endTimestamp'] == None and STAFResult[0]['rc'] == None"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'LIST HANDLES COMPLETED',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'LIST HANDLES RUNNING',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and STAFResult[0]['endTimestamp'] == None and STAFResult[0]['rc'] == None"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'LIST HANDLES COMPLETED RUNNING LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:PROCESS', 'VAR',     'SET VAR STAFTest/Process/Workload=STAFTest VAR STAFTest/Process/Handle=%s' % (QHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'QUERY HANDLE {STAFTest/Process/Handle}',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['handle']) == %s and " % (QHandle) +
          "STAFResult['handleName'] == 'STAFTest' and " +
          "STAFResult['title'] == 'STAFTest Delay Process' and " +
          "STAFResult['workload'] == 'STAFTest' and " +
          "STAFResult['command'] == 'STAF local DELAY DELAY 5h' and " +
          "STAFResult['workdir'] == None and STAFResult['parms'] == None and " +
          "STAFResult['focus'] == 'Minimized' and " +
          "STAFResult['userName'] == None and " +
          "STAFResult['startMode'] == 'Async' and " +
          "STAFResult['key'] and STAFResult['startTimestamp'] and " +
          "int(STAFResult['pid'] > 0) and " +
          "STAFResult['endTimestamp'] == None and STAFResult['rc'] == None"
          #"STAFResult['shell'] == '&lt;Default Shell>'"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'QUERY HANDLE 2147483647',
          [ STAFRC.HandleDoesNotExist ], None
        ],

        # Verify that an InvalidValue error is returned when specify a handle# not in range 1 -  2147483647
        [ 'STD:PROCESS', 'PROCESS', 'QUERY HANDLE 0',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'QUERY HANDLE 999999999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'QUERY HANDLE X',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:PROCESS', 'PROCESS', 'LIST HANDLES WORKLOAD {STAFTest/Process/Workload} LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "int(STAFResult[0]['handle']) > 0 and " +
          "STAFResult[0]['workload'] == 'STAFTest' and " +
          "STAFResult[0]['command'] == 'STAF local DELAY DELAY 5h' and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['endTimestamp'] == None and STAFResult[0]['rc'] == None"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'FREE HANDLE {STAFTest/Process/Handle}',
          [ STAFRC.ProcessNotComplete ], None
        ],

        [ 'STD:PROCESS', 'PROCESS', 'FREE WORKLOAD {STAFTest/Process/Workload}',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['freedProcesses']) == 0 and " +
          "string.atoi(STAFResult['totalProcesses']) > 0"
        ],

        # Verify that an InvalidValue error is returned when specify a handle# not in range 1 -  2147483647
        [ 'STD:PROCESS', 'PROCESS', 'FREE HANDLE 0',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'FREE HANDLE 999999999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'FREE HANDLE X',
          [ STAFRC.InvalidValue ], None
        ],
        
        [ 'STD:PROCESS', 'VAR',     'SET VAR STAFTest/Process/Handle=%s' % (JobHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY REGISTER',
          [ STAFRC.InvalidRequestString ], r'^.*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY REGISTER ONENDOFHANDLE {STAFTest/Process/Handle}',
          [ STAFRC.HandleDoesNotExist ], r'^.*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE {STAFTest/Process/Handle}',
          [ STAFRC.HandleDoesNotExist ], r'.*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY REGISTER ONENDOFHANDLE {STAFTest/Process/Handle} HANDLE {STAFTest/Process/Handle}',
          [ STAFRC.HandleDoesNotExist ], r'^.*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE {STAFTest/Process/Handle} HANDLE {STAFTest/Process/Handle}',
          [ STAFRC.HandleDoesNotExist ], r'^.*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY REGISTER ONENDOFHANDLE {STAFTest/Process/Handle} NAME {STAFTest/Process/Workload}',
          [ STAFRC.HandleDoesNotExist ], r'^.*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE {STAFTest/Process/Handle} NAME {STAFTest/Process/Workload}',
          [ STAFRC.HandleDoesNotExist ], r'^.*'
        ],

        [ 'STD:PROCESS', 'VAR',     'SET VAR STAFTest/Process/Machine=%s VAR STAFTest/Process/Priority=4' % (TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY REGISTER ONENDOFHANDLE {STAFTest/Process/Handle} MACHINE {STAFTest/Process/Machine} PRIORITY {STAFTest/Process/Priority}',
          [ STAFRC.HandleDoesNotExist ], r'^.*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE {STAFTest/Process/Handle} MACHINE {STAFTest/Process/Machine} PRIORITY {STAFTest/Process/Priority}',
          [ STAFRC.HandleDoesNotExist ], r'^.*'
        ],
       
        # Verify that an InvalidValue error is returned when specify a handle# not in range 1 -  2147483647 for ONENDOFHANDLE
        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE 0',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE 9999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE X',
          [ STAFRC.InvalidValue ], None
        ],
        
        # Verify that an InvalidValue error is returned when specify a priority is not in range 0 -  UINT_MAX for PRIORITY
        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE 1 PRIORITY -1',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE 1 PRIORITY 9999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE 1 PRIORITY X',
          [ STAFRC.InvalidValue ], None
        ],

        # Verify that an InvalidValue error is returned when specify a handle# not in range 1 -  2147483647 for HANDLE
        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE 1 HANDLE 0',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE 1 HANDLE 9999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY UNREGISTER ONENDOFHANDLE 1 HANDLE X',
          [ STAFRC.InvalidValue ], None
        ],

        # Test START COMMAND without using the SHELL option.
        [ 'STD:PROCESS', 'PROCESS', 'START COMMAND find',
          [ STAFRC.Ok ], r'\d*'
        ],

        # When specifying COMMAND STAF, need to specify SHELL so that some Unix platforms like AIX 4.3.3 don't return RC 10, STAFResult 8 (exec format error)

        [ 'STD:PROCESS', 'VAR',     'SET VAR "STAFTest/Process/Command=STAF" VAR "STAFTest/Process/Parms=local DELAY DELAY 10"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} PARMS {STAFTest/Process/Parms}',
          [ STAFRC.Ok ], r'\d*'
        ],

        # XXX: Commented out because on SMP machines, the list is usually empty
        # Verify that there is at least one completed process in the list
        #[ 'STD:PROCESS', 'PROCESS', 'LIST HANDLES COMPLETED',
        #  [ STAFRC.Ok ], None,
        #  "len(STAFResult) > 0"
        #],

        [ 'STD:PROCESS', 'VAR',     'SET VAR "STAFTest/Process/Command=STAF local DELAY DELAY 10" VAR STAFTest/Process/Timeout=10000',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WORKLOAD "{STAFTest Workload}" WAIT {STAFTest/Process/Timeout}',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 0"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WORKDIR {STAF/Config/STAFRoot} WORKLOAD "{STAFTest Workload" WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 0"
        ],

        [ 'STD:PROCESS', 'VAR',     'SET VAR STAFTest/Process/VarValue=myVariable1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} VAR "STAFTest/Process/myVar1={STAFTest/Process/VarValue}" VAR STAFTest/Process/myVar2=myVariable2 WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 0"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} ENV STAFTEST/ENV/MYVAR1={STAFTest/Process/VarValue} ENV STAFTEST/ENV/MYVAR2=MyVariable2 WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 0"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WORKLOAD {STAFTest/Process/Workload} TITLE {STAFTest/Process/Workload} WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 0"
        ],
        
        # Test valid WAIT values and timeouts

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WAIT 00000000000000',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WAIT 0s',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WAIT 0d',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WAIT 00h',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WAIT 000000000000000000d',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WAIT 0w',
          [ STAFRC.Timeout, STAFRC.Ok ], None
        ],

        [ 'STD:PROCESS', 'VAR',     'SET VAR STAFTest/Process/StopUsing=SIGKILLALL VAR STAFTest/Process/UserName=STAFTest VAR STAFTest/Process/Password=password',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} NEWCONSOLE STOPUSING SIGKILLALL ASYNC',
          [ STAFRC.Ok ], r'\d*'
        ],
        
        # Check that get proper errors when specify invalid values for options when starting a process

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" STOPUSING InvalidMode WAIT',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WORKDIR doesNotExistNoWayNoHow WAIT',
          [ STAFRC.BaseOSError, STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WORKDIR {STAF/Config/STAFRoot}/docs/History WAIT',
          [ STAFRC.BaseOSError, STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" FOCUS',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" FOCUS XXX',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" VAR "XXX" WAIT',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT XXX',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT 999999999999999999999999',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT 9999999w',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT 1sec',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT {STAFTest/DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT STDIN {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow',
          [ STAFRC.BaseOSError ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT STDOUT {STAF/Config/STAFRoot}',
          [ STAFRC.BaseOSError ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT STDERR {STAF/Config/STAFRoot}',
          [ STAFRC.BaseOSError ], r'.*'
        ],

        # Specifying a directory path for stdout or stderr that contains directories that don't exist works as of STAF V3.4.7

        [ 'STD:PROCESS', 'FS', 'DELETE ENTRY {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow RECURSE CONFIRM',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF local PING PING" WAIT STDOUT {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow/noexist/stdout.out RETURNSTDOUT STDERRTOSTDOUT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 1 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 0 and " +
          "STAFResult['fileList'][0]['data']"
        ],

        [ 'STD:PROCESS', 'FS', 'DELETE ENTRY {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF local PING PING" WAIT STDOUTAPPEND {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow/noexist/stdout.out RETURNSTDOUT STDERRTOSTDOUT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 1 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 0 and " +
          "STAFResult['fileList'][0]['data']"
        ],

        [ 'STD:PROCESS', 'FS', 'DELETE ENTRY {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF local PING PING" WAIT STDERR {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow/noexist/stderr.out RETURNSTDOUT RETURNSTDERR',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 2 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 0 and " +
          "STAFResult['fileList'][0]['data'] and "
          "string.atoi(STAFResult['fileList'][1]['rc']) == 0"
        ],

        [ 'STD:PROCESS', 'FS', 'DELETE ENTRY {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF local PING PING" WAIT STDERRAPPEND {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow/noexist/stderr.out RETURNSTDOUT RETURNSTDERR',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 2 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 0 and " +
          "STAFResult['fileList'][0]['data'] and "
          "string.atoi(STAFResult['fileList'][1]['rc']) == 0"
        ],

        [ 'STD:PROCESS', 'FS', 'DELETE ENTRY {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        # Verify that an InvalidValue error is returned if STDOUT and STDERR point to the same file 
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT STDOUT {STAF/Config/STAFRoot}/stdout.out STDERR {STAF/Config/STAFRoot}/stdout.out',
          [ STAFRC.InvalidValue ], r'.*'
        ],

        # Verify that an InvalidValue error is returned if STDOUT and STDERR point to the same file (even when the file names are only the same after being "normalized")
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT STDOUT {STAF/Config/STAFRoot}/stdout.out STDERR {STAF/Config/STAFRoot}/stdout.out/',
          [ STAFRC.InvalidValue ], r'.*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT NOTIFY ONEND HANDLE Noexist',
          [ STAFRC.InvalidValue ], r'.*'
        ],                                                                                                                         
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT NOTIFYONEND HANDLE Noexist',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND "STAF" WAIT RETURNFILE {STAF/Config/STAFRoot}/DoesNotExistNoWayNoHow',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 1 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 1 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 17"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} WORKDIR {STAF/Config/STAFRoot} WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 0"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} USERNAME {STAFTest/Process/UserName} IGNOREDISABLEDAUTH WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 0"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} USERNAME {STAFTest/Process/UserName} PASSWORD {STAFTest/Process/Password} DISABLEDAUTHISERROR WAIT',
          [ STAFRC.ProcessAuthenticationDenied ], r'.*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} PASSWORD {STAFTest/Process/Password} WAIT',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],

        [ 'STD:PROCESS', 'VAR',     'SET VAR STAFTest/Process/Name=STAFTest',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} STATICHANDLENAME {STAFTest/Process/Name} STDIN {STAF/Config/ConfigFile} RETURNFILE {STAF/Config/ConfigFile} RETURNFILE {STAF/Config/ConfigFile} FOCUS Background WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 2 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 0 and " +
          "STAFResult['fileList'][0]['data'] and " +
          "string.atoi(STAFResult['fileList'][1]['rc']) == 0 and " +
          "STAFResult['fileList'][1]['data']"
        ],

        # Verify using NEWCONSOLE works
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} NEWCONSOLE WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "len(STAFResult['fileList']) == 0"
        ],
        
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} SAMECONSOLE STDOUT {STAF/DataDir}/user/STAFTest.out STDERR {STAF/DataDir}/user/STAFTest.err FOCUS Foreground WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 0"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} SAMECONSOLE STDOUTAPPEND {STAF/DataDir}/user/STAFTest.out STDERRAPPEND {STAF/DataDir}/user/STAFTest.err RETURNSTDOUT RETURNSTDERR WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 2 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 0 and " +
          "STAFResult['fileList'][0]['data'] and " +
          "string.atoi(STAFResult['fileList'][1]['rc']) == 0 and " +
          "(STAFResult['fileList'][1]['data'] == '' or STAFResult['fileList'][1]['data'] != '')"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} FOCUS {STAFTest/Process/Min} SAMECONSOLE STDOUT {STAF/DataDir}/user/STAFTest.out STDERRTOSTDOUT RETURNSTDOUT WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 1 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 0 and " +
          "STAFResult['fileList'][0]['data']"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} SAMECONSOLE RETURNSTDERR RETURNSTDOUT WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 2 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 0 and " +
          "STAFResult['fileList'][0]['data'] and " +
          "string.atoi(STAFResult['fileList'][1]['rc']) == 0 and " +
          "(STAFResult['fileList'][1]['data'] == '' or STAFResult['fileList'][1]['data'] != '')"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} SAMECONSOLE STDERRTOSTDOUT RETURNSTDOUT WAIT',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 1 and " +
          "string.atoi(STAFResult['fileList'][0]['rc']) == 0 and " +
          "STAFResult['fileList'][0]['data']"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} NOTIFY ONEND',
          [ STAFRC.Ok ], r'\d*'
        ],

        [ 'STD:PROCESS', 'VAR',     'SET VAR STAFTest/Process/Handle=%s VAR STAFTest/Process/Priority=4 VAR STAFTest/Process/Machine=%s' % (JobHandle, TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} NOTIFY ONEND HANDLE {STAFTest/Process/Handle}',
          [ STAFRC.Ok ], r'\d*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} NOTIFY ONEND NAME {STAFTest/Process/Name} PRIORITY {STAFTest/Process/Priority}',
          [ STAFRC.Ok ], r'\d*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} NOTIFY ONEND MACHINE {STAFTest/Process/Machine}',
          [ STAFRC.Ok ], r'\d*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} NOTIFY ONEND MACHINE {STAFTest/Process/Machine} RETURNSTDERR RETURNSTDOUT',
          [ STAFRC.Ok ], r'\d*'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} NOTIFY ONEND MACHINE {STAFTest/Process/Machine} STDERRTOSTDOUT RETURNSTDOUT',
          [ STAFRC.Ok ], r'\d*'
        ],

        [ 'STD:PROCESS', 'VAR',     'SET VAR "STAFTest/Process/Shell=%s"' % (TestMachShell),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'VAR',     'SET VAR "STAFTest/Process/StopWorkload=myWorkload"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL "{STAFTest/Process/Shell}" COMMAND {STAFTest/Process/Command} WAIT WORKLOAD {STAFTest/Process/StopWorkload}',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['rc']) == 0 and " +
          "STAFResult['key'] == None and " +
          "len(STAFResult['fileList']) == 0"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'NOTIFY LIST ONENDOFHANDLE %s' % QHandle,
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "string.atoi(STAFResult[0]['priority']) > 0 and " +
          "string.atoi(STAFResult[0]['priority']) &lt; 6 and " +
          "STAFResult[0]['machine'] and " +
          "STAFResult[0]['notifyBy'] == 'Handle' and " +
          "string.atoi(STAFResult[0]['notifiee']) > 0"
        ],

        # Test the STOP request

        # Verify that when specifying the PROCESS STOP request, must specify 
        # one of the following options: HANDLE, ALL, or WORKLOAD
        [ 'STD:PROCESS', 'PROCESS', 'STOP',
          [ STAFRC.InvalidRequestString ], None,
        ],
        [ 'STD:PROCESS', 'PROCESS', 'STOP ALL CONFIRM HANDLE XYZ',
          [ STAFRC.InvalidRequestString ], None,
        ],
        [ 'STD:PROCESS', 'PROCESS', 'STOP HANDLE XYZ WORKLOAD XYZ',
          [ STAFRC.InvalidRequestString ], None,
        ],

        # Verify that the CONFIRM option is required for the ALL option and
        # can't be specified if the ALL option is not specified
        [ 'STD:PROCESS', 'PROCESS', 'STOP HANDLE XYZ CONFIRM',
          [ STAFRC.InvalidRequestString ], None,
        ],
        [ 'STD:PROCESS', 'PROCESS', 'STOP WORKLOAD XYZ CONFIRM',
          [ STAFRC.InvalidRequestString ], None,
        ],

        # Verify that an InvalidValue error is returned when specify a handle# not in range 1 -  2147483647
        [ 'STD:PROCESS', 'PROCESS', 'STOP HANDLE 0',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'STOP HANDLE 9999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'STOP HANDLE X',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:PROCESS', 'PROCESS', 'STOP WORKLOAD {STAFTest/Process/StopWorkload}',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['stoppedProcesses']) >= 0 and "
          "string.atoi(STAFResult['totalProcesses']) > 0"
        ],

        # Verify that if an invalid stop using method for an operating systme is specified
        # (e.g. WM_CLOSE on Unix or SIGINTALL or SIGTERMALL on Windows) that get an error

        [ 'STD:PROCESS', 'PROCESS', 'STOP WORKLOAD DoesNotExist USING %s' % (invalidStopMethodForOS),
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND {STAFTest/Process/Command} STOPUSING %s' % (invalidStopMethodForOS),
          [ STAFRC.InvalidValue ], r'\d*'
        ],

        # Verify that if a valid stop using method is specified that no error occurs

        [ 'STD:PROCESS', 'PROCESS', 'STOP WORKLOAD DoesNotExist USING %s' % (validStopMethodForOS_1),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['stoppedProcesses']) == 0 and "
          "string.atoi(STAFResult['totalProcesses']) > 0"
        ],
        [ 'STD:PROCESS', 'PROCESS', 'STOP WORKLOAD DoesNotExist USING %s' % (validStopMethodForOS_2),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['stoppedProcesses']) == 0 and "
          "string.atoi(STAFResult['totalProcesses']) > 0"
        ],
        [ 'STD:PROCESS', 'PROCESS', 'STOP WORKLOAD DoesNotExist USING %s' % (validStopMethodForOS_3),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['stoppedProcesses']) == 0 and "
          "string.atoi(STAFResult['totalProcesses']) > 0"
        ],
        [ 'STD:PROCESS', 'PROCESS', 'STOP WORKLOAD DoesNotExist USING %s' % (validStopMethodForOS_4),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['stoppedProcesses']) == 0 and "
          "string.atoi(STAFResult['totalProcesses']) > 0"
        ],
        [ 'STD:PROCESS', 'PROCESS', 'STOP WORKLOAD DoesNotExist USING %s' % (validStopMethodForOS_5),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['stoppedProcesses']) == 0 and "
          "string.atoi(STAFResult['totalProcesses']) > 0"
        ],

        # Test the KILL request

        # Verify that an InvalidValue errror is returned when specify a pid not in range 0 - 4294967295
        [ 'STD:PROCESS', 'PROCESS', 'KILL PID 99x CONFIRM',
          [ STAFRC.InvalidValue ], None,
        ],

        # Don't specify 0 for the PID (e.g.  PID 0 or PID :0:) because on some Unix machines like
        # Linux, that will kill all STAFProc as 0 means to kill all the processes in the same group

        # Verify that get an InvalidValue error if specify a PID out of the supported range
        # which is 0 to 4294967295 on Windows and 0 to 2147483647 on Unix
        [ 'STD:PROCESS', 'PROCESS', 'KILL PID 000999999999999999 CONFIRM',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:PROCESS', 'PROCESS', 'KILL PID 4294967296 CONFIRM',
          [ STAFRC.InvalidValue ], None,
        ],

        # Verify that the CONFIRM option is required
        [ 'STD:PROCESS', 'PROCESS', 'KILL PID 2147483647',
          [ STAFRC.InvalidRequestString ], None,
        ],
        # Verify that a valid USING option is required
        [ 'STD:PROCESS', 'PROCESS', 'KILL PID 2147483647 CONFIRM USING XYZ',
          [ STAFRC.InvalidValue ], None,
        ],

        # Verify that the PID and USING options resolve STAF variables
        [ 'STD:PROCESS', 'VAR',  'SET VAR "STAFTest/Process/Kill/Pid=2147483647" VAR "STAFTest/Process/Kill/Using=SIGKILLALL"',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:PROCESS', 'PROCESS', 'KILL PID {STAFTest/Process/Kill/Pid} CONFIRM',
          [ STAFRC.DoesNotExist ], None,
        ],
        # Verify that the USING option resolves STAF variables
        [ 'STD:PROCESS', 'PROCESS', 'KILL PID {STAFTest/Process/Kill/Pid} USING {STAFTest/Process/Kill/Using} CONFIRM',
          [ STAFRC.DoesNotExist ], None,
        ],
        # Clean up STAF variables set for testing the KILL command
        [ 'STD:PROCESS', 'VAR',  'DELETE VAR STAFTest/Process/Kill/Pid VAR STAFTest/Process/Kill/Using',
          [ STAFRC.Ok ], r'^$'
        ],

        # Test the FREE request

        [ 'STD:PROCESS', 'PROCESS', 'FREE ALL',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['freedProcesses']) >= 0 and " +
          "string.atoi(STAFResult['totalProcesses']) > 0"
        ],

        # Verify that the static handle created when starting a process using the STATICHANDLENAME option 
        # has a pid associated with it when submitting a LIST request to the HANDLE service.

        [ 'STD:PROCESS', 'PROCESS', 'START SHELL COMMAND staf STATICHANDLENAME STAFTest/MyUniqueHandle WORKLOAD STAFTest/MyUniqueWorkload',
          [ STAFRC.Ok ], r'^.' 
        ],
        
        [ 'STD:PROCESS', 'HANDLE', 'LIST HANDLES NAME STAFTest/MyUniqueHandle STATIC LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "int(STAFResult[0]['pid']) > 0"
        ],

        [ 'STD:PROCESS', 'PROCESS', 'FREE WORKLOAD STAFTest/MyUniqueWorkload',
          [ STAFRC.Ok ], None
        ],

        # End of static handle pid test

        [ 'STD:PROCESS', 'VAR',     'DELETE VAR STAFTest/Process/Workload VAR STAFTest/Process/Handle VAR STAFTest/Process/Machine VAR STAFTest/Process/Priority',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'VAR',     'DELETE VAR STAFTest/Process/Command VAR STAFTest/Process/Parms VAR STAFTest/Process/Timeout VAR STAFTest/Process/VarValue',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'VAR',     'DELETE VAR STAFTest/Process/StopUsing VAR STAFTest/Process/UserName VAR STAFTest/Process/Password VAR STAFTest/Process/Min',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'VAR',     'DELETE VAR STAFTest/Process/Name VAR STAFTest/Process/Shell',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:PROCESS', 'SEM',     'RELEASE MUTEX STAFTest/PROCESS',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>PROCESSTests</return>

    </sequence>
    </testcase>
  </function>


  <!-- ============================================================================ -->
  <!-- InitHANDLETests - This function initializes all the HANDLE test information  -->
  <!-- ============================================================================ -->

  <function name="InitHANDLETests" scope="local">
    <sequence>

      <script>

      HANDLETests = [

        #
        #HANDLE tests
        #

        [ 'STD:HANDLE', 'SEM',    'REQUEST MUTEX STAFTest/HANDLE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:HANDLE', 'HANDLE', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['handle'] and STAFResult[0]['name'] and " +
          "STAFResult[0]['state'] and STAFResult[0]['lastUsedTimestamp']"
        ],
        
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "int(STAFResult[0]['handle']) == 1 and STAFResult[0]['name'] == 'STAF_Process' and " +
          "STAFResult[0]['state'] == 'InProcess' and STAFResult[0]['lastUsedTimestamp'] and " +
          "int(STAFResult[0]['pid']) > 0"
        ],
        
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES SUMMARY LONG',
          [ STAFRC.InvalidRequestString ], None
        ],
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES SUMMARY NAME',
          [ STAFRC.InvalidRequestString ], None
        ],
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES SUMMARY PENDING',
          [ STAFRC.InvalidRequestString ], None
        ],
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES SUMMARY REGISTERED',
          [ STAFRC.InvalidRequestString ], None
        ],
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES SUMMARY INPROCESS',
          [ STAFRC.InvalidRequestString ], None
        ],
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES SUMMARY STATIC',
          [ STAFRC.InvalidRequestString ], None
        ],
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES SUMMARY',
          [ STAFRC.Ok ], None,
          "long(STAFResult['activeHandles']) > 1 and " +
          "long(STAFResult['totalHandles']) > 1 and " +
          "long(STAFResult['resetCount']) >= 0 and " +
          "STAFResult['handleNumberRange'] and " +
          "long(STAFResult['maxActiveHandles']) >= 2147483647"
        ],

        [ 'STD:HANDLE', 'HANDLE', 'QUERY HANDLE 1',
          [ STAFRC.Ok ], None,
          "int(STAFResult['handle']) == 1 and STAFResult['name'] == 'STAF_Process' and " +
          "STAFResult['state'] == 'InProcess' and STAFResult['lastUsedTimestamp'] and " +
          "int(STAFResult['pid']) > 0 and STAFResult['user'] == 'none://anonymous' and " +
          "STAFResult['instanceUUID']"
        ],
        
        [ 'STD:HANDLE', 'HANDLE', 'QUERY HANDLE XYZ',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:HANDLE', 'HANDLE', 'QUERY HANDLE 0',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:HANDLE', 'HANDLE', 'QUERY HANDLE 2147483648',
          [ STAFRC.InvalidValue ], r'.*'
        ],

        # Test Bug #1755775 "QUERY HANDLE returns 0 if handle not found"
        [ 'STD:HANDLE', 'HANDLE', 'QUERY HANDLE 00000000000999999999',
          [ STAFRC.HandleDoesNotExist ], r'.*'
        ],
        [ 'STD:HANDLE', 'HANDLE', 'QUERY HANDLE 000000000009999999999',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:HANDLE', 'HANDLE', 'QUERY HANDLE 0000000000',
          [ STAFRC.InvalidValue ], r'.*'
        ],

        [ 'STD:HANDLE', 'VAR', 'SET VAR "STAFTest/HandleNum=1"',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:HANDLE', 'HANDLE', 'QUERY HANDLE {STAFTest/HandleNum}',
          [ STAFRC.Ok ], None,
          "int(STAFResult['handle']) == 1 and STAFResult['name'] == 'STAF_Process' and " +
          "STAFResult['state'] == 'InProcess' and STAFResult['lastUsedTimestamp'] and " +
          "int(STAFResult['pid']) > 0 and STAFResult['user'] == 'none://anonymous' and " +
          "STAFResult['instanceUUID']"
        ],

        [ 'STD:HANDLE', 'VAR', 'DELETE VAR "STAFTest/HandleNum"',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <!--  Only can create/delete and authenticate/unauthenticate a handle if local machine -->
      <if expr="testMachineIsLocal">
        <script>
        HANDLETests = HANDLETests + [

        [ 'STD:HANDLE', 'VAR',    'SET VAR STAFTest/myHandle=mySTAFTest',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'CREATE HANDLE NAME {STAFTest/myHandle}',
          [ STAFRC.Ok ], r'.*'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'CREATE HANDLE NAME {STAFTest/DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],

        [ 'STD:HANDLE', 'VAR',    'SET VAR STAFTest/HandleNumber=99999999',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'DELETE HANDLE {STAFTest/HandleNumber}',
          [ STAFRC.HandleDoesNotExist ], r'.*'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'DELETE HANDLE 1',
          [ STAFRC.InvalidHandle ], r'.*'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'DELETE HANDLE {STAFTest/DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'DELETE HANDLE 0',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:HANDLE', 'HANDLE', 'DELETE HANDLE 2147483648',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:HANDLE', 'HANDLE', 'DELETE HANDLE -1',
          [ STAFRC.InvalidValue ], r'.*'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES NAME {STAFTest/myHandle}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['handle'] and STAFResult[0]['name'] == 'mySTAFTest' and " +
          "STAFResult[0]['state'] == 'Static' and STAFResult[0]['lastUsedTimestamp']"
        ],
        
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES NAME {STAFTest/myHandle} LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['handle'] and STAFResult[0]['name'] == 'mySTAFTest' and " +
          "int(STAFResult[0]['pid']) == 0 and " +
          "STAFResult[0]['state'] == 'Static' and STAFResult[0]['lastUsedTimestamp']"
        ],

        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES NAME mySTAFTest STATIC LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['handle'] and STAFResult[0]['name'] == 'mySTAFTest' and " +
          "int(STAFResult[0]['pid']) == 0 and " +
          "STAFResult[0]['state'] == 'Static' and STAFResult[0]['lastUsedTimestamp']"
        ],

        [ 'STD:HANDLE', 'HANDLE', 'AUTHENTICATE USER User1 CREDENTIALS Password1 AUTHENTICATOR DoesNotExist',
          [ STAFRC.DoesNotExist, STAFRC.AccessDenied ], None
        ],

        [ 'STD:HANDLE', 'HANDLE', 'UNAUTHENTICATE',
          [ STAFRC.Ok, STAFRC.AccessDenied ], None
        ],

        # Make sure AUTHENTICATE requests resolve variables for USER and AUTHENTICATOR
        [ 'STD:HANDLE', 'VAR',    'SET VAR STAFTest/AuthUser=User1 VAR STAFTest/Authenticator=myAuth',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'AUTHENTICATE USER {DoesNotExist} CREDENTIALS Password1 AUTHENTICATOR DoesNotExist',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:HANDLE', 'HANDLE', 'AUTHENTICATE USER User1 CREDENTIALS Password1 AUTHENTICATOR {STAFTest/Authenticator}',
          [ STAFRC.DoesNotExist ], None ],

        [ 'STD:HANDLE', 'HANDLE', 'AUTHENTICATE USER User1 CREDENTIALS Password1 AUTHENTICATOR {DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:HANDLE', 'VAR',    'DELETE VAR STAFTest/myHandle VAR STAFTest/HandleNumber',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HANDLE', 'VAR',    'DELETE VAR STAFTest/AuthUser VAR STAFTest/Authenticator',
          [ STAFRC.Ok ], r'^$'
        ]

        ]
        </script>
      </if>

      <script>
        HANDLETests = HANDLETests + [

        [ 'STD:HANDLE', 'VAR',    'SET VAR STAFTest/Handle=STAFTest',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES NAME {STAFTest/DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], None
        ],

        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES INPROCESS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['handle'] and STAFResult[0]['name'] and " +
          "STAFResult[0]['state'] == 'InProcess' and STAFResult[0]['lastUsedTimestamp']"
        ],

        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES PENDING',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES REGISTERED',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['handle'] and " +
          " STAFResult[0]['name'] and " +
          " STAFResult[0]['state'] == 'Registered' and " +
          " STAFResult[0]['lastUsedTimestamp'])"
        ],

        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES REGISTERED STATIC',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['handle'] and STAFResult[0]['name'] and " +
          "STAFResult[0]['state'] and STAFResult[0]['lastUsedTimestamp']"
        ],
        
        [ 'STD:HANDLE', 'HANDLE', 'LIST HANDLES NAME mySTAFTest STATIC LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          "STAFResult[0]['handle'] and STAFResult[0]['name'] and " +
          "int(STAFResult[0]['pid']) == 0 and " +
          "STAFResult[0]['state'] and STAFResult[0]['lastUsedTimestamp'])"
        ]
        
        ]
      </script>
    
      <!--  Only can submit a STAF_NOTIFY REGISTER/UNREGISTER request to the local machine -->
      <if expr="testMachineIsLocal">
        <script>
        HANDLETests = HANDLETests + [

        [ 'STD:HANDLE', 'HANDLE', 'STAF_NOTIFY REGISTER ONENDOFHANDLE 1 MACHINE tcp://myMachine UUID myUUID SERVICE myService KEY key1',
          [ STAFRC.NoPathToMachine ], '.*'
        ],

        [ 'STD:HANDLE', 'HANDLE', 'STAF_NOTIFY REGISTER ONENDOFHANDLE 1 MACHINE %s KEY key1 UUID myUUID SERVICE myService' % (STAXEndpoint),
          [ STAFRC.Ok, ], None
        ],
        
        [ 'STD:HANDLE', 'HANDLE', 'LIST NOTIFICATIONS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['handle'] and STAFResult[0]['machine'] and " +
          "STAFResult[0]['notifyService']"
        ],

        [ 'STD:HANDLE', 'HANDLE', 'LIST NOTIFICATIONS POLLING',
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 0"
        ],

        [ 'STD:HANDLE', 'HANDLE', 'STAF_NOTIFY UNREGISTER ONENDOFHANDLE 1 MACHINE %s KEY key1 UUID myUUID SERVICE myService' % (STAXEndpoint),
          [ STAFRC.Ok ], None
        ]

        ]
       </script>
       <else>
         <!-- Should get RC 25 if submit a STAF_NOTIFY REGISTER/UNREGISTER request to a non-local machine -->

         <script>
           HANDLETests = HANDLETests + [

           [ 'STD:HANDLE', 'HANDLE', 'STAF_NOTIFY REGISTER ONENDOFHANDLE 1 MACHINE myMachine UUID myUUID SERVICE myService KEY key1',
             [ STAFRC.AccessDenied ], '.*'
           ],

           [ 'STD:HANDLE', 'HANDLE', 'STAF_NOTIFY UNREGISTER ONENDOFHANDLE 1 MACHINE myMachine UUID myUUID SERVICE myService KEY key1',
             [ STAFRC.AccessDenied ], '.*'
           ]

           ]
         </script>
       </else>
      </if>

      <script>

        HANDLETests = HANDLETests + [

        [ 'STD:HANDLE', 'VAR',    'DELETE VAR STAFTest/Handle',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:HANDLE', 'SEM',    'RELEASE MUTEX STAFTest/HANDLE',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>HANDLETests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitSEMTests - This function initializes all the SEM test information      -->
  <!-- ========================================================================== -->

  <function name="InitSEMTests" scope="local">
    <sequence>

      <testcase name="'SEM'">
        <sequence>

          <sequence>

          <!-- Clean up mutex and event semaphores in case test was interupted on a previous run -->

          <!-- Release and Delete the mutex semaphore -->

          <message>
            'STAF %s SEM RELEASE MUTEX STAFTest/MutexSem FORCE' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'RELEASE MUTEX STAFTest/MutexSem FORCE'</request>
          </stafcmd>

          <message>
            'STAF %s SEM DELETE MUTEX STAFTest/MutexSem' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'DELETE MUTEX STAFTest/MutexSem'</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC in [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ],
              'failMsg': 'STAF %s SEM DELETE MUTEX STAFTest/MutexSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
              'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <!-- Reset and Delete the event semaphore -->

          <message>
            'STAF %s SEM RESET EVENT STAFTest/EventSem' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'RESET EVENT STAFTest/EventSem'</request>
          </stafcmd>

          <message>
            'STAF %s SEM DELETE EVENT STAFTest/EventSem' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'DELETE EVENT STAFTest/EventSem'</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC in [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ],
              'failMsg': 'STAF %s SEM DELETE EVENT STAFTest/EventSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
              'sendToMonitor': 1, 'recordStatus': 1 }
          </call>
          </sequence>

          <parallel>

            <sequence>

              <!-- Request a mutex semaphore -->

              <message>
                'STAF %s SEM REQUEST MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'REQUEST MUTEX STAFTest/MutexSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM REQUEST MUTEX STAFTest/MutexSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <!-- Request the mutex semaphore again and wait indefinitely for it -->

              <message>
                'STAF %s SEM REQUEST MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'REQUEST MUTEX STAFTest/MutexSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM REQUEST MUTEX STAFTest/MutexSem  RC=%s STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <!-- Test Event Semaphores -->

              <!-- Wait on an event semaphore -->

              <message>
                'STAF %s SEM WAIT EVENT STAFTest/EventSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'WAIT EVENT STAFTest/EventSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM WAIT EVENT STAFTest/EventSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <!-- Delete the event semaphore -->

              <message>
                'STAF %s SEM DELETE EVENT STAFTest/EventSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'DELETE EVENT STAFTest/EventSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM DELETE EVENT STAFTest/EventSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

            </sequence>

            <sequence>

              <!-- Delay for 20 seconds to make sure that the mutex requests have been made -->

              <message>
                'STAF %s DELAY DELAY 20s' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'DELAY'</service>
                <request>'DELAY 20s'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s DELAY DELAY 20s  RC=%s STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <!-- Query the mutex semaphore -->

              <message>
                'STAF %s SEM QUERY MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'QUERY MUTEX STAFTest/MutexSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM QUERY MUTEX STAFTest/MutexSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <script>
                 if (STAFResult['state'] == 'Owned' and
                     STAFResult['owner'] and
                     len(STAFResult['requestList']) > 0 and
                     STAFResult['requestList'][0]['machine'] and
                     STAFResult['requestList'][0]['handleName'] and
                     STAFResult['requestList'][0]['handle'] and
                     STAFResult['requestList'][0]['user'] and
                     STAFResult['requestList'][0]['endpoint'].find('://') != -1 and
                     STAFResult['requestList'][0].has_key('gc') and STAFResult['requestList'][0]['gc'] == 'Yes' and
                     STAFResult['requestList'][0]['requestTimestamp']):
                   failMsg = ''
                 else:
                   failMsg = 'Result from SEM QUERY MUTEX STAFTest/MutexSem does not match. STAFResult=%s' % (STAFResult)
              </script>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': failMsg == '',
                  'failMsg': failMsg,
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <message>
                'STAF %s SEM RELEASE MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <!-- Release the mutex semaphore -->

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'RELEASE MUTEX STAFTest/MutexSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM RELEASE MUTEX STAFTest/MutexSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <message>
                'STAF %s SEM RELEASE MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <!-- Release the mutex semaphore -->

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'RELEASE MUTEX STAFTest/MutexSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM RELEASE MUTEX STAFTest/MutexSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>
              
              <!-- Delete the mutex semaphore -->

              <message>
                'STAF %s SEM DELETE MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'DELETE MUTEX STAFTest/MutexSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM DELETE MUTEX STAFTest/MutexSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <!-- Test that garbage collection is taking place for the handle that requested the mutex semaphore -->

              <message>
                'Test garbage collection is taking place:  STAF %s SEM REQUEST MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <process name="'TestGarbageCollectedMutex'">
                <location>TestMach</location>
                <command mode="'shell'">
                  'STAF local SEM REQUEST MUTEX STAFTest/MutexSem'
                </command>
                <stderr mode="'stdout'"/>
                <returnstdout/>
              </process>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM REQUEST MUTEX STAFTest/MutexSem  RC=%s STAFResult=%s STAXResult=%s' % (TestMach, RC, STAFResult, STAXResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <stafcmd name="'Delay 5 seconds while wait for gc to occur'">
                <location>'local'</location>
                <service>'DELAY'</service>
                <request>'DELAY 5s'</request>
              </stafcmd>

              <message>
                'STAF %s SEM QUERY MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'QUERY MUTEX STAFTest/MutexSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM QUERY MUTEX STAFTest/MutexSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <script>
                 if STAFResult['state'] == 'Unowned':
                   failMsg = ''
                 else:
                   failMsg = 'SEM QUERY MUTEX STAFTest/MutexSem shows that the mutex is owned when it should be unowned due to garbage collection. STAFResult=%s' % (STAFResult)
              </script>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': failMsg == '',
                  'failMsg': failMsg,
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <!-- Test that garbage collection is not taking place for the handle that requested the mutex semaphore -->

              <message>
                'Test garbage collection is not taking place:  STAF %s SEM REQUEST MUTEX STAFTest/MutexSem GARBAGECOLLECT No' % (TestMach)
              </message>

              <process name="'TestNoGarbageCollectedMutex'">
                <location>TestMach</location>
                <command mode="'shell'">
                  'STAF local SEM REQUEST MUTEX STAFTest/MutexSem GARBAGECOLLECT No'
                </command>
                <stderr mode="'stdout'"/>
                <returnstdout/>
              </process>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM REQUEST MUTEX STAFTest/MutexSem GARBAGECOLLECT No  RC=%s STAFResult=%s STAXResult=%s' % (TestMach, RC, STAFResult, STAXResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <stafcmd name="'Delay 5 seconds while wait for gc to occur'">
                <location>'local'</location>
                <service>'DELAY'</service>
                <request>'DELAY 5s'</request>
              </stafcmd>

              <message>
                'STAF %s SEM QUERY MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'QUERY MUTEX STAFTest/MutexSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM QUERY MUTEX STAFTest/MutexSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <script>
                 if (STAFResult['state'] == 'Owned' and STAFResult['owner']['gc'] == 'No'):
                   failMsg = ''
                 else:
                   failMsg = 'SEM QUERY MUTEX STAFTest/MutexSem shows that the mutex is unowned when it should be owned due to no garbage collection. STAFResult=%s' % (STAFResult)
              </script>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': failMsg == '',
                  'failMsg': failMsg,
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <!-- Release and Delete the mutex semaphore -->

              <message>
                'STAF %s SEM RELEASE MUTEX STAFTest/MutexSem FORCE' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'RELEASE MUTEX STAFTest/MutexSem FORCE'</request>
              </stafcmd>

              <message>
                'STAF %s SEM DELETE MUTEX STAFTest/MutexSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'DELETE MUTEX STAFTest/MutexSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC in [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ],
                  'failMsg': 'STAF %s SEM DELETE MUTEX STAFTest/MutexSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

              <!-- Test Event Semaphores -->

              <!-- Post an event semaphore -->

              <message>
                'STAF %s SEM POST EVENT STAFTest/EventSem' % (TestMach)
              </message>

              <stafcmd>
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'POST EVENT STAFTest/EventSem'</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'STAF %s SEM POST EVENT STAFTest/EventSem  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
              </call>

            </sequence>

          </parallel>

          <!-- Test Garbage Collection fix for Bug #1753842 and Bug #1757183:
                Create a new handle and use it to request two mutex semaphores and then
                release the second mutex semaphore.  Delete that handle and then verify that
                both mutex semaphores are now unowned.  -->

          <message>
            'Test garbage collection fix with the same handle requests multiple mutex semaphores and with static handles created by the process service (Bugs #1753842 and #1757183)'
          </message>

          <script>
              command = 'STAF local SEM REQUEST MUTEX STAFTest/MutexSem1 {STAF/Config/Sep/Command}' + \
              'STAF local SEM REQUEST MUTEX STAFTest/MutexSem2 {STAF/Config/Sep/Command}' + \
              'STAF local SEM RELEASE MUTEX STAFTest/MutexSem2'
          </script>

          <process name="'Test Bugs 1753842 and 1757183 for SEM Service GC'">
            <location>TestMach</location>
            <command mode="'shell'">command</command>
            <statichandlename>'STAFTest for Mutex Sem GC'</statichandlename>
            <stderr mode="'stdout'"/>
            <returnstdout/>
          </process>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
              'failMsg': 'Process testing garbage collection fix for SEM service failed  RC=%s STAFResult=%s STAXResult=%s' % (RC, STAFResult, STAXResult),
              'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <stafcmd name="'Delay 5 seconds while wait for gc to occur'">
            <location>'local'</location>
            <service>'DELAY'</service>
            <request>'DELAY 5s'</request>
          </stafcmd>

          <message>
            'STAF %s SEM QUERY MUTEX STAFTest/MutexSem2' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'QUERY MUTEX STAFTest/MutexSem2'</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
              'failMsg': 'STAF %s SEM QUERY MUTEX STAFTest/MutexSem2  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
              'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <script>
             if STAFResult['state'] == 'Unowned':
               failMsg = ''
             else:
               failMsg = 'SEM QUERY MUTEX STAFTest/MutexSem2 shows that the mutex is owned when it should be unowned due to garbage collection. STAFResult=%s' % (STAFResult)
          </script>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': failMsg == '',
              'failMsg': failMsg,
              'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <message>
            'STAF %s SEM QUERY MUTEX STAFTest/MutexSem1' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'QUERY MUTEX STAFTest/MutexSem1'</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
              'failMsg': 'STAF %s SEM QUERY MUTEX STAFTest/MutexSem1  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
              'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <script>
             if STAFResult['state'] == 'Unowned':
               failMsg = ''
             else:
               failMsg = 'SEM QUERY MUTEX STAFTest/MutexSem1 shows that the mutex is owned when it should be unowned due to garbage collection. STAFResult=%s' % (STAFResult)
          </script>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': failMsg == '',
              'failMsg': failMsg,
              'sendToMonitor': 1, 'recordStatus': 1 }
          </call>
          
          <!-- Release and Delete the mutex semaphores in case the above test failed -->

          <message>
            'STAF %s SEM RELEASE MUTEX STAFTest/MutexSem1 FORCE' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'RELEASE MUTEX STAFTest/MutexSem1 FORCE'</request>
          </stafcmd>

          <message>
            'STAF %s SEM DELETE MUTEX STAFTest/MutexSem1' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'DELETE MUTEX STAFTest/MutexSem1'</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC in [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ],
              'failMsg': 'STAF %s SEM DELETE MUTEX STAFTest/MutexSem1  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
              'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <message>
            'STAF %s SEM RELEASE MUTEX STAFTest/MutexSem2 FORCE' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'RELEASE MUTEX STAFTest/MutexSem2 FORCE'</request>
          </stafcmd>

          <message>
            'STAF %s SEM DELETE MUTEX STAFTest/MutexSem2' % (TestMach)
          </message>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'DELETE MUTEX STAFTest/MutexSem2'</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC in [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ],
              'failMsg': 'STAF %s SEM DELETE MUTEX STAFTest/MutexSem2  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
              'sendToMonitor': 1, 'recordStatus': 1 }
          </call>
          <!-- End Garbage Collect test for Bug #1757183 -->

          <!-- Test cancelling pending requests for a mutex semaphore -->
          
          <message log="1">
            'Test the SEM CANCEL request on machine %s' % (TestMach)
          </message>

          <!-- Clean up any event semaphores from a previous run -->
          <iterate var="i" in="range(1, 4)">
            <stafcmd name="'Reset Event Semaphore STAFTest/SEM/Step%s' % (i)">
              <location>TestMach</location>
              <service>'SEM'</service>
              <request>'RESET EVENT STAFTest/SEM/Step%s' % (i)</request>
            </stafcmd>
          </iterate>
            
          <!-- Clean up the mutex semaphore if leftover from a previous run -->
          <script>command = 'RELEASE MUTEX STAFTest/Mutex1 FORCE'</script>
          <loop from="1" to="4">
            <stafcmd name="'Release STAFTest/Mutex1'">
              <location>TestMach</location>
              <service>'SEM'</service>
              <request>command</request>
            </stafcmd>
          </loop>
          <script>command = 'DELETE MUTEX STAFTest/Mutex1'</script>
          <message>
            'STAF %s SEM %s' % (TestMach, command)
          </message>
          <stafcmd name="'Delete STAFTest/Mutex1'">
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>command</request>
          </stafcmd>
          <call function="'STAXUtilCheckSuccess'">
           { 'result': RC in [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ],
             'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
             'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <!-- Request a mutex semaphore so that it is owned -->

          <script>command = 'REQUEST MUTEX STAFTest/Mutex1'</script>
          <message log="1">
            '(Initial) STAF %s SEM %s' % (TestMach, command)
          </message>
          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>command</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
           { 'result': RC == STAFRC.Ok,
             'failMsg': '%s RC=%s STAFResult=%s STAXResult=%s' % (command, RC, STAFResult, STAXResult),
             'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <parallel>
            <block name="'Step 1: SEM MUTEX CANCEL Test'">
              <sequence>
                <script>command = 'REQUEST MUTEX STAFTest/Mutex1'</script>
                <message log="1">'(1st Pending Request) STAF %s SEM %s' % (TestMach, command)</message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request mutex semaphore STAFTest/Mutex1'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.RequestCancelled,
                       'failMsg': 'RC=%s STAFResult=%s Expected RC=%s' % (RC, STAFResult, STAFRC.RequestCancelled),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while the request for STAFTest/Mutex1 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/SEM/Step3'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/SEM/Step1'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
            </block>

            <block name="'Step 2: SEM MUTEX CANCEL Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/SEM/Step1'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/SEM/Step1 TIMEOUT 10m'</request>
                </stafcmd>
                <script>command = 'REQUEST MUTEX STAFTest/Mutex1'</script>
                <message log="1">
                  '(2nd Pending Request) STAF %s SEM %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request mutex semaphore'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.RequestCancelled,
                       'failMsg': 'RC=%s STAFResult=%s Expected RC=%s' % (RC, STAFResult, STAFRC.RequestCancelled),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while the request for STAFTest/Mutex1 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/SEM/Step2'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/SEM/Step2'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
            </block>
              
            <block name="'Step 3: SEM MUTEX CANCEL Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/SEM/Step2'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/SEM/Step2 TIMEOUT 10m'</request>
                </stafcmd>
                <script>command = 'REQUEST MUTEX STAFTest/Mutex1'</script>
                <message log="1">
                  '(3rd Pending Request) STAF %s SEM %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request mutex semaphore'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.RequestCancelled,
                       'failMsg': 'RC=%s STAFResult=%s Expected RC=%s' % (RC, STAFResult, STAFRC.RequestCancelled),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while the request for STAFTest/Mutex1 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/SEM/Step5'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/SEM/Step3'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
            </block>

            <block name="'Step 4: SEM MUTEX CANCEL Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/SEM/Step3'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/SEM/Step3 TIMEOUT 10m'</request>
                </stafcmd>
                <message log="1">
                  'STAF %s SEM QUERY MUTEX STAFTest/Mutex1' % (TestMach)
                </message>
                <stafcmd name="'Query Mutex STAFTest/Mutex1'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'QUERY MUTEX STAFTest/Mutex1'</request>
                </stafcmd>
                <script>
                 # Verify that STAFTest/Mutex1 is owned and there are 3 pending requests
                 if (RC == STAFRC.Ok and
                    STAFResult['state'] == 'Owned' and len(STAFResult['requestList']) == 3):
                   success = 1
                   expectedResult = ''
                 else:
                   success = 0
                   expectedResult = '3 Pending Requests'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>
                  command = 'SET VAR STAFTest/MutexName=STAFTest/Mutex1' + \
                    ' VAR STAFTest/Mutex1/Handle=%s VAR STAFTest/Mutex1/HandleName=%s/Job/%s VAR STAFTest/Mutex1/Machine=%s' % \
                    (JobHandle, STAXServiceName, STAXJobID, STAXMachine)
                </script>
                <stafcmd name="'Set variables used by the cancel mutex request test'">
                  <location>TestMach</location>
                  <service>'VAR'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'CANCEL MUTEX {STAFTest/MutexName} LAST'</script>
                <message log="1">
                  'STAF %s SEM %s' % (TestMach, command)
                </message>
                <stafcmd name="'Cancel last pending request for mutex STAFTest/Mutex1'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                <stafcmd name="'Delay for 2 seconds while finish cancelling the mutex request'">
                  <location>'local'</location>
                  <service>'DELAY'</service>
                  <request>'DELAY 2s'</request>
                </stafcmd>

                <script>command = 'QUERY MUTEX STAFTest/Mutex1'</script>
                <message log="1">
                  'STAF %s SEM %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Mutex STAFTest/Mutex1'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that there are 2 pending requests for STAF/Mutex1
                 if (RC == STAFRC.Ok and
                    STAFResult['state'] == 'Owned' and len(STAFResult['requestList']) == 2):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '2 Pending Requests'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'CANCEL MUTEX {STAFTest/MutexName} FIRST'</script>
                <message log="1">
                  'STAF %s SEM %s' % (TestMach, command)
                </message>
                <stafcmd name="'Cancel first pending request for mutex STAFTest/Mutex1'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                <stafcmd name="'Delay for 2 seconds while finish cancelling the mutex request'">
                  <location>'local'</location>
                  <service>'DELAY'</service>
                  <request>'DELAY 2s'</request>
                </stafcmd>

                <script>command = 'QUERY MUTEX STAFTest/Mutex1'</script>
                <message log="1">
                  'STAF %s SEM %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Mutex STAFTest/Mutex1'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that there is 1 pending request for STAF/Mutex1
                 if (RC == STAFRC.Ok and
                    STAFResult['state'] == 'Owned' and len(STAFResult['requestList']) == 1):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '1 Pending Requests'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>
                  command = 'CANCEL MUTEX STAFTest/Mutex1 FORCE NAME {STAFTest/Mutex1/HandleName} MACHINE {STAFTest/Mutex1/Machine}'
                </script>
                <message log="1">
                  'STAF %s SEM %s' % (TestMach, command)
                </message>
                <stafcmd name="'Cancel last pending request for mutex STAFTest/Mutex1 submitted by this STAX job handle name on the STAX machine'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                <stafcmd name="'Delay for 2 seconds while finish cancelling the mutex request'">
                  <location>'local'</location>
                  <service>'DELAY'</service>
                  <request>'DELAY 2s'</request>
                </stafcmd>

                <script>command = 'QUERY MUTEX STAFTest/Mutex1'</script>
                <message log="1">
                  'STAF %s SEM %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Mutex STAFTest/Mutex1'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that there are no pending requests
                 if (RC == STAFRC.Ok and
                    STAFResult['state'] == 'Owned' and len(STAFResult['requestList']) == 0):
                   success = 1
                 else:
                   success = 0
                   expectedResult = 'No Pending Requests'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'CANCEL MUTEX STAFTest/Mutex1'</script>
                <message log="1">
                  'STAF %s SEM %s' % (TestMach, command)
                </message>
                <stafcmd name="'Cancel Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.DoesNotExist,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                 
                <script>command = 'RELEASE MUTEX STAFTest/Mutex1'</script>
                <message>
                  'STAF %s SEM %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release STAFTest/Mutex1'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'DELETE MUTEX STAFTest/Mutex1'</script>
                <message>
                  'STAF %s SEM %s' % (TestMach, command)
                </message>
                <stafcmd name="'Delete STAFTest/Mutex1'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <!-- Clean-up the event semaphores used by this test -->
                <iterate var="i" in="range(1, 6)">
                  <stafcmd name="'Delete Event Semaphore STAFTest/SEM/Step%s' % (i)">
                    <location>TestMach</location>
                    <service>'SEM'</service>
                    <request>'DELETE EVENT STAFTest/SEM/Step%s' % (i)</request>
                  </stafcmd>
                </iterate>

                <!--- Clean up the variables used by this test -->
                <script>
                  command = 'DELETE VAR STAFTest/MutexName' + \
                    ' VAR STAFTest/Mutex1/Handle' + \
                    ' VAR STAFTest/Mutex1/HandleName VAR STAFTest/Mutex1/Machine'
                </script>
                <stafcmd name="'Delete variables used by the cancel mutex request test'">
                  <location>TestMach</location>
                  <service>'VAR'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>'End testing the SEM CANCEL MUTEX request'</message>

              </sequence>
            </block>

          </parallel>

          <!-- Delete the event semaphores -->
          <iterate var="i" in="range(1, 4)">
            <stafcmd name="'Reset Event Semaphore STAFTest/SEM/Step%s' % (i)">
              <location>TestMach</location>
              <service>'SEM'</service>
              <request>'DELETE EVENT STAFTest/SEM/Step%s' % (i)</request>
            </stafcmd>
          </iterate>

          <!-- End testing cancelling pending requests -->

        </sequence>
      </testcase>

      <script>

      SEMTests = [

        #
        #SEM tests
        #

        [ 'STD:SEM', 'SEM', 'REQUEST MUTEX STAFTest/SEM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:SEM', 'SEM', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:SEM', 'VAR', 'SET VAR STAFTest/mutexName=aaaMutex VAR STAFTest/eventName=aaaEvent VAR STAFTest/timeout=100 VAR STAFTest/No=No',
          [ STAFRC.Ok ], r'^$'
        ],

        # Clean up in case test was interupted on a previous run
        [ 'STD:SEM', 'SEM', 'RELEASE MUTEX STAFTest/SEM FORCE',
          [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'DELETE MUTEX {STAFTest/mutexName}',
          [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ], r'.*'
        ],

        [ 'STD:SEM', 'SEM', 'RESET EVENT {STAFTest/eventName}',
          [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'DELETE EVENT {STAFTest/eventName}',
          [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'POST EVENT {STAFTest/eventName}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'QUERY EVENT {STAFTest/eventName}',
          [ STAFRC.Ok ], None,
          "STAFResult['state'] == 'Posted' and " +
          "STAFResult['lastPosted']['machine'] and " +
          "STAFResult['lastPosted']['handleName'] and " +
          "STAFResult['lastPosted']['handle'] and " +
          "STAFResult['lastPosted']['user'] and " +
          "STAFResult['lastPosted']['endpoint'].find('://') != -1 and " +
          "STAFResult['lastPosted']['timestamp'] and " +
          "STAFResult['lastReset']['machine'] and " +
          "STAFResult['lastReset']['handleName'] and " +
          "STAFResult['lastReset']['handle'] and " +
          "STAFResult['lastReset']['user'] and " +
          "STAFResult['lastReset']['endpoint'].find('://') != -1 and " +
          "STAFResult['lastReset']['timestamp'] and " +
          "len(STAFResult['waiterList']) == 0"
        ],

        [ 'STD:SEM', 'SEM', 'RESET EVENT {STAFTest/eventName}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'QUERY EVENT {STAFTest/eventName}',
          [ STAFRC.Ok ], None,
          "STAFResult['state'] == 'Reset' and " +
          "STAFResult['lastPosted']['machine'] and " +
          "STAFResult['lastPosted']['handleName'] and " +
          "STAFResult['lastPosted']['handle'] and " +
          "STAFResult['lastPosted']['user'] and " +
          "STAFResult['lastPosted']['endpoint'].find('://') != -1 and " +
          "STAFResult['lastPosted']['timestamp'] and " +
          "STAFResult['lastReset']['machine'] and " +
          "STAFResult['lastReset']['handleName'] and " +
          "STAFResult['lastReset']['handle'] and " +
          "STAFResult['lastReset']['user'] and " +
          "STAFResult['lastReset']['endpoint'].find('://') != -1 and " +
          "STAFResult['lastReset']['timestamp'] and " +
          "len(STAFResult['waiterList']) == 0"
        ],

        [ 'STD:SEM', 'SEM', 'PULSE EVENT {STAFTest/eventName}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'QUERY EVENT {STAFTest/eventName}',
          [ STAFRC.Ok ], None,
          "STAFResult['state'] == 'Reset' and " +
          "STAFResult['lastPosted']['machine'] and " +
          "STAFResult['lastPosted']['handleName'] and " +
          "STAFResult['lastPosted']['handle'] and " +
          "STAFResult['lastPosted']['user'] and " +
          "STAFResult['lastPosted']['endpoint'].find('://') != -1 and " +
          "STAFResult['lastPosted']['timestamp'] and " +
          "STAFResult['lastReset']['machine'] and " +
          "STAFResult['lastReset']['handleName'] and " +
          "STAFResult['lastReset']['handle'] and " +
          "STAFResult['lastReset']['user'] and " +
          "STAFResult['lastReset']['endpoint'].find('://') != -1 and " +
          "STAFResult['lastReset']['timestamp'] and " +
          "len(STAFResult['waiterList']) == 0"
        ],

        [ 'STD:SEM', 'SEM', 'LIST EVENT',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['name'] == 'aaaEvent' and " +
          "STAFResult[0]['state'] == 'Reset' and " +
          "STAFResult[0]['waiters'] == '0'"
        ],

        [ 'STD:SEM', 'SEM', 'WAIT EVENT {STAFTest/eventName} TIMEOUT {STAFTest/timeout}',
          [ STAFRC.Timeout ], None
        ],

        [ 'STD:SEM', 'SEM', 'POST EVENT {STAFTest/eventName}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'LIST EVENT',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['name'] == 'aaaEvent' and " +
          "STAFResult[0]['state'] == 'Posted' and " +
          "STAFResult[0]['waiters'] == '0'"
        ],

        [ 'STD:SEM', 'SEM', 'DELETE EVENT {STAFTest/eventName}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'QUERY EVENT {STAFTest/eventName}',
          [ STAFRC.SemaphoreDoesNotExist ], None
        ],
        
        # Test valid WAIT values and timeouts

        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT 0000000000000000000000',
          [ STAFRC.Timeout ], None
        ],
        
        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT 0s',
          [ STAFRC.Timeout ], None
        ],
        
        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT 0d',
          [ STAFRC.Timeout ], None
        ],
        
        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT 00h',
          [ STAFRC.Timeout ], None
        ],
        
        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT 0000000000000000000d',
          [ STAFRC.Timeout ], None
        ],
        
        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT 0w',
          [ STAFRC.Timeout ], None
        ],

        # Test invalid variable in Event TIMEOUT value
        
        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT {DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], None
        ],
        
        # Test invalid WAIT value -- doesn't follow format of Number[s | m | h | d | w]

        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT x',
          [ STAFRC.InvalidValue ], None
        ],
        
        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT 1y',
          [ STAFRC.InvalidValue ], None
        ],

       # Test invalid WAIT values -- too large

        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT 9999999999999999999999',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:SEM', 'SEM', 'WAIT EVENT STAFTest/TestEvent TIMEOUT 9999999w',
          [ STAFRC.InvalidValue ], None
        ],
        
        [ 'STD:SEM', 'SEM', 'DELETE EVENT STAFTest/TestEvent',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'REQUEST MUTEX {STAFTest/mutexName} TIMEOUT {STAFTest/timeout}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'QUERY MUTEX {STAFTest/mutexName}',
          [ STAFRC.Ok ],  None,
          "STAFResult['state'] == 'Owned' and " +
          "STAFResult['owner'] and " +
          "STAFResult['owner']['machine'] and " +
          "STAFResult['owner']['handle'] and " +
          "STAFResult['owner']['handleName'] and " +
          "STAFResult['owner']['user'] and " +
          "STAFResult['owner']['endpoint'].find('://') != -1 and " +
          "STAFResult['owner']['requestTimestamp'] and " +
          "STAFResult['owner']['acquireTimestamp'] and " +
          "STAFResult['owner'].has_key('gc') and STAFResult['owner']['gc'] == 'Yes' and " +
          "len(STAFResult['requestList']) == 0"
        ],

        [ 'STD:SEM', 'SEM', 'LIST MUTEX',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'aaaMutex' and " +
          "STAFResult[0]['state'] == 'Owned' and " +
          "STAFResult[0]['pendingRequests'] == '0'"
        ],

        [ 'STD:SEM', 'SEM', 'RELEASE MUTEX {STAFTest/mutexName}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'QUERY MUTEX {STAFTest/mutexName}',
          [ STAFRC.Ok ],  None,
          "STAFResult['state'] == 'Unowned' and " +
          "STAFResult['owner'] == None and " +
          "len(STAFResult['requestList']) == 0"
        ],

        [ 'STD:SEM', 'SEM', 'LIST MUTEX',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'aaaMutex' and " +
          "STAFResult[0]['state'] == 'Unowned' and " +
          "STAFResult[0]['pendingRequests'] == '0'"
        ],

        # Request a mutex semaphore with no garbage collection, query it, and then release it
        [ 'STD:SEM', 'SEM', 'REQUEST MUTEX {STAFTest/mutexName} TIMEOUT 1s GARBAGECOLLECT {STAFTest/No}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'QUERY MUTEX {STAFTest/mutexName}',
          [ STAFRC.Ok ],  None,
          "STAFResult['state'] == 'Owned' and " +
          "STAFResult['owner'] and " +
          "STAFResult['owner']['machine'] and " +
          "STAFResult['owner']['handle'] and " +
          "STAFResult['owner']['handleName'] and " +
          "STAFResult['owner']['user'] and " +
          "STAFResult['owner']['endpoint'].find('://') != -1 and " +
          "STAFResult['owner']['requestTimestamp'] and " +
          "STAFResult['owner']['acquireTimestamp'] and " +
          "STAFResult['owner'].has_key('gc') and STAFResult['owner']['gc'] == 'No' and " +
          "len(STAFResult['requestList']) == 0"
        ],

        [ 'STD:SEM', 'SEM', 'RELEASE MUTEX {STAFTest/mutexName}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'QUERY MUTEX STAFTest/NOEXISTSEM',
          [ STAFRC.SemaphoreDoesNotExist ], None
        ],

        # Test for expected errors on a CANCEL request

        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX DoesNotExist',
          [ STAFRC.SemaphoreDoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE HANDLE 0',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE HANDLE X0001',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE HANDLE 9999999999',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE HANDLE {DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE HANDLE 99999',
          [ STAFRC.DoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE HANDLE 1 NAME MyHandle',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} HANDLE 1',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} NAME MyHandle',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} MACHINE local://local',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE NAME {DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE NAME DoesNotExist',
          [ STAFRC.DoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE MACHINE {DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE MACHINE DoesNotExist FIRST',
          [ STAFRC.DoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE FIRST',
          [ STAFRC.DoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE LAST',
          [ STAFRC.DoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName}',
          [ STAFRC.DoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FORCE',
          [ STAFRC.DoesNotExist ], r'.*'
        ],
        [ 'STD:SEM', 'SEM', 'CANCEL MUTEX {STAFTest/mutexName} FIRST LAST',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],


        [ 'STD:SEM', 'SEM', 'DELETE MUTEX {STAFTest/mutexName}',
          [ STAFRC.Ok ], r'.*'
        ],

        [ 'STD:SEM', 'SEM', 'QUERY MUTEX {STAFTest/mutexName}',
          [ STAFRC.SemaphoreDoesNotExist ], r'.*'
        ],

        [ 'STD:SEM', 'VAR', 'DELETE VAR STAFTest/mutexName VAR STAFTest/eventName VAR STAFTest/timeout VAR STAFTest/No',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:SEM', 'SEM', 'RELEASE MUTEX STAFTest/SEM',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>SEMTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitLIFECYCLETests - This function initializes all the LIFECYCLE test information      -->
  <!-- ========================================================================== -->

  <function name="InitLIFECYCLETests" scope="local">
    <sequence>

      <script>

      LIFECYCLETests = [

        #
        #LIFECYCLE tests
        #

        [ 'STD:LIFECYCLE', 'SEM', 'REQUEST MUTEX STAFTest/LIFECYCLE', [ STAFRC.Ok ], r'^$' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'HELP', [ STAFRC.Ok ], r'^.' ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        # Unregister ids in case left over from a previous run
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 1', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 2', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 3', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 4', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 5', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 6', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],

        [ 'STD:LIFECYCLE', 'VAR', 'SET VAR STAFTest/LifeCycle/ID=1 VAR STAFTest/LifeCycle/phase=StartUp VAR STAFTest/LifeCycle/priority=25',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'REGISTER PHASE {STAFTest/LifeCycle/phase} MACHINE local SERVICE MISC REQUEST WHOAMI', [ STAFRC.Ok ], '1' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'QUERY ID {STAFTest/LifeCycle/ID}', 
          [ STAFRC.Ok ],  None,
          "STAFResult['phase'] == 'Startup' and " +
          "STAFResult['priority'] == '50' and " +
          "STAFResult['state'] == 'Enabled' and " +
          "STAFResult['machine'] == 'local' and " +
          "STAFResult['service'] == 'MISC' and " +
          "STAFResult['request'] == 'WHOAMI' and " +
          "STAFResult['description'] == None and " +
          "STAFResult['once'] == 'False'"
        ],

        # Verify that specifying invalid values for the ID on a QUERY request returns errors
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'QUERY ID X', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'QUERY ID 0', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'QUERY ID 4294967296', [ STAFRC.InvalidValue ], r'^.' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['phase'] == 'Startup' and " +
          "STAFResult[0]['priority'] == '50' and " +
          "STAFResult[0]['id'] == '1' and " +
          "STAFResult[0]['state'] == 'Enabled' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'WHOAMI' and " +
          "STAFResult[0]['once'] == 'False'"
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST PHASE {STAFTest/LifeCycle/phase}', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['phase'] == 'Startup' and " +
          "STAFResult[0]['priority'] == '50' and " +
          "STAFResult[0]['id'] == '1' and " +
          "STAFResult[0]['state'] == 'Enabled' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'WHOAMI' and " +
          "STAFResult[0]['once'] == 'False'"
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST PHASE Shutdown', 
          [ STAFRC.Ok ],  None, "len(STAFResult) == 0" ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST LONG', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['phase'] == 'Startup' and " +
          "STAFResult[0]['priority'] == '50' and " +
          "STAFResult[0]['id'] == '1' and " +
          "STAFResult[0]['state'] == 'Enabled' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'WHOAMI' and " +
          "STAFResult[0]['description'] == None and " +
          "STAFResult[0]['once'] == 'False'"
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UPDATE ID {STAFTest/LifeCycle/ID} PRIORITY {STAFTest/LifeCycle/priority} DESCRIPTION "Get WhoAmI Info"', [ STAFRC.Ok ], r'^$' ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'QUERY ID 1', 
          [ STAFRC.Ok ],  None,
          "STAFResult['phase'] == 'Startup' and " +
          "STAFResult['priority'] == '25' and " +
          "STAFResult['state'] == 'Enabled' and " +
          "STAFResult['machine'] == 'local' and " +
          "STAFResult['service'] == 'MISC' and " +
          "STAFResult['request'] == 'WHOAMI' and " +
          "STAFResult['description'] == 'Get WhoAmI Info' and " +
          "STAFResult['once'] == 'False'"
        ],
        
        # Verify that specifying invalid values for the ID option on an UPDATE request returns errors
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UPDATE ID X PRIORITY 5', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UPDATE ID 0 PRIORITY 5', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UPDATE ID 4294967296 PRIORITY 5', [ STAFRC.InvalidValue ], r'^.' ],
        
        # Verify that specifying invalid values for the PRIORITY option on an UPDATE request returns errors
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UPDATE ID 1 PRIORITY xyz', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UPDATE ID 1 PRIORITY 0', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UPDATE ID 1 PRIORITY 101', [ STAFRC.InvalidValue ], r'^.' ],

        # Verify that specifying invalid values for the ONCE option on an UPDATE request returns errors
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UPDATE ID 1 ONCE xyz', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UPDATE ID 1 ONCE', [ STAFRC.InvalidRequestString ], r'^.' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST PHASE STARTUP LONG', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['phase'] == 'Startup' and " +
          "STAFResult[0]['priority'] == '25' and " +
          "STAFResult[0]['id'] == '1' and " +
          "STAFResult[0]['state'] == 'Enabled' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'WHOAMI' and " +
          "STAFResult[0]['description'] == 'Get WhoAmI Info' and " +
          "STAFResult[0]['once'] == 'False'"
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER ID {STAFTest/LifeCycle/ID} CONFIRM', 
          [ STAFRC.Ok ],  None,
          "STAFResult['machine'] == 'local' and " +
          "STAFResult['service'] == 'MISC' and " +
          "STAFResult['request'] == 'WHOAMI' and " +
          "STAFResult['rc'] == '0' and " +
          "STAFResult['result'] != None"
          # XXX: Need to unmarshall STAFResult['result'] before can check it
          #STAFResult['result'].has_key('interface') and STAFResult['result']['interface'] == 'local'"
        ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER PHASE {STAFTest/LifeCycle/phase} CONFIRM', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['id'] == '1' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'WHOAMI' and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result']"
          # XXX: Need to unmarshall STAFResult[0]['result'] before can check it
          #"STAFResult[0]['result'].has_key('interface') and STAFResult[0]['result']['interface'] == 'local'"
        ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER PHASE XYZ CONFIRM', 
          [ STAFRC.InvalidValue ],  r'^.'  ],

        # Verify that specifying invalid values for the ID option on a TRIGGER request returns errors
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER ID X CONFIRM', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER ID 0 CONFIRM', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER ID 4294967296 CONFIRM', [ STAFRC.InvalidValue ], r'^.' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'DISABLE ID {STAFTest/LifeCycle/ID}', [ STAFRC.Ok ], '' ],

         # Verify that specifying invalid values for the ID option on a DISABLE request returns errors
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'DISABLE ID X', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'DISABLE ID 0', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'DISABLE ID 4294967296', [ STAFRC.InvalidValue ], r'^.' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'DISABLE ID 50', [ STAFRC.DoesNotExist ], '' ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'QUERY ID 1', 
          [ STAFRC.Ok ],  None,
          "STAFResult['phase'] == 'Startup' and " +
          "STAFResult['priority'] == '25' and " +
          "STAFResult['state'] == 'Disabled' and " +
          "STAFResult['machine'] == 'local' and " +
          "STAFResult['service'] == 'MISC' and " +
          "STAFResult['request'] == 'WHOAMI' and " +
          "STAFResult['description'] == 'Get WhoAmI Info' and " +
          "STAFResult['once'] == 'False'"
        ],
       
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER ID 1 CONFIRM', 
          [ STAFRC.Ok ],  None,
          "STAFResult['machine'] == 'local' and " +
          "STAFResult['service'] == 'MISC' and " +
          "STAFResult['request'] == 'WHOAMI' and " +
          "STAFResult['rc'] == '0' and " +
          "STAFResult['result'] != None"
          # Need to unmarshall STAFResult['result'] before can check it
          #"STAFResult['result'].has_key('interface') and STAFResult['result']['interface'] == 'local'"
        ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER PHASE Startup CONFIRM', 
          [ STAFRC.Ok ],  None, "len(STAFResult) == 0" ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER PHASE Shutdown CONFIRM', 
          [ STAFRC.Ok ],  None, "len(STAFResult) == 0" ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'ENABLE ID {STAFTest/LifeCycle/ID}', [ STAFRC.Ok ], r'^$' ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'QUERY ID 1', 
          [ STAFRC.Ok ],  None,
          "STAFResult['phase'] == 'Startup' and " +
          "STAFResult['priority'] == '25' and " +
          "STAFResult['state'] == 'Enabled' and " +
          "STAFResult['machine'] == 'local' and " +
          "STAFResult['service'] == 'MISC' and " +
          "STAFResult['request'] == 'WHOAMI' and " +
          "STAFResult['description'] == 'Get WhoAmI Info' and " +
          "STAFResult['once'] == 'False'"
        ],
        
        # Verify that specifying invalid values for the ID option on an ENABLE request returns errors
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'ENABLE ID X', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'ENABLE ID 0', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'ENABLE ID 4294967296', [ STAFRC.InvalidValue ], r'^.' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'ENABLE ID 50', [ STAFRC.DoesNotExist ], '' ],

        [ 'STD:LIFECYCLE', 'VAR', 'SET VAR STAFTest/LifeCycle/priority=10',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'REGISTER PHASE STARTUp MACHINE local SERVICE MISC REQUEST VERSION PRIORITY {STAFTest/LifeCycle/priority} DESCRIPTION "Get STAF Version"',
          [ STAFRC.Ok ], '2' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'QUERY ID 2', 
          [ STAFRC.Ok ],  None,
          "STAFResult['phase'] == 'Startup' and " +
          "STAFResult['priority'] == '10' and " +
          "STAFResult['state'] == 'Enabled' and " +
          "STAFResult['machine'] == 'local' and " +
          "STAFResult['service'] == 'MISC' and " +
          "STAFResult['request'] == 'VERSION' and " +
          "STAFResult['description'] == 'Get STAF Version' and " +
          "STAFResult['once'] == 'False'"
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST PHASE Startup LONG', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['phase'] == 'Startup' and " +
          "STAFResult[0]['priority'] == '10' and " +
          "STAFResult[0]['id'] == '2' and " +
          "STAFResult[0]['state'] == 'Enabled' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'VERSION' and " +
          "STAFResult[0]['description'] == 'Get STAF Version' and " + 
          "STAFResult[1]['phase'] == 'Startup' and " +
          "STAFResult[1]['priority'] == '25' and " +
          "STAFResult[1]['id'] == '1' and " +
          "STAFResult[1]['state'] == 'Enabled' and " +
          "STAFResult[1]['machine'] == 'local' and " +
          "STAFResult[1]['service'] == 'MISC' and " +
          "STAFResult[1]['request'] == 'WHOAMI' and " +
          "STAFResult[1]['description'] == 'Get WhoAmI Info' and " +
          "STAFResult[1]['once'] == 'False'"
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'REGISTER PHASE SHUTDown MACHINE local SERVICE VAR REQUEST "RESOLVE STRING {STAF/Config/Machine}" DESCRIPTION "Get STAF/Config/Machine"',
          [ STAFRC.Ok ], '3' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST LONG', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0]['phase'] == 'Startup' and " +
          "STAFResult[0]['priority'] == '10' and " +
          "STAFResult[0]['id'] == '2' and " +
          "STAFResult[0]['state'] == 'Enabled' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'VERSION' and " +
          "STAFResult[0]['description'] == 'Get STAF Version' and " + 
          "STAFResult[0]['once'] == 'False' and " +
          "STAFResult[1]['phase'] == 'Startup' and " +
          "STAFResult[1]['priority'] == '25' and " +
          "STAFResult[1]['id'] == '1' and " +
          "STAFResult[1]['state'] == 'Enabled' and " +
          "STAFResult[1]['machine'] == 'local' and " +
          "STAFResult[1]['service'] == 'MISC' and " +
          "STAFResult[1]['request'] == 'WHOAMI' and " +
          "STAFResult[1]['description'] == 'Get WhoAmI Info' and " +
          "STAFResult[1]['once'] == 'False' and " +
          "STAFResult[2]['phase'] == 'Shutdown' and " +
          "STAFResult[2]['priority'] == '50' and " +
          "STAFResult[2]['id'] == '3' and " +
          "STAFResult[2]['state'] == 'Enabled' and " +
          "STAFResult[2]['machine'] == 'local' and " +
          "STAFResult[2]['service'] == 'VAR' and " +
          "STAFResult[2]['request'] == 'RESOLVE STRING {STAF/Config/Machine}' and " +
          "STAFResult[2]['description'] == 'Get STAF/Config/Machine' and " +
          "STAFResult[2]['once'] == 'False'"
        ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST PHASE SHUTDOWN LONG', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['phase'] == 'Shutdown' and " +
          "STAFResult[0]['priority'] == '50' and " +
          "STAFResult[0]['id'] == '3' and " +
          "STAFResult[0]['state'] == 'Enabled' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'VAR' and " +
          "STAFResult[0]['request'] == 'RESOLVE STRING {STAF/Config/Machine}' and " +
          "STAFResult[0]['description'] == 'Get STAF/Config/Machine' and " +
          "STAFResult[0]['once'] == 'False'"
        ],
        
        # Verify that specifying invalid values for the ID option on an UNREGISTER request returns errors
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID X', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 0', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 4294967296', [ STAFRC.InvalidValue ], r'^.' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 50', [ STAFRC.DoesNotExist ], '' ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 2', [ STAFRC.Ok ], '' ],

        # Verify that if a register request returns registration ID 4, and then you unregister ID 4, and then you submit another register request, it will reuse registration ID 4.
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'REGISTER PHASE startup MACHINE local SERVICE MISC REQUEST "QUERY INTERFACE local"',
          [ STAFRC.Ok ], '4' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 4', [ STAFRC.Ok ], '' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'REGISTER PHASE startup MACHINE local SERVICE MISC REQUEST VERSION PRIORITY 5 DESCRIPTION "Get STAF Version"',
          [ STAFRC.Ok ], '4' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'REGISTER PHASE SHUTDown MACHINE local SERVICE VAR REQUEST "RESOLVE STRING {STAF/Config/Machine}" DESCRIPTION "Get STAF/Config/Machine"',
          [ STAFRC.Ok ], '5' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'REGISTER PHASE SHUTDown MACHINE local SERVICE MISC REQUEST "QUERY INTERFACE local" PRIORITY 35 ONCE',
          [ STAFRC.Ok ], '6' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 5', [ STAFRC.Ok ], '' ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST LONG', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 4 and " +

          "STAFResult[0]['phase'] == 'Startup' and " +
          "STAFResult[0]['priority'] == '5' and " +
          "STAFResult[0]['id'] == '4' and " +
          "STAFResult[0]['state'] == 'Enabled' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'VERSION' and " +
          "STAFResult[0]['description'] == 'Get STAF Version' and " + 
          "STAFResult[0]['once'] == 'False' and " +

          "STAFResult[1]['phase'] == 'Startup' and " +
          "STAFResult[1]['priority'] == '25' and " +
          "STAFResult[1]['id'] == '1' and " +
          "STAFResult[1]['state'] == 'Enabled' and " +
          "STAFResult[1]['machine'] == 'local' and " +
          "STAFResult[1]['service'] == 'MISC' and " +
          "STAFResult[1]['request'] == 'WHOAMI' and " +
          "STAFResult[1]['description'] == 'Get WhoAmI Info' and " +
          "STAFResult[1]['once'] == 'False' and " +

          "STAFResult[2]['phase'] == 'Shutdown' and " +
          "STAFResult[2]['priority'] == '35' and " +
          "STAFResult[2]['id'] == '6' and " +
          "STAFResult[2]['state'] == 'Enabled' and " +
          "STAFResult[2]['machine'] == 'local' and " +
          "STAFResult[2]['service'] == 'MISC' and " +
          "STAFResult[2]['request'] == 'QUERY INTERFACE local' and " +
          "STAFResult[2]['description'] == None and " + 
          "STAFResult[2]['once'] == 'True' and " +

          "STAFResult[3]['phase'] == 'Shutdown' and " +
          "STAFResult[3]['priority'] == '50' and " +
          "STAFResult[3]['id'] == '3' and " +
          "STAFResult[3]['state'] == 'Enabled' and " +
          "STAFResult[3]['machine'] == 'local' and " +
          "STAFResult[3]['service'] == 'VAR' and " +
          "STAFResult[3]['request'] == 'RESOLVE STRING {STAF/Config/Machine}' and " +
          "STAFResult[3]['description'] == 'Get STAF/Config/Machine' and " +
          "STAFResult[3]['once'] == 'False'"
        ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER PHASE Startup CONFIRM', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['id'] == '4' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'VERSION' and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] and " +

          "STAFResult[1]['id'] == '1' and " +
          "STAFResult[1]['machine'] == 'local' and " +
          "STAFResult[1]['service'] == 'MISC' and " +
          "STAFResult[1]['request'] == 'WHOAMI' and " +
          "STAFResult[1]['rc'] == '0' and " +
          "STAFResult[1]['result']"
          # XXX: Need to unmarshall STAFResult[0]['result'] before can check it
          #"STAFResult[1]['result'].has_key('interface') and STAFResult[0]['result']['interface'] == 'local'"
        ],
        
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'TRIGGER PHASE Shutdown CONFIRM', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['id'] == '6' and " +
          "STAFResult[0]['machine'] == 'local' and " +
          "STAFResult[0]['service'] == 'MISC' and " +
          "STAFResult[0]['request'] == 'QUERY INTERFACE local' and " +
          "STAFResult[0]['rc'] == '0' and " +
          "STAFResult[0]['result'] and " +
          "STAFResult[1]['id'] == '3' and " +
          "STAFResult[1]['machine'] == 'local' and " +
          "STAFResult[1]['service'] == 'VAR' and " +
          "STAFResult[1]['request'] == 'RESOLVE STRING {STAF/Config/Machine}' and " +
          "STAFResult[1]['rc'] == '0' and " +
          "STAFResult[1]['result']"
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID {STAFTest/LifeCycle/ID}', [ STAFRC.Ok ], '' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 3', [ STAFRC.Ok ], '' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 4', [ STAFRC.Ok ], '' ],
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 6', [ STAFRC.Ok ], '' ],

        # Test that when all IDs have been unregistered, ID 1 is reused
        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'REGISTER PHASE SHUTDown MACHINE local SERVICE PROCESS REQUEST "START SHELL COMMAND STAF USERNAME User1 PASSWORD !!@secret@!!" PRIORITY 99',
          [ STAFRC.Ok ], '1' ],

        # Test that private data specified in a request is masked when queried/listed.

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'QUERY ID 1', 
          [ STAFRC.Ok ],  None,
          "STAFResult['request'] == 'START SHELL COMMAND STAF USERNAME User1 PASSWORD ************'"
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'LIST LONG', 
          [ STAFRC.Ok ],  None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['request'] == 'START SHELL COMMAND STAF USERNAME User1 PASSWORD ************'"
        ],

        [ 'STD:LIFECYCLE', 'LIFECYCLE', 'UNREGISTER ID 1', [ STAFRC.Ok ], '' ],

        [ 'STD:LIFECYCLE', 'VAR', 'DELETE VAR STAFTest/LifeCycle/ID VAR STAFTest/LifeCycle/phase VAR STAFTest/LifeCycle/priority',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LIFECYCLE', 'SEM', 'RELEASE MUTEX STAFTest/LIFECYCLE', [ STAFRC.Ok ], r'^$' ]

      ]

      </script>

      <return>LIFECYCLETests</return>

    </sequence>
  </function>
  
  <!-- =============================================================================== -->
  <!-- InitCONFIGTests - This function initializes the CONFIG service test information -->
  <!-- =============================================================================== -->

  <function name="InitCONFIGTests" scope="local">
    <sequence>

      <script>

      CONFIGTests = [

        #
        #CONFIG service tests
        #

        [ 'STD:CONFIG', 'SEM', 'REQUEST MUTEX STAFTest/CONFIG', [ STAFRC.Ok ], r'^$' ],

        [ 'STD:CONFIG', 'CONFIG', 'HELP', [ STAFRC.Ok ], r'^.' ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:CONFIG', 'CONFIG', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:CONFIG', 'CONFIG', 'SAVE', [ STAFRC.Ok ], r'^.' ],

        # Test using the VARS option
        [ 'STD:CONFIG', 'VAR', 'SET VAR STAFTest/Config/Vars=Startup', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:CONFIG', 'CONFIG', 'SAVE VARS Current', [ STAFRC.Ok ], r'^.' ],
        [ 'STD:CONFIG', 'CONFIG', 'SAVE VARS {STAFTest/Config/Vars}', [ STAFRC.Ok ], r'^.' ],
        [ 'STD:CONFIG', 'CONFIG', 'SAVE VARS Invalid', [ STAFRC.InvalidValue ], r'^.' ],
        [ 'STD:CONFIG', 'CONFIG', 'SAVE VARS', [ STAFRC.InvalidRequestString ], r'^.' ],

        # Test using the FILE option
        [ 'STD:CONFIG', 'FS', 'DELETE ENTRY "{STAF/DataDir}/tmp/STAF.cfg" CONFIRM', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],
        [ 'STD:CONFIG', 'CONFIG', 'SAVE FILE "{STAF/DataDir}/tmp/STAF.cfg"', [ STAFRC.Ok ], '' ],
        [ 'STD:CONFIG', 'CONFIG', 'SAVE FILE "{STAF/DataDir}/tmp/STAF.cfg"', [ STAFRC.AlreadyExists ], r'^.' ],

        [ 'STD:CONFIG', 'VAR', 'DELETE VAR STAFTest/Config/Vars', [ STAFRC.Ok ], r'^$' ],

        [ 'STD:CONFIG', 'SEM', 'RELEASE MUTEX STAFTest/CONFIG', [ STAFRC.Ok ], r'^$' ]

      ]

      </script>

      <return>CONFIGTests</return>

    </sequence>
  </function>

  <!-- ========================================================================== -->
  <!-- InitLOGTests - This function initializes all the LOG test information      -->
  <!-- ========================================================================== -->

  <function name="InitLOGTests" scope="local">
    <sequence>

      <script>

      LOGTests = [

        #
        #LOG tests
        #

        [ 'STD:LOG', 'SEM', 'REQUEST MUTEX STAFTest/LOG', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:LOG', LogService, 'HELP', [ STAFRC.Ok ], r'^.' ],
        [ 'STD:LOG', LogService, 'VERSION', [ STAFRC.Ok ], r'^.' ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:LOG', 'LOG', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        # Global Log Tests

        [ 'STD:LOG', LogService, 'DELETE GLOBAL LOGNAME staftest CONFIRM',
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:LOG', 'VAR', 'SET VAR "STAFTest/LogMsg=This message had to be resolved" VAR STAFTest/LogName=staftest VAR STAFTest/LogLevel=Info',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/LogMask=11111111111111111111111111111111 VAR STAFTest/LogFirst=5 VAR STAFTest/LogLast=3 VAR STAFTest/HName=STAX/Job/%s' % (STAXJobID),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/LogHandle=%s VAR STAFTest/STAXMachine=%s' % (JobHandle, STAXMachine),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG GLOBAL LOGNAME staftest LEVEL info MESSAGE {STAFTest/LogMsg} RESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG GLOBAL LOGNAME {STAFTest/LogName} LEVEL {STAFTest/LogLevel} MESSAGE "On Monday, testing should begin" NORESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG GLOBAL LOGNAME staftest LEVEL info MESSAGE "Testing should end by Tuesday"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LIST GLOBAL',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and STAFResult[0]['logName'] != '' and " +
          "STAFResult[0]['timestamp'] != '' and STAFResult[0]['size'] > 0"
        ],

        # The default maximum query records is 100
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest',
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 3 and len(STAFResult) &lt;= 100"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest ALL',
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 3"
        ],

        [ 'STD:LOG', 'VAR', 'SET VAR "STAFTest/LogStartsWith=On Monday"', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/LogContains=Monday', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest LAST {STAFTest/LogLast}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0]['level'] == 'Info' and STAFResult[0]['message'] == 'This message had to be resolved' and " +
          "STAFResult[1]['level'] == 'Info' and STAFResult[1]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[2]['level'] == 'Info' and STAFResult[2]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/LogFromRecord=2', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/LogToRecord=3', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROMRECORD 2 TORECORD 3',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2"
        ],
        
        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/LogFromRecord=2', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/LogToRecord=3', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROMRECORD 2 TORECORD 3 LAST 1',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1"
        ],
        
        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/LogFromRecord=2', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/LogToRecord=3', [ STAFRC.Ok ], r'^$' ],
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROMRECORD 2 TORECORD 3 FIRST 1',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROMRECORD -1 TORECORD 3',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROMRECORD 1 TORECORD xxx',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROMRECORD 3 TORECORD 2',
          [ STAFRC.InvalidValue ], None
        ],
        
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROMRECORD 1 TORECORD 9999999999',
          [ STAFRC.InvalidValue ], None
        ],
        
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROMRECORD 4294967296 TORECORD 1',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest CONTAINS {STAFTest/LogContains} CONTAINS TUESDAY FIRST 2 LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['timestamp'] and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[0]['level'] == 'Info' and " +
          "STAFResult[0]['machine'] == '%s' and " % (STAXMachine) +
          "STAFResult[0]['handle'] == '%s' and "  % (JobHandle) +
          "STAFResult[0]['handleName'] == 'STAX/Job/%s' and " % (STAXJobID) +
          "STAFResult[0]['user'] == 'none://anonymous' and " +
          "STAFResult[0]['endpoint'].find('://') != -1 and " +
          "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest CSCONTAINS {STAFTest/LogContains} CSCONTAINS TUESDAY FIRST 2 LEVELBITSTRING',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest STARTSWITH {STAFTest/LogStartsWith} STARTSWITH TESTING FIRST 2 LEVELBITSTRING',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest CSSTARTSWITH {STAFTest/LogStartsWith} CSSTARTSWITH TESTING FIRST 2 LEVELBITSTRING',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        # Mix use of STARTSWITH and CSSTARTSWITH
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest STARTSWITH {STAFTest/LogStartsWith} CSSTARTSWITH Testing FIRST 2 LEVELBITSTRING',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest STARTSWITH {STAFTest/LogStartsWith} CSSTARTSWITH TESTING FIRST 2 LEVELBITSTRING',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/User=none://anonymous VAR STAFTest/Endpoint=tcp://%s@6500' % (STAXMachine),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest USER {STAFTest/User} STARTSWITH {STAFTest/LogStartsWith}  FIRST 2',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest ENDPOINT {STAFTest/Endpoint} LAST 2',
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 0 and len(STAFResult) &lt; 3"
        ],

        [ 'STD:LOG', 'VAR', 'DELETE VAR STAFTest/User VAR STAFTest/Endpoint',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME {STAFTest/LogName} NAME {STAFTest/HName} total',
          [ STAFRC.Ok ],
          r"""(?mx)
              ^3\s*"""
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest LEVELMASK {STAFTest/LogMask} STATS',
          [ STAFRC.Ok ], None,
          "STAFResult['info'] == '3' and " +
          "STAFResult['fatal'] == '0' and STAFResult['error'] == '0' and " +
          "STAFResult['warning'] == '0' and STAFResult['trace'] == '0' and " +
          "STAFResult['trace2'] == '0' and STAFResult['trace3'] == '0' and " +
          "STAFResult['debug'] == '0' and STAFResult['debug2'] == '0' and " +
          "STAFResult['debug3'] == '0' and STAFResult['start'] == '0' and " +
          "STAFResult['stop'] == '0' and STAFResult['pass'] == '0' and " +
          "STAFResult['fail'] == '0' and STAFResult['status'] == '0' and " +
          "STAFResult['user1'] == '0' and STAFResult['user2'] == '0' and " +
          "STAFResult['user3'] == '0' and STAFResult['user4'] == '0' and " +
          "STAFResult['user4'] == '0' and STAFResult['user6'] == '0' and " +
          "STAFResult['user7'] == '0' and STAFResult['user8'] == '0'"
        ],

        [ 'STD:LOG', 'VAR', 'SET VAR STAFTest/Today=TODAY',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROM %s@%s TO TODAY@23:59:59 FIRST {STAFTest/LogFirst}' % (TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROM %s@%s TO TODAY@23:59:59 FIRST 5' % (TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROM %s TO {STAFTest/Today}@23:59:59 FIRST 5' % (TestMachJobStartDate),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest AFTER %s@%s FIRST 5' % (TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest BEFORE {STAFTest/Today}@23:59:59 FIRST 5',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest LAST 10',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FIRST 10badNumber',
          [ STAFRC.InvalidValue ], None ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FIRST 9999999999',
          [ STAFRC.InvalidValue ], None ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest LAST 9999999999',
          [ STAFRC.InvalidValue ], None ],
        
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest LAST -1',
          [ STAFRC.InvalidValue ], None ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROM 2003badDate',
          [ STAFRC.InvalidValue ], None ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest FROM TODAY@01:61:badtime',
          [ STAFRC.InvalidValue ], None ],

        [ 'STD:LOG', LogService, 'LOG GLOBAL LOGNAME staftest LEVEL 00000000000000000000000000000001 MESSAGE :33:Testcase aborted with error "255"',
          [ STAFRC.Ok ], r'^$' ],

        [ 'STD:LOG', LogService, 'LOG GLOBAL LOGNAME staftest LEVEL 00000000000000000000000010000000 MESSAGE Recovered',
          [ STAFRC.Ok ], r'^$' ],

        [ 'STD:LOG', LogService, 'LOG GLOBAL LOGNAME staftest LEVEL start MESSAGE "Step1 in Test1 initiated"',
          [ STAFRC.Ok ], r'^$' ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest LEVELMASK "TRACE TRACE2 DEBUG DEBUG2"',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest QMACHINE {STAFTest/STAXMachine} QHANDLE {STAFTest/LogHandle}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],
        
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest QMACHINE {STAFTest/STAXMachine} QHANDLE 0',
          [ STAFRC.InvalidValue ], None,
        ],
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest QMACHINE {STAFTest/STAXMachine} QHANDLE 9999999999',
          [ STAFRC.InvalidValue ], None,
        ],

        [ 'STD:LOG', LogService, 'ASK GLOBAL LOGNAME staftest LAST 1',
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:LOG', LogService, 'PURGE GLOBAL LOGNAME staftest CONFIRM',
          [ 4008 ], None ],

        [ 'STD:LOG', LogService, 'PURGE GLOBAL LOGNAME {STAFTest/LogName} CONTAINS {STAFTest/LogContains} STARTSWITH {STAFTest/LogStartsWith} AFTER %s@%s FIRST 1 CONFIRM' % (TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1' and STAFResult['totalRecords']"
        ],

        [ 'STD:LOG', LogService, 'PURGE GLOBAL LOGNAME {STAFTest/LogName} CSCONTAINS Tuesday CSSTARTSWITH Testing BEFORE TODAY@23:59:59 LAST 1 CONFIRM',
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],

        [ 'STD:LOG', LogService, 'PURGE GLOBAL LOGNAME staftest LEVELMASK "INFO DEBUG" FROM %s@%s TO TODAY@23:59:59 LAST 1 CONFIRM' % (TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],

        [ 'STD:LOG', LogService, 'PURGE GLOBAL LOGNAME staftest NAME {STAFTest/HName} QMACHINE {STAFTest/STAXMachine} QHANDLE {STAFTest/LogHandle} FIRST 1 CONFIRM',
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],

        [ 'STD:LOG', LogService, 'PURGE GLOBAL LOGNAME staftest CONFIRMALL',
          [ STAFRC.Ok ], None,
          "int(STAFResult['purgedRecords']) == int(STAFResult['totalRecords'])"
        ],

        [ 'STD:LOG', LogService, 'PURGE GLOBAL LOGNAME staftest CONFIRM',
          [ STAFRC.Ok ], None,
          "int(STAFResult['purgedRecords']) == 0 and int(STAFResult['totalRecords']) == 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest TOTAL',
          [ STAFRC.Ok], None,
          "int(STAFResult) == 0"
        ],
        
        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest',
          [ STAFRC.Ok], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:LOG', LogService, 'DELETE GLOBAL LOGNAME {STAFTest/LogName} CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'DELETE GLOBAL LOGNAME staftest CONFIRM',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest STATS',
          [ STAFRC.DoesNotExist ], None
        ],

        # Handle Log Tests

        [ 'STD:LOG', LogService, 'DELETE MACHINE %s HANDLE %s LOGNAME staftest CONFIRM' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:LOG', LogService, 'LOG HANDLE LOGNAME staftest LEVEL info MESSAGE {STAFTest/LogMsg} RESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG HANDLE LOGNAME {STAFTest/LogName} LEVEL {STAFTest/LogLevel} MESSAGE "On Monday, testing should begin"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG HANDLE LOGNAME staftest LEVEL info MESSAGE "Testing should end by Tuesday"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LIST MACHINE %s HANDLES' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'LIST MACHINE %s HANDLE {STAFTest/LogHandle}' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and STAFResult[0]['logName'] and " +
          "STAFResult[0]['timestamp'] and STAFResult[0]['size']"
        ],

        # The default maximum query records is 100
        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 3 and len(STAFResult) &lt;= 100"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest ALL' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 3"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest LAST {STAFTest/LogLast}' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0]['level'] == 'Info' and STAFResult[0]['message'] == 'This message had to be resolved' and " +
          "STAFResult[1]['level'] == 'Info' and STAFResult[1]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[2]['level'] == 'Info' and STAFResult[2]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest CONTAINS {STAFTest/LogContains} CONTAINS TUESDAY FIRST 2 LEVELBITSTRING LONG' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[0]['machine'] == '%s' and " % (STAXMachine) +
          "STAFResult[0]['endpoint'].find('://') != -1 and " +
          "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest CSCONTAINS {STAFTest/LogContains} CSCONTAINS TUESDAY FIRST 2 LEVELBITSTRING' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest STARTSWITH {STAFTest/LogStartsWith} STARTSWITH TESTING FIRST 2 LEVELBITSTRING' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest CSSTARTSWITH {STAFTest/LogStartsWith} CSSTARTSWITH TESTING FIRST 2 LEVELBITSTRING' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        # Mix use of STARTSWITH and CSSTARTSWITH
        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest STARTSWITH {STAFTest/LogStartsWith} CSSTARTSWITH Testing FIRST 2 LEVELBITSTRING' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest STARTSWITH {STAFTest/LogStartsWith} CSSTARTSWITH TESTING FIRST 2 LEVELBITSTRING' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        ['STD:LOG', 'VAR', 'SET VAR STAFTest/STAXMachineNickname=%s' % (STAXMachineNickname),
          [ STAFRC.Ok], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} HANDLE {STAFTest/LogHandle} LOGNAME {STAFTest/LogName} NAME {STAFTest/HName} total',
          [ STAFRC.Ok ],
          r"""(?mx)
              ^3\s*"""
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest LEVELMASK {STAFTest/LogMask} STATS' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['info'] == '3'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest FROM %s@%s TO TODAY@23:59:59 FIRST {STAFTest/LogFirst}' % \
                            (STAXMachineNickname, JobHandle, TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest FROM %s@%s TO TODAY@23:59:59 FIRST 5' % (STAXMachineNickname, JobHandle, TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest FROM %s TO {STAFTest/Today}@23:59:59 FIRST 5' % (STAXMachineNickname, JobHandle, TestMachJobStartDate),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest AFTER %s@%s FIRST 5' % (STAXMachineNickname, JobHandle, TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest BEFORE {STAFTest/Today}@23:59:59 FIRST 5' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest LAST 10' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest FIRST 10badNumber' % (STAXMachineNickname, JobHandle),
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest FROM 2003badDate' % (STAXMachineNickname, JobHandle),
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest FROM TODAY@01:61:badtime' % (STAXMachineNickname, JobHandle),
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:LOG', LogService, 'LOG HANDLE LOGNAME staftest LEVEL 00000000000000000000000000000001 MESSAGE :33:Testcase aborted with error "255"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG HANDLE LOGNAME staftest LEVEL 00000000000000000000000010000000 MESSAGE Recovered',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG HANDLE LOGNAME staftest LEVEL start MESSAGE "Step1 in Test1 initiated"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest LEVELMASK "TRACE TRACE2 DEBUG DEBUG2"' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest QMACHINE {STAFTest/STAXMachine} QHANDLE {STAFTest/LogHandle}' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'ASK MACHINE %s HANDLE %s LOGNAME staftest LAST 1' % (STAXMachineNickname, JobHandle),
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:LOG', LogService, 'LOG HANDLE LOGNAME staftest LEVEL 00000000000000000000000000000001 MESSAGE :33:Testcase aborted with error "255"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE %s HANDLE %s LOGNAME staftest CONFIRM' % (STAXMachineNickname, JobHandle),
          [ 4008 ], None
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE {STAFTest/STAXMachineNickname} HANDLE {STAFTest/LogHandle} LOGNAME {STAFTest/LogName} CONTAINS {STAFTest/LogContains} STARTSWITH {STAFTest/LogStartsWith} AFTER %s@%s FIRST 1 CONFIRM' % (TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE %s HANDLE %s LOGNAME {STAFTest/LogName} CSCONTAINS Tuesday CSSTARTSWITH Testing BEFORE TODAY@23:59:59 LAST 1 CONFIRM' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE %s HANDLE %s LOGNAME staftest LEVELMASK "INFO DEBUG" FROM %s@%s TO TODAY@23:59:59 LAST 1 CONFIRM' % (STAXMachineNickname, JobHandle, TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE %s HANDLE %s LOGNAME staftest NAME {STAFTest/HName} QMACHINE {STAFTest/STAXMachine} QHANDLE {STAFTest/LogHandle} FIRST 1 CONFIRM' % \
                            (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],
        
        [ 'STD:LOG', LogService, 'PURGE MACHINE %s HANDLE %s LOGNAME staftest CONFIRMALL' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "int(STAFResult['purgedRecords']) == int(STAFResult['totalRecords'])"
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE %s HANDLE %s LOGNAME staftest CONFIRM' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "int(STAFResult['purgedRecords']) == 0 and int(STAFResult['totalRecords']) == 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest TOTAL' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok], None,
          "int(STAFResult) == 0"
        ],
        
        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s  LOGNAME staftest' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:LOG', LogService, 'DELETE MACHINE {STAFTest/STAXMachineNickname} HANDLE {STAFTest/LogHandle} LOGNAME {STAFTest/LogName} CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'DELETE MACHINE %s HANDLE %s LOGNAME staftest CONFIRM' % (STAXMachineNickname, JobHandle),
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s HANDLE %s LOGNAME staftest STATS' % (STAXMachineNickname, JobHandle),
          [ STAFRC.DoesNotExist ], None
        ],

        # Machine Log Tests

        [ 'STD:LOG', LogService, 'DELETE MACHINE %s LOGNAME staftest CONFIRM' % (STAXMachineNickname),
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:LOG', LogService, 'LOG MACHINE LOGNAME staftest LEVEL info MESSAGE {STAFTest/LogMsg} RESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG MACHINE LOGNAME {STAFTest/LogName} LEVEL {STAFTest/LogLevel} MESSAGE "On Monday, testing should begin"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG MACHINE LOGNAME staftest LEVEL info MESSAGE "Testing should end by Tuesday"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LIST MACHINES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'LIST MACHINE {STAFTest/STAXMachineNickname}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and STAFResult[0]['logName'] and " +
          "STAFResult[0]['timestamp'] and STAFResult[0]['size']"
        ],

        # Test uses default maximum query records

        [ 'STD:LOG', LogService, 'SET DEFAULTMAXQUERYRECORDS 2',
          [ STAFRC.Ok ], ''
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest' % (STAXMachineNickname),
          [ 4010 ], None,
          "len(STAFResult) == 2"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest ALL' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 3"
        ],

        [ 'STD:LOG', LogService, 'SET DEFAULTMAXQUERYRECORDS 100',
          [ STAFRC.Ok ], ''
        ],

        # Test other QUERY requests

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest LAST {STAFTest/LogLast}' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0]['level'] == 'Info' and STAFResult[0]['message'] == 'This message had to be resolved' and " +
          "STAFResult[1]['level'] == 'Info' and STAFResult[1]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[2]['level'] == 'Info' and STAFResult[2]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest CONTAINS {STAFTest/LogContains} CONTAINS TUESDAY FIRST 2 LEVELBITSTRING LONG' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[0]['machine'] == '%s' and " % (STAXMachine) +
          "STAFResult[0]['endpoint'].find('://') != -1 and " +
          "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest CSCONTAINS {STAFTest/LogContains} CSCONTAINS TUESDAY FIRST 2 LEVELBITSTRING' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest STARTSWITH {STAFTest/LogStartsWith} STARTSWITH TESTING FIRST 2 LEVELBITSTRING' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest CSSTARTSWITH {STAFTest/LogStartsWith} CSSTARTSWITH TESTING FIRST 2 LEVELBITSTRING' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        # Mix use of STARTSWITH and CSSTARTSWITH
        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest STARTSWITH {STAFTest/LogStartsWith} CSSTARTSWITH Testing FIRST 2 LEVELBITSTRING' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin' and " +
          "STAFResult[1]['message'] == 'Testing should end by Tuesday'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest STARTSWITH {STAFTest/LogStartsWith} CSSTARTSWITH TESTING FIRST 2 LEVELBITSTRING' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['message'] == 'On Monday, testing should begin'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} LOGNAME {STAFTest/LogName} NAME {STAFTest/HName} total',
          [ STAFRC.Ok ],
          r"""(?mx)
              ^3\s*"""
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest LEVELMASK {STAFTest/LogMask} STATS' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "STAFResult['info'] == '3'"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest FROM %s@%s TO TODAY@23:59:59 FIRST {STAFTest/LogFirst}' % (STAXMachineNickname, TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest FROM %s@%s TO TODAY@23:59:59 FIRST 5' % (STAXMachineNickname, TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest FROM %s TO {STAFTest/Today}@23:59:59 FIRST 5' % (STAXMachineNickname, TestMachJobStartDate),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest AFTER %s@%s FIRST 5' % (STAXMachineNickname, TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest BEFORE {STAFTest/Today}@23:59:59 FIRST 5' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest LAST 10' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest FIRST 1 ALL' % (STAXMachineNickname),
            [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest LAST 1 ALL' % (STAXMachineNickname),
            [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest TOTAL LONG' % (STAXMachineNickname),
            [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest STATS LONG' % (STAXMachineNickname),
            [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest FIRST 10badNumber' % (STAXMachineNickname),
            [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest FROM 2003badDate' % (STAXMachineNickname),
            [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest FROM TODAY@01:61:badtime' % (STAXMachineNickname),
            [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:LOG', LogService, 'LOG MACHINE LOGNAME staftest LEVEL 00000000000000000000000000000001 MESSAGE :33:Testcase aborted with error "255"',
            [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG MACHINE LOGNAME staftest LEVEL 00000000000000000000000010000000 MESSAGE Recovered',
            [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'LOG MACHINE LOGNAME staftest LEVEL start MESSAGE "Step1 in Test1 initiated"',
            [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest LEVELMASK "TRACE TRACE2 DEBUG DEBUG2"' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest QMACHINE {STAFTest/STAXMachine} QHANDLE {STAFTest/LogHandle}' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:LOG', LogService, 'ASK MACHINE %s LOGNAME staftest LAST 1' % (STAXMachineNickname),
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:LOG', LogService, 'LOG MACHINE LOGNAME staftest LEVEL 00000000000000000000000000000001 MESSAGE :33:Testcase aborted with error "255"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE %s LOGNAME staftest CONFIRM' % (STAXMachineNickname),
          [ 4008 ], None
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE {STAFTest/STAXMachineNickname} LOGNAME {STAFTest/LogName} CONTAINS {STAFTest/LogContains} STARTSWITH {STAFTest/LogStartsWith} AFTER %s@%s FIRST 1 CONFIRM' % (TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE %s LOGNAME {STAFTest/LogName} CSCONTAINS Tuesday CSSTARTSWITH Testing BEFORE TODAY@23:59:59 LAST 1 CONFIRM' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE %s LOGNAME staftest LEVELMASK "INFO DEBUG" FROM %s@%s TO TODAY@23:59:59 LAST 1 CONFIRM' % (STAXMachineNickname, TestMachJobStartDate, TestMachJobStartTime),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],

        [ 'STD:LOG', LogService, 'PURGE MACHINE %s LOGNAME staftest NAME {STAFTest/HName} QMACHINE {STAFTest/STAXMachine} QHANDLE {STAFTest/LogHandle} FIRST 1 CONFIRM' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "STAFResult['purgedRecords'] == '1'"
        ],
        
        [ 'STD:LOG', LogService, 'PURGE MACHINE %s LOGNAME staftest NAME {STAFTest/HName} QMACHINE {STAFTest/STAXMachine} QHANDLE 0 FIRST 1 CONFIRM' % (STAXMachineNickname),
          [ STAFRC.InvalidValue], None,
        ],
        
        [ 'STD:LOG', LogService, 'PURGE MACHINE %s LOGNAME staftest NAME {STAFTest/HName} QMACHINE {STAFTest/STAXMachine} QHANDLE 9999999999 FIRST 1 CONFIRM' % (STAXMachineNickname),
          [ STAFRC.InvalidValue], None,
        ],

        [ 'STD:LOG', LogService, 'DELETE MACHINE {STAFTest/STAXMachineNickname} LOGNAME {STAFTest/LogName} CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'DELETE MACHINE %s LOGNAME staftest CONFIRM' % (STAXMachineNickname),
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:LOG', LogService, 'QUERY MACHINE %s LOGNAME staftest STATS' % (STAXMachineNickname),
          [ STAFRC.DoesNotExist ], None
        ],

        # Log Settings tests
        
        [ 'STD:LOG', LogService, 'SET DEFAULTMAXQUERYRECORDS -1',
          [ STAFRC.InvalidValue ], ''
        ],
        
        [ 'STD:LOG', LogService, 'SET DEFAULTMAXQUERYRECORDS 4294967296',
          [ STAFRC.InvalidValue ], ''
        ],

        # Set the defaultMaxQueryRecords, verify it was set, and reset to the original value

        [ 'STD:LOG', LogService, 'SET DEFAULTMAXQUERYRECORDS 110',
          [ STAFRC.Ok ], ''
        ],

        [ 'STD:LOG', LogService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['defaultMaxQueryRecords'] == '110'"
        ],

        [ 'STD:LOG', LogService, 'SET DEFAULTMAXQUERYRECORDS 100',
          [ STAFRC.Ok ], ''
        ],

        [ 'STD:LOG', LogService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "(STAFResult['loggingMode'] == 'Local' and " +
          "STAFResult['directory'] != '' and " +
          "STAFResult['maxRecordSize'] >= '100000' and " +
          "STAFResult['defaultMaxQueryRecords'] == '100' and " +
          "STAFResult['resolveMessage'] == 'Disabled' and " +
          "STAFResult['resolveMessageVar'] == 'Disabled') or " +
          "(STAFResult['loggingMode'] == 'Remote' and " +
          "STAFResult['remoteLogServer'] != '' and " +
          "STAFResult['remoteLogService'] != '')",
          "logServiceMaxRecordSize = STAFResult['maxRecordSize']"
        ],

        [ 'STD:LOG', LogService, 'SET MAXRECORDSIZE -1',
          [ STAFRC.InvalidValue ], ''
        ],
        
        [ 'STD:LOG', LogService, 'SET MAXRECORDSIZE 00009999999999',
          [ STAFRC.InvalidValue ], ''
        ],

        # Set the maxRecordSize, verify it was set, and reset to the original value

        [ 'STD:LOG', LogService, 'SET MAXRECORDSIZE 110000',
          [ STAFRC.Ok ], ''
        ],

        [ 'STD:LOG', LogService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['maxRecordSize'] == '110000'"
        ],

        [ 'STD:LOG', LogService, 'SET MAXRECORDSIZE 1048576',
          [ STAFRC.Ok ], ''
        ],

        # Set the enableResolveMessageVar, verify it was set, and disable it

        [ 'STD:LOG', LogService, 'SET ENABLERESOLVEMESSAGEVAR',
          [ STAFRC.Ok ], ''
        ],

        [ 'STD:LOG', LogService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['resolveMessageVar'] == 'Enabled'"
        ],

        [ 'STD:LOG', LogService, 'SET DISABLERESOLVEMESSAGEVAR',
          [ STAFRC.Ok ], ''
        ],

        [ 'STD:LOG', LogService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['resolveMessageVar'] == 'Disabled'"
        ],

        # Test RESOLVEMESSAGE/NORESOLVEMESSAGE settings

        [ 'STD:LOG', LogService, 'SET RESOLVEMESSAGE',
          [ STAFRC.Ok ], ''
        ],

        [ 'STD:LOG', LogService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['resolveMessage'] == 'Enabled'"
        ],

        [ 'STD:LOG', LogService, 'LOG GLOBAL LOGNAME staftest LEVEL info MESSAGE {STAFTest/LogMsg}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest LAST 1',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and STAFResult[0]['message'] == 'This message had to be resolved'"
        ],

        [ 'STD:LOG', LogService, 'SET NORESOLVEMESSAGE',
          [ STAFRC.Ok ], ''
        ],

        [ 'STD:LOG', LogService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['resolveMessage'] == 'Disabled'"
        ],

        [ 'STD:LOG', LogService, 'LOG GLOBAL LOGNAME staftest LEVEL info MESSAGE {STAFTest/LogMsg}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', LogService, 'QUERY GLOBAL LOGNAME staftest LAST 1',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and STAFResult[0]['message'] == '{STAFTest/LogMsg}'"
        ],

        [ 'STD:LOG', 'HELP', 'ERROR 4010 SERVICE LOG',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'Exceeded default maximum query records' and "
          "len(STAFResult['details']) > len(STAFResult['description'])"
        ],

        [ 'STD:LOG', LogService, 'DELETE GLOBAL LOGNAME staftest CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        # Perform clean-up

        [ 'STD:LOG', 'VAR', 'DELETE VAR STAFTest/LogStartsWith',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', 'VAR', 'DELETE VAR STAFTest/LogMsg VAR STAFTest/LogName VAR STAFTest/LogLevel',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', 'VAR', 'DELETE VAR STAFTest/LogMask VAR STAFTest/LogFirst VAR STAFTest/LogLast VAR STAFTest/HName',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', 'VAR', 'DELETE VAR STAFTest/LogHandle VAR STAFTest/STAXMachine VAR STAFTest/STAXMachineNickname',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', 'VAR', 'DELETE VAR STAFTest/LogContains VAR STAFTest/Today',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:LOG', 'SEM', 'RELEASE MUTEX STAFTest/LOG', [ STAFRC.Ok ], r'^$' ]

      ]

      </script>

      <return>LOGTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitMONITORTests - This function initializes all the MONITOR test information  -->
  <!-- ========================================================================== -->

  <function name="InitMONITORTests" scope="local">
    <sequence>

      <script>
        currYear = time.strftime("%Y")
        futureDate = "%s0101" % (int(currYear) + 1)
      </script>

      <script>

      MONITORTests = [

        #
        #MONITOR tests
        #

        [ 'STD:MONITOR', 'SEM',     'REQUEST MUTEX STAFTest/MONITOR',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:MONITOR', MonitorService, 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:MONITOR', MonitorService, 'VERSION',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:MONITOR', MonitorService, 'SET NORESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'SET DISABLERESOLVEMESSAGEVAR',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['maxRecordSize']) > 0 and " +
          "STAFResult['resolveMessageVar'] == 'Disabled' and " +
          "STAFResult['resolveMessage'] == 'Disabled'"
        ],

        [ 'STD:MONITOR', 'VAR',     'SET VAR "STAFTest/STAXMachineNickname=%s" VAR "STAFTest/Handle=%s" VAR "STAFTest/STAXMachine=%s"' % \
                                    (STAXMachineNickname, JobHandle, STAXMachine),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :39:Check QUERY MACHINE variable resolution',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} HANDLE %s' % (JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Check QUERY MACHINE variable resolution'"
        ],

        ]
        </script>
      </if>

      <script>
        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :38:Check QUERY HANDLE variable resolution',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE {STAFTest/Handle}' % (STAXMachineNickname),
         [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Check QUERY HANDLE variable resolution'"
         ]

        ]
        </script>
      </if>

      <script>
        MONITORTests = MONITORTests + [

        # Test ENABLERESOLVEMESSAGEVAR and DISABLERESOLVEMESSAGEVAR Settings

        [ 'STD:MONITOR', MonitorService, 'SET ENABLERESOLVEMESSAGEVAR',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['resolveMessageVar'] == 'Enabled'"
        ],

        [ 'STD:MONITOR', 'VAR',     'SET VAR "STAFTest/MonMsg=Message for testing ENABLERESOLVEMESSAGEVAR"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg}',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <!-- Doesn't work on SMP machines like staf1e so commented out
      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == '{STAFTest/MonMsg}'"
        ]

        ]
        </script>
      </if>
      -->

      <script>

        MONITORTests = MONITORTests + [


        [ 'STD:MONITOR', 'VAR',     'SET VAR STAF/Service/Monitor/ResolveMessage=0',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg}',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == '{STAFTest/MonMsg}'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', 'VAR',     'SET VAR STAF/Service/Monitor/ResolveMessage=1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg}',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == 'Message for testing ENABLERESOLVEMESSAGEVAR'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'SET DISABLERESOLVEMESSAGEVAR',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['resolveMessageVar'] == 'Disabled'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg}',
          [ STAFRC.Ok ], r'^$'
        ]


      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == '{STAFTest/MonMsg}'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        # Test RESOLVEMESSAGE Setting

        [ 'STD:MONITOR', MonitorService, 'SET RESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', 'VAR',     'SET VAR "STAFTest/MonMsg=Message for testing RESOLVEMESSAGE"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg}',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == 'Message for testing RESOLVEMESSAGE'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg} RESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == 'Message for testing RESOLVEMESSAGE'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg} NORESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == '{STAFTest/MonMsg}'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        # Test NORESOLVEMESSAGE Setting

        [ 'STD:MONITOR', MonitorService, 'SET NORESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['resolveMessage'] == 'Disabled'"
        ],

        [ 'STD:MONITOR', 'VAR',     'SET VAR "STAFTest/MonMsg=Message for testing NORESOLVEMESSAGE"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg}',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == '{STAFTest/MonMsg}'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg} RESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == 'Message for testing NORESOLVEMESSAGE'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg} NORESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == '{STAFTest/MonMsg}'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        # Test MAXRECORDSIZE Setting

        [ 'STD:MONITOR', 'VAR',     'SET VAR STAFTest/MaxRecSize=512',
          [ STAFRC.Ok ], r'^$'
        ],

        #  56 + 18 (length of timestamp + 1) = 74
        [ 'STD:MONITOR', MonitorService, 'SET MAXRECORDSIZE 74',
          [ STAFRC.Ok ], r'^$'
        ]
        ,
        [ 'STD:MONITOR', 'VAR',     'SET VAR "STAFTest/MonMsg=This message is longer than 56 characters at this point. MISSING THIS"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg} RESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == 'This message is longer than 56 characters at this point.'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'SET MAXRECORDSIZE {STAFTest/MaxRecSize}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['maxRecordSize']) == 512"
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE {STAFTest/MonMsg} RESOLVEMESSAGE',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == 'This message is longer than 56 characters at this point. MISSING THIS'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        # Test DELETE option

        [ 'STD:MONITOR', MonitorService, 'DELETE CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE %s' % (STAXMachineNickname),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :20:Monitor STAFTest 123',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE BEFORE TODAY CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <if expr="testMachineIsLocal">
        <script>

        # MONITOR QUERY only works if the Test machine is the STAX machine

        MONITORTests = MONITORTests + [

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.Ok ], None,
          "STAFResult['message'] == 'Monitor STAFTest 123'"
        ]

        ]
        </script>
      </if>

      <script>

        MONITORTests = MONITORTests + [

        # Named Monitor tests

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :29:Testing Named Monitor Support NAME NameTest1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME NameTest1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME NAMETEST1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME nametest1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME NameTest2',
          [ STAFRC.DoesNotExist ], r'^.'
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'NameTest1' and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :37:Testing Named Monitor Support Update1 NAME nametest1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME NameTest1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support Update1'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME NAMETEST1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support Update1'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME nametest1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support Update1'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'NameTest1' and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :37:Testing Named Monitor Support Update2 NAME NAMETEST1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME NameTest1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support Update2'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME NAMETEST1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support Update2'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME nametest1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support Update2'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'NameTest1' and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY HANDLE X NAME Y',
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST NAMES MACHINE {STAFTest/STAXMachineNickname}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'NameTest1' and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0"
        ],
        
        [ 'STD:MONITOR', MonitorService, 'LIST NAME MACHINE {STAFTest/STAXMachineNickname}',
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :12:Loop 5 of 27 NAME :20:Named Monitor Test A',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test A',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Loop 5 of 27'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :14:Loop 20 of 107 NAME :20:Named Monitor Test B',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test B',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Loop 20 of 107'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :13:Loop 76 of 77 NAME :20:Named Monitor Test C',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test C',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Loop 76 of 77'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'Named Monitor Test A' and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0 and " +
          "STAFResult[1]['name'] == 'Named Monitor Test B' and " +
          "STAFResult[1]['timestamp'] and " +
          "string.atoi(STAFResult[1]['size']) > 0 and " +
          "STAFResult[2]['name'] == 'Named Monitor Test C' and " +
          "STAFResult[2]['timestamp'] and " +
          "string.atoi(STAFResult[2]['size']) > 0 and " +
          "STAFResult[3]['name'] == 'NameTest1' and " +
          "STAFResult[3]['timestamp'] and " +
          "string.atoi(STAFResult[3]['size']) > 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE BEFORE %s CONFIRM' % (TestMachJobStartDate),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME nametest1',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Testing Named Monitor Support Update2'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test A',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Loop 5 of 27'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test B',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Loop 20 of 107'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test C',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Loop 76 of 77'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'Named Monitor Test A' and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0 and " +
          "STAFResult[1]['name'] == 'Named Monitor Test B' and " +
          "STAFResult[1]['timestamp'] and " +
          "string.atoi(STAFResult[1]['size']) > 0 and " +
          "STAFResult[2]['name'] == 'Named Monitor Test C' and " +
          "STAFResult[2]['timestamp'] and " +
          "string.atoi(STAFResult[2]['size']) > 0 and " +
          "STAFResult[3]['name'] == 'NameTest1' and " +
          "STAFResult[3]['timestamp'] and " +
          "string.atoi(STAFResult[3]['size']) > 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE BEFORE %s CONFIRM' % futureDate,
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME nametest1',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test A',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test B',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test C',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :22:Step 95345 of 18943141 NAME :20:Named Monitor Test X',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test X',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Step 95345 of 18943141'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :32:Windows Vista tests 54% complete NAME :20:Named Monitor Test Y',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test Y',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Windows Vista tests 54% complete'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :14:Error code 291 NAME :20:Named Monitor Test Z',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test Z',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Error code 291'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'Named Monitor Test X' and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0 and " +
          "STAFResult[1]['name'] == 'Named Monitor Test Y' and " +
          "STAFResult[1]['timestamp'] and " +
          "string.atoi(STAFResult[1]['size']) > 0 and " +
          "STAFResult[2]['name'] == 'Named Monitor Test Z' and " +
          "STAFResult[2]['timestamp'] and " +
          "string.atoi(STAFResult[2]['size']) > 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE MACHINE {STAFTest/STAXMachineNickname} NAME dummyName CONFIRM',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE MACHINE {STAFTest/STAXMachineNickname} NAME Named Monitor Test Y CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test X',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Step 95345 of 18943141'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test Y',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test Z',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Error code 291'"
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'Named Monitor Test X' and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0 and " +
          "STAFResult[1]['name'] == 'Named Monitor Test Z' and " +
          "STAFResult[1]['timestamp'] and " +
          "string.atoi(STAFResult[1]['size']) > 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE MACHINE {STAFTest/STAXMachineNickname} NAME NAMED MONITOR test Z CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test X',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Step 95345 of 18943141'"
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test Z',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] == 'Named Monitor Test X' and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE MACHINE DummyMachine NAME Named Monitor Test X CONFIRM',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test X',
          [ STAFRC.Ok ], None,
          "STAFResult['timestamp'] and " +
          "STAFResult['message'] == 'Step 95345 of 18943141'"
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE MACHINE {STAFTest/STAXMachineNickname} NAME NAMED MONITOR test X CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE {STAFTest/STAXMachineNickname} NAME :20:Named Monitor Test X',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname} NAMES',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE MACHINE {STAFTest/STAXMachineNickname}',
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE NAME TestName',
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'DELETE MACHINE {STAFTest/STAXMachineNickname} NAME TestName BEFORE TODAY',
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'LOG MESSAGE :39:Check QUERY MACHINE variable resolution',
          [ STAFRC.Ok ], r'^$'
        ]

       ]
      </script>

      <script>

        MONITORTests = MONITORTests + [

        # Test Error Conditions

        [ 'STD:MONITOR', MonitorService, 'ASK MACHINE %s HANDLE %s' % (STAXMachineNickname, JobHandle),
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE HAN9809897' % (STAXMachineNickname),
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE 9809897' % (STAXMachineNickname),
          [ STAFRC.DoesNotExist ], r'^.'
        ],
        
        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE 0' % (STAXMachineNickname),
          [ STAFRC.InvalidValue ], r'^.'
        ],
        
        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE 9999999999' % (STAXMachineNickname),
          [ STAFRC.InvalidValue ], r'^.'
        ],
        
        [ 'STD:MONITOR', MonitorService, 'QUERY MACHINE %s HANDLE -1' % (STAXMachineNickname),
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:MONITOR', MonitorService, 'SET MAXRECORDSIZE -1',
          [ STAFRC.InvalidValue ], r'^.'
        ],
        
        [ 'STD:MONITOR', MonitorService, 'SET MAXRECORDSIZE 9999999999',
          [ STAFRC.InvalidValue ], r'^.'
        ],

        [ 'STD:MONITOR', MonitorService, 'REFRESH VAR',
          [ STAFRC.InvalidRequestString ], None
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:MONITOR', MonitorService, 'LIST MACHINE {STAFTest/STAXMachineNickname}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['handle'] and " +
          "STAFResult[0]['timestamp'] and " +
          "string.atoi(STAFResult[0]['size']) > 0"
        ],

        [ 'STD:MONITOR', 'VAR',     'DELETE VAR STAFTest/Handle VAR STAFTest/STAXMachineNickname',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', 'VAR',     'DELETE VAR STAFTest/MonMsg VAR STAFTest/MaxRecSize',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:MONITOR', 'SEM',     'RELEASE MUTEX STAFTest/MONITOR',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>MONITORTests</return>

    </sequence>
  </function>


  <!-- ============================================================================== -->
  <!-- InitRESPOOLTests - This function initializes all the RESPOOL test information  -->
  <!-- ============================================================================== -->

  <function name="InitRESPOOLTests" scope="local">
    <sequence>

        <testcase name="'RESPOOL'">
          <sequence>

            <!-- Clean up resource pools in case test was interupted on a previous run -->

            <message>
              'STAF %s RESPOOL DELETE POOL STAFTestGC CONFIRM FORCE' % (TestMach)
            </message>

            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'DELETE POOL STAFTestGC CONFIRM FORCE'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC in [ STAFRC.Ok, STAFRC.DoesNotExist ],
                'failMsg': 'STAF %s RESPOOL DELETE POOL STAFTestGC CONFIRM FORCE RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'CREATE POOL STAFTestGC DESCRIPTION "Test Pool"'</request>
            </stafcmd>
            
            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC in [ STAFRC.Ok ],
                'failMsg': 'STAF %s RESPOOL CREATE POOL STAFTestGC DESCRIPTION "Test Pool" RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'ADD POOL STAFTestGC ENTRY Resource1'</request>
            </stafcmd>
            
            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC in [ STAFRC.Ok ],
                'failMsg': 'STAF %s RESPOOL ADD POOL STAFTestGC ENTRY Resource1 RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <!-- Test that garbage collection is taking place for the handle that requested the resource pool entry -->

            <message>
              'Test garbage collection is taking place:  STAF %s RESPOOL REQUEST POOL STAFTestGC' % (TestMach)
            </message>

            <process name="'TestGarbageCollectedResPoolEntry'">
              <location>TestMach</location>
              <command mode="'shell'">
                'STAF local %s REQUEST POOL STAFTestGC' % (ResPoolService)
              </command>
              <stderr mode="'stdout'"/>
              <returnstdout/>
            </process>

            <script>
              if STAXResult != None and len(STAXResult) > 0:
                poolEntry = STAXResult[0][1]
            </script>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s RESPOOL REQUEST POOL STAFTestGC  RC=%s STAFResult=%s STAXResult=%s' % (TestMach, RC, STAFResult, STAXResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <stafcmd name="'Delay 5 seconds while wait for gc to occur'">
              <location>'local'</location>
              <service>'DELAY'</service>
              <request>'DELAY 5s'</request>
            </stafcmd>

            <message>
              'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
            </message>

            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'QUERY POOL STAFTestGC'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s RESPOOL QUERY POOL STAFTestGC  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <if expr="RC == STAFRC.Ok">
              <sequence>
                <script>
                  if STAFResult['resourceList'][0]['owner'] == None:
                    failMsg = ''
                  else:
                    failMsg = 'RESPOOL QUERY POOL STAFTestGC shows that the entry is owned when it should be unowned due to garbage collection. STAFResult=%s' % (STAFResult)
                </script>

                <call function="'STAXUtilCheckSuccess'">
                  { 'result': failMsg == '',
                    'failMsg': failMsg,
                    'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
              </sequence>
            </if>

            <!-- Test that garbage collection is not taking place for the handle that requested the resource pool entry -->

            <message>
              'Test garbage collection is not taking place:  STAF %s RESPOOL REQUEST POOL STAFTestGC GARBAGECOLLECT No' % (TestMach)
            </message>

            <process name="'TestNoGarbageCollectedResPoolEntry'">
              <location>TestMach</location>
              <command mode="'shell'">
                'STAF local %s REQUEST POOL STAFTestGC GARBAGECOLLECT No' % (ResPoolService)
              </command>
              <stderr mode="'stdout'"/>
              <returnstdout/>
            </process>

            <script>
              if RC == STAFRC.Ok and STAXResult != None and len(STAXResult) > 0:
                poolEntry = STAXResult[0][1]
            </script>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s RESPOOL REQUEST POOL STAFTestGC GARBAGECOLLECT No  RC=%s STAFResult=%s STAXResult=%s' % (TestMach, RC, STAFResult, STAXResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <stafcmd name="'Delay 5 seconds while wait for gc to occur'">
              <location>'local'</location>
              <service>'DELAY'</service>
              <request>'DELAY 5s'</request>
            </stafcmd>

            <message>
              'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
            </message>

            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'QUERY POOL STAFTestGC'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s RESPOOL QUERY POOL STAFTestGC  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <if expr="RC == STAFRC.Ok">
              <sequence>
                <script>
                  if STAFResult['resourceList'][0]['owner'] != None and STAFResult['resourceList'][0]['owner']['gc'] == 'No':
                    failMsg = ''
                  else:
                    failMsg = 'RESPOOL QUERY POOL STAFTestGC shows that the resource is unowned when it should be owned due to no garbage collection. STAFResult=%s' % (STAFResult)
                </script>

                <call function="'STAXUtilCheckSuccess'">
                  { 'result': failMsg == '',
                    'failMsg': failMsg,
                    'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
              </sequence>
            </if>

            <message>
              'STAF %s RESPOOL RELEASE POOL STAFTestGC ENTRY Resource1 FORCE' % (TestMach)
            </message>

            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'RELEASE POOL STAFTestGC ENTRY Resource1 FORCE'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s RESPOOL RELEASE POOL STAFTestGC ENTRY Resource1 FORCE  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <!-- Verify that the RESPOOL service deletes it's callback notifications for garbage collection (Bug #1753844) -->

            <message>
              'Bug #1753844: Test that the RESPOOL service deletes any callback notifications for GC'
            </message>

            <!-- Get current number of entries in the handle notification list -->
            <stafcmd>
              <location>TestMach</location>
              <service>'HANDLE'</service>
              <request>'LIST NOTIFICATIONS'</request>
            </stafcmd>

            <script>
              # Create a list of the current notifications for the RESPOOL service
              prevRespoolNotificationList = []
              for entry in STAFResult:
                  if entry['notifyService'] == 'RESPOOL':
                    prevRespoolNotificationList.append(entry)
            </script>

            <script>
              command = 'STAF local %s REQUEST POOL STAFTestGC {STAF/Config/Sep/Command}' % (ResPoolService) + \
                'STAF local %s RELEASE POOL STAFTestGC ENTRY Resource1' % (ResPoolService)
            </script>

            <process name="'Test Bug #1753844'">
              <location>TestMach</location>
              <command mode="'shell'">command</command>
              <statichandlename>'STAFTestGC'</statichandlename>
              <stderr mode="'stdout'"/>
              <returnstdout/>
            </process>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s PROCESS START SHELL COMMAND "%s"  RC=%s STAFResult=%s STAXResult=%s' % \
                 (TestMach, command, RC, STAFResult, STAXResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>
            
            <script>
              # Delay for 5 seconds while wait for gc to complete
              # Note:  Don't using the DELAY service as that adds to the garbage collection notifications
              import time
              time.sleep(5)
            </script>

            <message>
              'STAF %s HANDLE LIST NOTIFICATIONS' % (TestMach)
            </message>

            <stafcmd>
              <location>TestMach</location>
              <service>'HANDLE'</service>
              <request>'LIST NOTIFICATIONS'</request>
            </stafcmd>

            <script>
              # Create a list of the current notifications for the RESPOOL service
              currRespoolNotificationList = []
              for entry in STAFResult:
                  if entry['notifyService'] == 'RESPOOL':
                    currRespoolNotificationList.append(entry)
            </script>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s HANDLE LIST NOTIFICATIONS  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <!-- Verify that no notifications are left in the handle notification list for respool garbage collection -->
            
            <script>
              if len(currRespoolNotificationList) == len(prevRespoolNotificationList):
                failMsg = ''
              else:
                failMsg = 'STAF %s HANDLE LIST NOTIFICATIONS contains %s entries instead of %s entries.\n Curr Notification List: %s\n Prev Notification List: %s' % \
                  (TestMach, len(currRespoolNotificationList), len(prevRespoolNotificationList), currRespoolNotificationList, prevRespoolNotificationList)
            </script>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': failMsg == '',
                'failMsg': failMsg,
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>
            
            <!-- End of GC test for Bug #1753844 -->

            <!-- Test garbage collection when the same handle requests a mutex semaphore and a resource entry and then releases the mutex (Bug #1753842) -->

            <message>
              'Bug #1753842: Test garbage collection by having the same handle request a mutex semapahore and a resource entry, ' + \
              'release the mutex, and then delete the handle.  There should be no notifications added when this completes'
            </message>

            <!-- Get current number of entries in the handle notification list -->
            <stafcmd>
              <location>TestMach</location>
              <service>'HANDLE'</service>
              <request>'LIST NOTIFICATIONS'</request>
            </stafcmd>

            <script>
              # Create a list of the current notifications for the RESPOOL service
              prevRespoolNotificationList = []
              for entry in STAFResult:
                  if entry['notifyService'] == 'RESPOOL':
                    prevRespoolNotificationList.append(entry)
            </script>

            <script>
              command = 'STAF local %s REQUEST POOL STAFTestGC {STAF/Config/Sep/Command}' % (ResPoolService) + \
                'STAF local SEM REQUEST MUTEX STAFTest/GCMutex {STAF/Config/Sep/Command}' + \
                'STAF local SEM RELEASE MUTEX STAFTest/GCMutex'
            </script>

            <process name="'Test Bug #1753842'">
              <location>TestMach</location>
              <command mode="'shell'">command</command>
              <statichandlename>'STAFTestGC'</statichandlename>
              <stderr mode="'stdout'"/>
              <returnstdout/>
            </process>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s PROCESS START SHELL COMMAND "%s"  RC=%s STAFResult=%s STAXResult=%s' % \
                 (TestMach, command, RC, STAFResult, STAXResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <script>
              # Delay for 5 seconds while wait for gc to complete
              # Note:  Don't using the DELAY service as that adds to the garbage collection notifications
              import time
              time.sleep(5)
            </script>

            <message>
              'STAF %s HANDLE LIST NOTIFICATIONS' % (TestMach)
            </message>

            <stafcmd>
              <location>TestMach</location>
              <service>'HANDLE'</service>
              <request>'LIST NOTIFICATIONS'</request>
            </stafcmd>

            <script>
              # Create a list of the current notifications for the RESPOOL service
              currRespoolNotificationList = []
              for entry in STAFResult:
                  if entry['notifyService'] == 'RESPOOL':
                    currRespoolNotificationList.append(entry)
            </script>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s HANDLE LIST NOTIFICATIONS  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <!-- Verify that no notifications are left in the handle notification list for garbage collection -->
            
            <script>
              if len(currRespoolNotificationList) == len(prevRespoolNotificationList):
                failMsg = ''
              else:
                failMsg = 'STAF %s HANDLE LIST NOTIFICATIONS contains %s entries instead of %s entries.\n Curr Notification List: %s\n Prev Notification List: %s' % \
                  (TestMach, len(currRespoolNotificationList), len(prevRespoolNotificationList), currRespoolNotificationList, prevRespoolNotificationList)
            </script>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': failMsg == '',
                'failMsg': failMsg,
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <stafcmd name="'Clean-up: Release mutex semaphore STAFTest/GCMutex'">
              <location>TestMach</location>
              <service>'SEM'</service>
              <request>'DELETE MUTEX STAFTest/GCMutex'</request>
            </stafcmd>
            
            <!-- End of GC test for Bug #1753842 -->

            <!-- Test garbage collection when the same handle requests two resources and then releases a resource
                  and then the handle is deleted.  Now, neither resource should be owned (due to garbage collection).. -->

            <message>
              'Test garbage collection by having the same handle request two resources from a pool, ' + \
              'release an entry, and then delete the handle.  Now, neither resource should be owned.'
            </message>

            <!-- Release Resource1 -->
            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'RELEASE POOL STAFTestGC ENTRY Resource1 FORCE'</request>
            </stafcmd>

            <!-- Add another entry to the pool so that there are two entries -->
            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'ADD POOL STAFTestGC ENTRY Resource2'</request>
            </stafcmd>

            <script>
              command = 'STAF local %s REQUEST POOL STAFTestGC {STAF/Config/Sep/Command}' % (ResPoolService) + \
                'STAF local %s REQUEST POOL STAFTestGC {STAF/Config/Sep/Command}' % (ResPoolService) + \
                'STAF local %s RELEASE POOL STAFTestGC ENTRY Resource2' % (ResPoolService)
            </script>

            <process name="'Test RESPOOL GC'">
              <location>TestMach</location>
              <command mode="'shell'">command</command>
              <statichandlename>'STAFTestGC'</statichandlename>
              <stderr mode="'stdout'"/>
              <returnstdout/>
            </process>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s PROCESS START SHELL COMMAND "%s"  RC=%s STAFResult=%s STAXResult=%s' % \
                 (TestMach, command, RC, STAFResult, STAXResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <!-- Delay 5 seconds to give garbage collection a chance to be performed -->
            <stafcmd name="'Delay 5 seconds to allow garbage collection to be performed'">
              <location>'local'</location>
              <service>'DELAY'</service>
              <request>'DELAY 5s'</request>
            </stafcmd>

            <message>
              'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
            </message>

            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'QUERY POOL STAFTestGC'</request>
            </stafcmd>

            <script>
              queryPoolMap = STAFResult
            </script>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.Ok,
                'failMsg': 'STAF %s RESPOOL QUERY POOL STAFTestGC  RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <!-- Verify that both resources are unowned -->
            
            <script>
              if queryPoolMap['resourceList'][0]['owner'] == None and queryPoolMap['resourceList'][1]['owner'] == None:
                failMsg = ''
              else:
                failMsg = 'STAF %s RESPOOL QUERY POOL STAFTestGC shows that Resource1 and Resource2 are not both unowned. STAFResult=%s' % \
                  (TestMach, queryPoolMap)
            </script>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': failMsg == '',
                'failMsg': failMsg,
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <stafcmd name="'Clean-up: Release Resource1 in STAFTestGC'">
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'RELEASE POOL STAFTestGC ENTRY Resource1 FORCE'</request>
            </stafcmd>

            <stafcmd name="'Clean-up: Release Resource2 in STAFTestGC'">
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'RELEASE POOL STAFTestGC ENTRY Resource2 FORCE'</request>
            </stafcmd>
            
            <!-- End of GC test -->

            <!-- Begin testing requesting a particular entry in a resource pool -->

            <message>
              'Test requesting a particular entry in a resource pool on machine %s' % (TestMach)
            </message>

            <!-- Clean up any event semaphores from a previous run -->
            <iterate var="i" in="range(1, 9)">
              <stafcmd name="'Reset Event Semaphore STAFTest/Respool/Step%s' % (i)">
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'RESET EVENT STAFTest/Respool/Step%s' % (i)</request>
              </stafcmd>
            </iterate>

            <parallel>
              <block name="'Step 1: RESPOOL Entry Test'">
              <sequence>
                <script>
                 command = 'STAF %s %s REQUEST POOL STAFTestGC ENTRY Resource2 GARBAGECOLLECT No {STAF/Config/Sep/Command}' % (TestMach, ResPoolService) + \
                   ' STAF %s %s REQUEST POOL STAFTestGC FIRST GARBAGECOLLECT No {STAF/Config/Sep/Command}' % (TestMach, ResPoolService) + \
                   ' STAF %s SEM POST EVENT STAFTest/Respool/Step2 {STAF/Config/Sep/Command}' % (TestMach) + \
                   ' STAF %s %s REQUEST POOL STAFTestGC ENTRY Resource2 GARBAGECOLLECT No {STAF/Config/Sep/Command}' % (TestMach, ResPoolService)
                </script>
                <message>command</message>
                <process name="'RequestResources'">
                  <location>TestMach</location>
                  <command mode="'shell'">command</command>
                  <stderr mode="'stdout'"/>
                  <returnstdout/>
                </process>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': '%s RC=%s STAFResult=%s STAXResult=%s' % (command, RC, STAFResult, STAXResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
              </sequence>
              </block>

              <block name="'Step 2: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step2'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step2 TIMEOUT 600000'</request>
                </stafcmd>
                <stafcmd name="'Delay for 3 seconds while request Resource2 is submitted'">
                  <location>'local'</location>
                  <service>'DELAY'</service>
                  <request>'DELAY 3s'</request>
                </stafcmd>
                <message>
                  'STAF %s RESPOOL REQUEST POOL STAFTestGC ENTRY Resource2 GARBAGECOLLECT No' % (TestMach)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource2'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>'REQUEST POOL STAFTestGC ENTRY Resource2 GARBAGECOLLECT No'</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok and STAFResult == 'Resource2',
                       'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource2' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 3 seconds while request Resource2 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 3s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step3'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step3'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 3: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step3'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step3 TIMEOUT 600000'</request>
                </stafcmd>
                <message>
                  'STAF %s RESPOOL REQUEST POOL STAFTestGC FIRST GARBAGECOLLECT No' % (TestMach)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Any Resource'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>'REQUEST POOL STAFTestGC FIRST GARBAGECOLLECT No'</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok and STAFResult == 'Resource1',
                       'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource1' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 3 seconds while request first resource is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 3s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step4'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step4'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 4: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step4'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step4 TIMEOUT 600000'</request>
                </stafcmd>
                <message>
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there are 2 pending requests for Resource2 and 1 pending request for any resource
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 3 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource2' and
                    STAFResult['requestList'][1]['requestedEntry'] == 'Resource2' and
                    STAFResult['requestList'][2]['requestedEntry'] == None and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                 else:
                   success = 0
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL RELEASE POOL STAFTestGC ENTRY Resource2 FORCE' % (TestMach)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource2 Force'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'RELEASE POOL STAFTestGC ENTRY Resource2 FORCE'</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there is 1 pending request for Resource2 and 1 pending request for any resource
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 2 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource2' and
                    STAFResult['requestList'][1]['requestedEntry'] == None and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                 else:
                   success = 0
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL RELEASE POOL STAFTestGC ENTRY Resource2 FORCE' % (TestMach)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource2 Force'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'RELEASE POOL STAFTestGC ENTRY Resource2 FORCE'</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there is 1 pending request for any resource
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 1 and
                    STAFResult['requestList'][0]['requestedEntry'] == None and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                 else:
                   success = 0
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                
                <message>
                  'STAF %s RESPOOL RELEASE POOL STAFTestGC ENTRY Resource1 FORCE' % (TestMach)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource1 Force'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'RELEASE POOL STAFTestGC ENTRY Resource1 FORCE'</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there are no pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 0 and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                 else:
                   success = 0
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL REQUEST POOL STAFTestGC ENTRY Resource2 GARBAGECOLLECT No' % (TestMach)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource2'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>'REQUEST POOL STAFTestGC ENTRY Resource2 GARBAGECOLLECT No'</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.DoesNotExist,
                       'failMsg': 'RC=%s Expected RC=%s STAFResult=%s' % (RC, STAFRC.DoesNotExist, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 3 seconds while request Resource2 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 3s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step5'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step5'</request>
                    </stafcmd>
                  </sequence>
                </parallel>

              </sequence>
              </block>

              <block name="'Step 5: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step5'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step5 TIMEOUT 600000'</request>
                </stafcmd>
                <message>
                  'STAF %s RESPOOL REQUEST POOL STAFTestGC FIRST' % (TestMach)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Any Resource'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>'REQUEST POOL STAFTestGC FIRST'</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok and STAFResult == 'Resource2',
                       'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource2' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 3 seconds while request for first resource is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 3s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step6'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step6'</request>
                    </stafcmd>
                  </sequence>
                </parallel>

              </sequence>
              </block>

              <block name="'Step 6: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step6'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step6 TIMEOUT 600000'</request>
                </stafcmd>
                <message>
                  'STAF %s RESPOOL REQUEST POOL STAFTestGC ENTRY Resource2' % (TestMach)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource2'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>'REQUEST POOL STAFTestGC ENTRY Resource2 GARBAGECOLLECT No'</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.DoesNotExist,
                       'failMsg': 'RC=%s Expected RC=%s STAFResult=%s' % (RC, STAFRC.DoesNotExist, STAFResult),
                      'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 3 seconds while request for Resource2 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 3s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step7'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step7'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>
              
              <block name="'Step 7: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step7'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step7 TIMEOUT 600000'</request>
                </stafcmd>
                <message>
                  'STAF %s RESPOOL REMOVE POOL STAFTestGC ENTRY Resource2 CONFIRM FORCE' % (TestMach)
                </message>
                <stafcmd name="'Remove Entry Resource2'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'REMOVE POOL STAFTestGC ENTRY Resource2 CONFIRM FORCE'</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that only Resource1 exists in the pool and that it is owned and there is 1 pending request for any resource
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 1 and
                    STAFResult['requestList'][0]['requestedEntry'] == None and
                    len(STAFResult['resourceList']) == 1 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner']):
                   success = 1
                 else:
                   success = 0
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL REQUEST POOL STAFTestGC ENTRY Resource1 GARBAGECOLLECT No' % (TestMach)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource1'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>'REQUEST POOL STAFTestGC ENTRY Resource1 GARBAGECOLLECT No'</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok,
                       'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 3 seconds while request for Resource1 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 3s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step8'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step8'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 8: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step8'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step8 TIMEOUT 600000'</request>
                </stafcmd>
                <message>
                  'STAF %s RESPOOL ADD POOL STAFTestGC ENTRY Resource2 ENTRY Resource3' % (TestMach)
                </message>
                <stafcmd name="'Add Entry Resource2 and Resource3 with pending requests'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'ADD POOL STAFTestGC ENTRY Resource2 ENTRY Resource3'</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that Resource1, Resource2 and Resource3 exist in the pool and that Resource1 is owned and Resource2 is owned and 
                 # Resource3 is unowned and there is 1 pending request for Resource1
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 1 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource1' and
                    len(STAFResult['resourceList']) == 3 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner'] and
                    STAFResult['resourceList'][2]['entry'] == 'Resource3' and
                    STAFResult['resourceList'][2]['owner'] == None):
                   success = 1
                 else:
                   success = 0
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                
                <message>
                  'STAF %s RESPOOL REMOVE POOL STAFTestGC ENTRY Resource2 ENTRY Resource3 CONFIRM FORCE' % (TestMach)
                </message>
                <stafcmd name="'Remove Entry Resource2 and Resource3'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'REMOVE POOL STAFTestGC ENTRY Resource2 ENTRY Resource3 CONFIRM FORCE'</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                <!-- XXX -->

                <stafcmd name="'Release Pool STAFTestGC Entry Resource1 Force'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'RELEASE POOL STAFTestGC ENTRY Resource1 FORCE'</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that only Resource1 exists in the pool and that it is owned and there are no pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 0 and
                    len(STAFResult['resourceList']) == 1 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner']):
                   success = 1
                 else:
                   success = 0
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                
                <message>
                  'STAF %s RESPOOL RELEASE POOL STAFTestGC ENTRY Resource1 FORCE' % (TestMach)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource1 Force'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'RELEASE POOL STAFTestGC ENTRY Resource1 FORCE'</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that only Resource1 exists in the pool and that it is not owned and there are no pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 0 and
                    len(STAFResult['resourceList']) == 1 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] == None):
                   success = 1
                 else:
                   success = 0
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <!-- Clean-up the event semaphores used by this test -->
                <iterate var="i" in="range(1, 9)">
                  <stafcmd name="'Delete Event Semaphore STAFTest/Respool/Step%s' % (i)">
                    <location>TestMach</location>
                    <service>'SEM'</service>
                    <request>'DELETE EVENT STAFTest/Respool/Step%s' % (i)</request>
                  </stafcmd>
                </iterate>

                <message>'End testing requesting a particular entry in a resource pool'</message>

              </sequence>
              </block>

            </parallel>

            <!-- Test that the order of the Pending Requests list is correct (by priority, then requested date-time)
                  and that they acquire the correct resources in the correct order --> 

            <message log="1">
              'Test that the order of the Pending Requests list is correct (by priority, then requested date-time on machine %s' % (TestMach)
            </message>

            <!-- Clean up any event semaphores from a previous run -->
            <iterate var="i" in="range(1, 7)">
              <stafcmd name="'Reset Event Semaphore STAFTest/Respool/Step%s' % (i)">
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'RESET EVENT STAFTest/Respool/Step%s' % (i)</request>
              </stafcmd>
            </iterate>
            
            <!-- Add another entry to the pool so that there are two entries -->
            <script>command = 'ADD POOL STAFTestGC ENTRY Resource2'</script>
            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'ADD POOL STAFTestGC ENTRY Resource2'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
             { 'result': RC == STAFRC.Ok,
               'failMsg': '%s RC=%s STAFResult=%s STAXResult=%s' % (command, RC, STAFResult, STAXResult),
               'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <parallel>
              <block name="'Step 1: RESPOOL Entry Test'">
              <sequence>
                <script>
                 command = 'STAF %s %s REQUEST POOL STAFTestGC ENTRY Resource1 GARBAGECOLLECT No {STAF/Config/Sep/Command}' % (TestMach, ResPoolService) + \
                   ' STAF %s %s REQUEST POOL STAFTestGC ENTRY Resource2 GARBAGECOLLECT No {STAF/Config/Sep/Command}' % (TestMach, ResPoolService) + \
                   ' STAF %s SEM POST EVENT STAFTest/Respool/Step2 {STAF/Config/Sep/Command}' % (TestMach)
                </script>
                <message log="1">command</message>
                <process name="'RequestResources'">
                  <location>TestMach</location>
                  <command mode="'shell'">command</command>
                  <stderr mode="'stdout'"/>
                  <returnstdout/>
                </process>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': '%s RC=%s STAFResult=%s STAXResult=%s' % (command, RC, STAFResult, STAXResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
              </sequence>
              </block>

              <block name="'Step 2: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step2'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step2 TIMEOUT 600000'</request>
                </stafcmd>
                <script>command = 'REQUEST POOL STAFTestGC ENTRY Resource1 PRIORITY 99'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource1 at priority 99'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok and STAFResult == 'Resource1',
                       'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource1' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while request Resource1 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step3'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step3'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 3: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step3'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step3 TIMEOUT 600000'</request>
                </stafcmd>
                <script>command = 'REQUEST POOL STAFTestGC ENTRY Resource1'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource1 at default priority'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok and STAFResult == 'Resource1',
                       'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource1' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while request Resource1 at default priority 50 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step4'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step4'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>
              
              <block name="'Step 4: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step4'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step4 TIMEOUT 600000'</request>
                </stafcmd>
                <script>command = 'REQUEST POOL STAFTestGC ENTRY Resource1 PRIORITY 1'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource1 at priority 1'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok and STAFResult == 'Resource1',
                       'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource1' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while request Resource1 at default priority 1 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step5'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step5'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 5: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step5'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step5 TIMEOUT 600000'</request>
                </stafcmd>
                <script>command = 'REQUEST POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Any Resource'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok and STAFResult == 'Resource2',
                       'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource2' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while request any resource at default priority 50 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step6'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step6'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 6: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step6'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step6 TIMEOUT 600000'</request>
                </stafcmd>
                <message log="1">
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there are
                 # 3 pending requests for Resource1 and 1 pending request for any resource, and they are in order by priority
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 4 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][0]['priority'] == '1' and
                    STAFResult['requestList'][1]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][1]['priority'] == '50' and
                    STAFResult['requestList'][2]['requestedEntry'] == None and STAFResult['requestList'][2]['priority'] == '50' and
                    STAFResult['requestList'][2]['requestedTimestamp'] > STAFResult['requestList'][1]['requestedTimestamp'] and
                    STAFResult['requestList'][3]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][3]['priority'] == '99' and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                   expectedResult = ''
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [\n' + \
                    '    { Priority:  1, Requested Entry: Resource1 }\n' + \
                    '    { Priority: 50, Requested Entry: Resource1 }\n' + \
                    '    { Priority: 50, Requested Entry: None }\n' + \
                    '    { Priority: 99, Requested Entry: Resource1 }\n' + \
                    '\n  Resource List:  Resource1 and Resource2 are owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'RELEASE POOL STAFTestGC ENTRY Resource1 FORCE'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource1'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there are
                 # 2 pending requests for Resource1 and 1 pending request for any resource in the correct order
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 3 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][0]['priority'] == '50' and
                    STAFResult['requestList'][1]['requestedEntry'] == None and STAFResult['requestList'][1]['priority'] == '50' and
                    STAFResult['requestList'][1]['requestedTimestamp'] > STAFResult['requestList'][0]['requestedTimestamp'] and
                    STAFResult['requestList'][2]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][2]['priority'] == '99' and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [\n' +\
                    '    { Priority: 50, Requested Entry: Resource1 }\n' + \
                    '    { Priority: 50, Requested Entry: None }\n' + \
                    '    { Priority: 99, Requested Entry: Resource1 }\n' + \
                    '\n  Resource List:  Resource1 and Resource2 are owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'RELEASE POOL STAFTestGC ENTRY Resource2 FORCE'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource2'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there are
                 # 2 pending requests for Resource1, in the correct order
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 2 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][0]['priority'] == '50' and
                    STAFResult['requestList'][1]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][1]['priority'] == '99' and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [\n' +\
                    '    { Priority: 50, Requested Entry: Resource1 }\n' + \
                    '    { Priority: 99, Requested Entry: Resource1 }\n' + \
                    '\n  Resource List:  Resource1 and Resource2 are owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                
                <script>command = 'RELEASE POOL STAFTestGC ENTRY Resource1'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource1'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there is
                 # 1 pending requests for Resource1
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 1 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][0]['priority'] == '99' and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [\n' +\
                    '    { Priority: 99, Requested Entry: Resource1 }\n' + \
                    '\n  Resource List:  Resource1 and Resource2 are owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'RELEASE POOL STAFTestGC ENTRY Resource1'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource1'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there are no pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 0 and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [ ]\n' +\
                    '\n  Resource List:  Resource1 and Resource2 are owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'RELEASE POOL STAFTestGC ENTRY Resource1'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource1'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                
                <script>command = 'RELEASE POOL STAFTestGC ENTRY Resource2'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource2'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are available and there are no pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 0 and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] == None and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner'] == None):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [ ]\n' +\
                    '\n  Resource List:  Resource1 and Resource2 are available\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'REMOVE POOL STAFTestGC ENTRY Resource1 ENTRY Resource2 CONFIRM'</script>
                <message>
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Remove Entry Resource1 and Resource2'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <!-- Clean-up the event semaphores used by this test -->
                <iterate var="i" in="range(1, 7)">
                  <stafcmd name="'Delete Event Semaphore STAFTest/Respool/Step%s' % (i)">
                    <location>TestMach</location>
                    <service>'SEM'</service>
                    <request>'DELETE EVENT STAFTest/Respool/Step%s' % (i)</request>
                  </stafcmd>
                </iterate>

                <message>'End testing the order of the Pending Requests list and that the correct resources are acquired in the correct order'</message>

              </sequence>
              </block>

            </parallel>

            <!-- End of testing the order of the Pending Requests list and that the correct resources are
                  acquired in the correct order -->

            <!-- Test cancelling pending requests --> 

            <message log="1">
              'Test the RESPOOL CANCEL request on machine %s' % (TestMach)
            </message>

            <!-- Clean up any event semaphores from a previous run -->
            <iterate var="i" in="range(1, 6)">
              <stafcmd name="'Reset Event Semaphore STAFTest/Respool/Step%s' % (i)">
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'RESET EVENT STAFTest/Respool/Step%s' % (i)</request>
              </stafcmd>
            </iterate>
            
            <!-- Add an entry to the pool so that there is 1 entry -->
            <script>command = 'ADD POOL STAFTestGC ENTRY Resource1'</script>
            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'ADD POOL STAFTestGC ENTRY Resource1'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
             { 'result': RC == STAFRC.Ok,
               'failMsg': '%s RC=%s STAFResult=%s STAXResult=%s' % (command, RC, STAFResult, STAXResult),
               'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <!-- Request the entry to the pool so that the entry is owned -->
            <script>command = 'REQUEST POOL STAFTestGC TIMEOUT 1m'</script>
            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>command</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
             { 'result': RC == STAFRC.Ok,
               'failMsg': '%s RC=%s STAFResult=%s STAXResult=%s' % (command, RC, STAFResult, STAXResult),
               'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <parallel>
              <block name="'Step 1: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step2'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'POST EVENT STAFTest/Respool/Step2'</request>
                </stafcmd>
              </sequence>
              </block>

              <block name="'Step 2: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step2'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step2 TIMEOUT 600000'</request>
                </stafcmd>
                <script>command = 'REQUEST POOL STAFTestGC'</script>
                <message log="1">'STAF %s RESPOOL %s' % (TestMach, command)</message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request any resource'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.RequestCancelled,
                       'failMsg': 'RC=%s STAFResult=%s Expected RC=%s' % (RC, STAFResult, STAFRC.RequestCancelled),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while request Resource1 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step3'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step3'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 3: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step3'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step3 TIMEOUT 600000'</request>
                </stafcmd>
                <script>command = 'REQUEST POOL STAFTestGC ENTRY Resource1 PRIORITY 99'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource1 at priority 99'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.RequestCancelled,
                       'failMsg': 'RC=%s STAFResult=%s Expected RC=%s' % (RC, STAFResult, STAFRC.RequestCancelled),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while request Resource1 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step4'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step4'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>
              
              <block name="'Step 4: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step4'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step4 TIMEOUT 600000'</request>
                </stafcmd>
                <script>command = 'REQUEST POOL STAFTestGC ENTRY Resource1 PRIORITY 30'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource1 at priority 1'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.RequestCancelled,
                       'failMsg': 'RC=%s STAFResult=%s Expected RC=%s' % (RC, STAFResult, STAFRC.RequestCancelled),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while request Resource1 at default priority 30 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step5'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step5'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 5: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step5'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step5 TIMEOUT 600000'</request>
                </stafcmd>
                <message log="1">
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 is are owned and there are 3 pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 3 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][0]['priority'] == '30' and
                    STAFResult['requestList'][1]['requestedEntry'] == None and STAFResult['requestList'][1]['priority'] == '50' and
                    STAFResult['requestList'][2]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][2]['priority'] == '99' and
                    len(STAFResult['resourceList']) == 1 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner']):
                   success = 1
                   expectedResult = ''
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [\n' + \
                    '    { Priority: 30, Requested Entry: Resource1 }\n' + \
                    '    { Priority: 50, Requested Entry: None }\n' + \
                    '    { Priority: 99, Requested Entry: Resource1 }\n' + \
                    '\n  Resource List:  Resource1 is owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>
                  command = 'SET VAR STAFTest/PoolName=STAFTestGC VAR STAFTest/ResPool/Priority=50' + \
                    ' VAR STAFTest/ResPool/Entry=Resource1' + \
                    ' VAR STAFTest/ResPool/Handle=%s VAR STAFTest/ResPool/HandleName=%s/Job/%s VAR STAFTest/ResPool/Machine=%s' % \
                    (JobHandle, STAXServiceName, STAXJobID, STAXMachine)
                </script>
                <stafcmd name="'Set variables used by the cancel respool request test'">
                  <location>TestMach</location>
                  <service>'VAR'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'CANCEL POOL {STAFTest/PoolName} PRIORITY {STAFTest/ResPool/Priority} LAST'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Cancel last pending request with priority 50 in pool STAFTestGC requested by this STAX job'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 is owned and there are 2 pending requests for Resource1
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 2 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][0]['priority'] == '30' and
                    STAFResult['requestList'][1]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][1]['priority'] == '99' and
                    len(STAFResult['resourceList']) == 1 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner']):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [\n' +\
                    '    { Priority: 30, Requested Entry: Resource1 }\n' + \
                    '    { Priority: 99, Requested Entry: Resource1 }\n' + \
                    '\n  Resource List:  Resource1 is owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'CANCEL POOL STAFTestGC ENTRY {STAFTest/ResPool/Entry} HANDLE {STAFTest/ResPool/Handle} FIRST FORCE'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Cancel first pending request for entry Resource1 in pool STAFTestGC requested by this job handle'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 and Resource2 are owned and there are
                 # 2 pending requests for Resource1, in the correct order
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 1 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource1' and STAFResult['requestList'][0]['priority'] == '99' and
                    len(STAFResult['resourceList']) == 1 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner']):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [\n' +\
                    '    { Priority: 99, Requested Entry: Resource1 }\n' + \
                    '\n  Resource List:  Resource1 is owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                
                <script>
                  command = 'CANCEL POOL STAFTestGC FORCE NAME {STAFTest/ResPool/HandleName} MACHINE {STAFTest/ResPool/Machine} PRIORITY 99'
                </script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Cancel last pending request with priority 99 in pool STAFTestGC submitted by this STAX job handle name on the STAX machine'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource1 is owned and there are no pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 0 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner']):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [ ]\n' +\
                    '\n  Resource List:  Resource1 is owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'RELEASE POOL STAFTestGC ENTRY Resource1'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource1'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that no resources are owned and there are no pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 0 and
                    len(STAFResult['resourceList']) == 1 and
                    STAFResult['resourceList'][0]['entry'] == 'Resource1' and
                    STAFResult['resourceList'][0]['owner'] == None):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [ ]\n' +\
                    '\n  Resource List:  Resource1 is not owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'CANCEL POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Cancel Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.DoesNotExist,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                 
                <script>command = 'REMOVE POOL STAFTestGC ENTRY Resource1 CONFIRM'</script>
                <message>
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Remove Entry Resource1'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <!-- Clean-up the event semaphores used by this test -->
                <iterate var="i" in="range(1, 6)">
                  <stafcmd name="'Delete Event Semaphore STAFTest/Respool/Step%s' % (i)">
                    <location>TestMach</location>
                    <service>'SEM'</service>
                    <request>'DELETE EVENT STAFTest/Respool/Step%s' % (i)</request>
                  </stafcmd>
                </iterate>

                <!--- Clean up the variables used by this test -->
                <script>
                  command = 'DELETE VAR STAFTest/PoolName VAR STAFTest/ResPool/Priority' + \
                    ' VAR STAFTest/ResPool/Entry VAR STAFTest/ResPool/Handle' + \
                    ' VAR STAFTest/ResPool/HandleName VAR STAFTest/ResPool/Machine'
                </script>
                <stafcmd name="'Delete variables used by the cancel respool request test'">
                  <location>TestMach</location>
                  <service>'VAR'</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <message>'End testing the RESPOOL CANCEL requestr'</message>

              </sequence>
              </block>

            </parallel>

            <!-- End testing cancelling pending requests -->

            <!-- Begin testing RELEASE option for REQUEST ENTRY -->

            <message log="1">
              'Test the RELEASE option for REQUEST ENTRY on machine %s' % (TestMach)
            </message>

            <!-- Clean up any event semaphores from a previous run -->
            <iterate var="i" in="range(1, 5)">
              <stafcmd name="'Reset Event Semaphore STAFTest/Respool/Step%s' % (i)">
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'RESET EVENT STAFTest/Respool/Step%s' % (i)</request>
              </stafcmd>
            </iterate>
            
            <!-- Put 2 entries in the pool -->

            <script>command = 'ADD POOL STAFTestGC ENTRY Resource1'</script>
            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'ADD POOL STAFTestGC ENTRY Resource1'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
             { 'result': RC == STAFRC.Ok,
               'failMsg': '%s RC=%s STAFResult=%s STAXResult=%s' % (command, RC, STAFResult, STAXResult),
               'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <script>command = 'ADD POOL STAFTestGC ENTRY Resource2'</script>
            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'ADD POOL STAFTestGC ENTRY Resource2'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
             { 'result': RC == STAFRC.Ok,
               'failMsg': '%s RC=%s STAFResult=%s STAXResult=%s' % (command, RC, STAFResult, STAXResult),
               'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

            <parallel>
              <block name="'Step 1: RESPOOL Entry Test'">
              <sequence>
                <script>command = 'REQUEST POOL STAFTestGC ENTRY Resource2'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Request Resource2 at default priority 50'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok and STAFResult == 'Resource2',
                   'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource2' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step2'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'POST EVENT STAFTest/Respool/Step2'</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
              </sequence>
              </block>

              <block name="'Step 2: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step2'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step2 TIMEOUT 600000'</request>
                </stafcmd>
                <script>command = 'REQUEST POOL STAFTestGC ENTRY Resource2'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource2 at default priority 50'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok and STAFResult == 'Resource2',
                       'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource2' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while request Resource2 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step3'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step3'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 3: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step3'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step3 TIMEOUT 600000'</request>
                </stafcmd>
                <script>command = 'REQUEST POOL STAFTestGC ENTRY Resource2 RELEASE PRIORITY 25'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <parallel>
                  <sequence>
                    <stafcmd name="'Request Resource2 using RELEASE option at priority 25'">
                      <location>TestMach</location>
                      <service>ResPoolService</service>
                      <request>command</request>
                    </stafcmd>
                    <call function="'STAXUtilCheckSuccess'">
                     { 'result': RC == STAFRC.Ok and STAFResult == 'Resource2',
                       'failMsg': 'RC=%s STAFResult=%s Expected STAFResult: Resource2' % (RC, STAFResult),
                       'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                  <sequence>
                    <stafcmd name="'Delay for 5 seconds while request Resource2 with RELEASE option at priority 25 is submitted'">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 5s'</request>
                    </stafcmd>
                    <stafcmd name="'Post Event Semaphore STAFTest/Respool/Step4'">
                      <location>TestMach</location>
                      <service>'SEM'</service>
                      <request>'POST EVENT STAFTest/Respool/Step4'</request>
                    </stafcmd>
                  </sequence>
                </parallel>
              </sequence>
              </block>

              <block name="'Step 4: RESPOOL Entry Test'">
              <sequence>
                <stafcmd name="'Wait for Event Semaphore STAFTest/Respool/Step4'">
                  <location>TestMach</location>
                  <service>'SEM'</service>
                  <request>'WAIT EVENT STAFTest/Respool/Step4 TIMEOUT 600000'</request>
                </stafcmd>
                <message log="1">
                  'STAF %s RESPOOL QUERY POOL STAFTestGC' % (TestMach)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>'QUERY POOL STAFTestGC'</request>
                </stafcmd>
                <script>
                 # Verify that Resource2 is owned and there is 1 pending request for Resource2
                 # with priority 50
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 1 and
                    STAFResult['requestList'][0]['requestedEntry'] == 'Resource2' and STAFResult['requestList'][0]['priority'] == '50' and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                   expectedResult = ''
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  [\n' + \
                    '    { Priority: 50, Requested Entry: Resource2 }\n' + \
                    '    ]\n' + \
                    '\n  Resource List:  Resource1 is not owned and Resource2 is owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'RELEASE POOL STAFTestGC ENTRY Resource2'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource2'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource2 is owned and there are no pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 0 and
                    len(STAFResult['resourceList']) == 2 and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner']):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  []\n' +\
                    '\n  Resource List:  Resource1 is not owned and Resource2 is owned\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'Expected RC=0 Got RC=%s\nExpected STAFResult:\n %s,\nGot STAFResult=\n%s' % \
                                (RC, expectedResult, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'RELEASE POOL STAFTestGC ENTRY Resource2'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Release Pool STAFTestGC Entry Resource2'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == STAFRC.Ok,
                  'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'QUERY POOL STAFTestGC'</script>
                <message log="1">
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Query Pool STAFTestGC'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <script>
                 # Verify that Resource2 is not owned and there are 0 pending requests
                 if (RC == STAFRC.Ok and
                    len(STAFResult['requestList']) == 0 and
                    STAFResult['resourceList'][1]['entry'] == 'Resource2' and
                    STAFResult['resourceList'][1]['owner'] == None):
                   success = 1
                 else:
                   success = 0
                   expectedResult = '{\n  Pending Requests:  []\n' +\
                    '\n  Resource List:  Resource1 and Resource2 are available\n}'
                </script>
                <call function="'STAXUtilCheckSuccess'">
                { 'result': success == 1,
                  'failMsg': 'RC=%s STAFResult=\n%s' % (RC, STAFResultContext),
                  'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <script>command = 'REMOVE POOL STAFTestGC ENTRY Resource1 ENTRY Resource2 CONFIRM'</script>
                <message>
                  'STAF %s RESPOOL %s' % (TestMach, command)
                </message>
                <stafcmd name="'Remove Entry Resource1 and Resource2'">
                  <location>TestMach</location>
                  <service>ResPoolService</service>
                  <request>command</request>
                </stafcmd>
                <call function="'STAXUtilCheckSuccess'">
                 { 'result': RC == STAFRC.Ok,
                   'failMsg': 'RC=%s STAFResult=%s' % (RC, STAFResult),
                   'sendToMonitor': 1, 'recordStatus': 1 }
                </call>

                <!-- Clean-up the event semaphores used by this test -->
                <iterate var="i" in="range(1, 5)">
                  <stafcmd name="'Delete Event Semaphore STAFTest/Respool/Step%s' % (i)">
                    <location>TestMach</location>
                    <service>'SEM'</service>
                    <request>'DELETE EVENT STAFTest/Respool/Step%s' % (i)</request>
                  </stafcmd>
                </iterate>

                <message>'End testing RELEASE option for REQUEST ENTRY'</message>

              </sequence>
              </block>

            </parallel>


            <!-- End testing RELEASE option for REQUEST ENTRY -->

            <message>
              'STAF %s RESPOOL DELETE POOL STAFTestGC CONFIRM FORCE' % (TestMach)
            </message>

            <stafcmd>
              <location>TestMach</location>
              <service>ResPoolService</service>
              <request>'DELETE POOL STAFTestGC CONFIRM FORCE'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC in [ STAFRC.Ok ],
                'failMsg': 'STAF %s RESPOOL DELETE POOL STAFTestGC CONFIRM FORCE RC=%s  STAFResult=%s' % (TestMach, RC, STAFResult),
                'sendToMonitor': 1, 'recordStatus': 1 }
            </call>

          </sequence>
        </testcase>

      <script>

      RESPOOLTests = [

        #
        #RESPOOL tests
        #

        [ 'STD:RESPOOL', 'SEM',     'REQUEST MUTEX STAFTest/RESPOOL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:RESPOOL', ResPoolService, 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'VERSION',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:RESPOOL', 'VAR',     'SET VAR STAFTest/PoolName=STAFTest VAR "STAFTest/PoolDesc=STAF Test Pool" VAR STAFTest/Timeout=5000 VAR STAFTest/GC=No',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'CREATE POOL {STAFTest/PoolName} DESCRIPTION "{STAFTest/PoolDesc}"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'QUERY POOL {StafTest/PoolName}',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'STAF Test Pool' and " +
          "len(STAFResult['requestList']) == 0 and " +
          "len(STAFResult['resourceList']) == 0"
        ],

        [ 'STD:RESPOOL', ResPoolService, 'ADD POOL {STAFTest/PoolName} ENTRY Resource1 ENTRY Resource2 ENTRY Resource3',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'QUERY POOL {StafTest/PoolName}',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'STAF Test Pool' and " +
          "len(STAFResult['requestList']) == 0 and " +
          "len(STAFResult['resourceList']) == 3 and " +
          "STAFResult['resourceList'][0]['entry'] == 'Resource1' and " +
          "STAFResult['resourceList'][0]['owner'] == None and " +
          "STAFResult['resourceList'][1]['entry'] == 'Resource2' and " +
          "STAFResult['resourceList'][1]['owner'] == None and " +
          "STAFResult['resourceList'][2]['entry'] == 'Resource3' and " +
          "STAFResult['resourceList'][2]['owner'] == None"
        ],

        [ 'STD:RESPOOL', ResPoolService, 'CREATE POOL StAfTeSt DESCRIPTION "My new pool description"',
          [ STAFRC.AlreadyExists ], 'StAfTeSt'
        ],

        # Test creating a resource pool name using characters (e.g. : and / on Windows and / on Unix)
        # that are not allowed in a pool name
        [ 'STD:RESPOOL', ResPoolService, 'CREATE POOL "Pool:Version/1" DESCRIPTION "My new pool description"',
          [ STAFRC.InvalidValue ], r'.*'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'ADD POOL {STAFTest/PoolName} ENTRY Resource2 ENTRY Resource3',
          [ STAFRC.AlreadyExists ], 'Resource2'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REMOVE POOL {STAFTest/PoolName} ENTRY Resource2 ENTRY Resource3 CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'QUERY POOL {StafTest/PoolName}',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'STAF Test Pool' and " +
          "len(STAFResult['requestList']) == 0 and " +
          "len(STAFResult['resourceList']) == 1 and " +
          "STAFResult['resourceList'][0]['entry'] == 'Resource1' and " +
          "STAFResult['resourceList'][0]['owner'] == None"
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REMOVE POOL {STAFTest/PoolName} ENTRY Resource2 CONFIRM',
          [ STAFRC.DoesNotExist ], 'Resource2'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName}',
          [ STAFRC.Ok ], 'Resource1'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} TIMEOUT {STAFTest/Timeout} RANDOM',
          [ STAFRC.Timeout ], None
        ],

        [ 'STD:RESPOOL', ResPoolService, 'RELEASE POOL {STAFTest/PoolName} ENTRY Resource1',
         [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL StAfTeSt FIRST',
          [ STAFRC.Ok ], 'Resource1'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL DoesNotExist',
          [ STAFRC.DoesNotExist ],
          r"""(?mx)
              ^.*?DoesNotExist.*?\s*"""
        ],

        [ 'STD:RESPOOL', ResPoolService, 'QUERY POOL {StafTest/PoolName}',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'STAF Test Pool' and " +
          "len(STAFResult['requestList']) == 0 and " +
          "len(STAFResult['resourceList']) == 1 and " +
          "STAFResult['resourceList'][0]['entry'] == 'Resource1' and " +
          "STAFResult['resourceList'][0]['owner'] and " +
          "STAFResult['resourceList'][0]['owner']['machine'] and " +
          "STAFResult['resourceList'][0]['owner']['handle'] and " +
          "STAFResult['resourceList'][0]['owner']['handleName'] and " +
          "STAFResult['resourceList'][0]['owner']['user'] and " +
          "STAFResult['resourceList'][0]['owner']['endpoint'].find('://') != -1 and " +
          "STAFResult['resourceList'][0]['owner']['requestedTimestamp'] and " +
          "STAFResult['resourceList'][0]['owner']['acquiredTimestamp'] and " +
          "STAFResult['resourceList'][0]['owner'].has_key('gc') and STAFResult['resourceList'][0]['owner']['gc'] == 'Yes'"
        ],

        [ 'STD:RESPOOL', ResPoolService, 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and STAFResult[0]['poolName'] and STAFResult[0]['description']"
        ],

        # Release entry Resource1 and  request entry Resource1 with garbage collection, and query to make sure that gc == 'No'
        
        [ 'STD:RESPOOL', ResPoolService, 'RELEASE POOL {STAFTest/PoolName} ENTRY Resource1',
         [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} GARBAGECOLLECT',
          [ STAFRC.InvalidRequestString ], None
        ],
        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} GARBAGECOLLECT {STAFTest/GC}',
          [ STAFRC.Ok ], 'Resource1'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'QUERY POOL {StafTest/PoolName}',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'STAF Test Pool' and " +
          "len(STAFResult['requestList']) == 0 and " +
          "len(STAFResult['resourceList']) == 1 and " +
          "STAFResult['resourceList'][0]['entry'] == 'Resource1' and " +
          "STAFResult['resourceList'][0]['owner'] and " +
          "STAFResult['resourceList'][0]['owner']['machine'] and " +
          "STAFResult['resourceList'][0]['owner']['handle'] and " +
          "STAFResult['resourceList'][0]['owner']['handleName'] and " +
          "STAFResult['resourceList'][0]['owner']['user'] and " +
          "STAFResult['resourceList'][0]['owner']['endpoint'].find('://') != -1 and " +
          "STAFResult['resourceList'][0]['owner']['requestedTimestamp'] and " +
          "STAFResult['resourceList'][0]['owner']['acquiredTimestamp'] and " +
          "STAFResult['resourceList'][0]['owner'].has_key('gc') and STAFResult['resourceList'][0]['owner']['gc'] == 'No'"
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REMOVE POOL {STAFTest/PoolName} ENTRY Resource1 CONFIRM',
          [ 4010 ],
          r"""(?mx)
              ^.*?Resource1*?\s*"""
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REMOVE POOL {STAFTest/PoolName} ENTRY Resource1 CONFIRM FORCE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'QUERY POOL {StafTest/PoolName}',
          [ STAFRC.Ok ], None,
          "STAFResult['description'] == 'STAF Test Pool' and " +
          "len(STAFResult['requestList']) == 0 and " +
          "len(STAFResult['resourceList']) == 0"
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName}',
          [ 4007 ], None
        ],

        [ 'STD:RESPOOL', ResPoolService, 'ADD POOL {STAFTest/PoolName} ENTRY Resource1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName}',
          [ STAFRC.Ok ], 'Resource1'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'DELETE POOL {STAFTest/PoolName} CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'QUERY POOL {StafTest/PoolName}',
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:RESPOOL', ResPoolService, 'DELETE POOL {STAFTest/PoolName} CONFIRM FORCE',
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # Test requesting a specific entry from a resource pool
        
        [ 'STD:RESPOOL', ResPoolService, 'CREATE POOL {STAFTest/PoolName} DESCRIPTION "{STAFTest/PoolDesc}"',
          [ STAFRC.Ok ], r'^$'
        ],

        ['STD:RESPOOL', ResPoolService, 'ADD POOL {STAFTest/PoolName} ENTRY Resource1',
          [ STAFRC.Ok ], r'^$'
        ],

        ['STD:RESPOOL', ResPoolService, 'ADD POOL {STAFTest/PoolName} ENTRY Resource2',
          [ STAFRC.Ok ], r'^$'
        ],

        ['STD:RESPOOL', ResPoolService, 'ADD POOL {STAFTest/PoolName} ENTRY Resource3',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2',
          [ STAFRC.Ok ], 'Resource2'
        ],

        # Test the RELEASE option when request a specific entry from a resource pool

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 RELEASE',
          [ STAFRC.Ok ], 'Resource2'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 RELEASE PRIORITY 25',
          [ STAFRC.Ok ], 'Resource2'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource1 RELEASE',
          [ 4005 ], r'.*'
        ],
        
        # Test using the PRIORITY option on a request

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource3 PRIORITY 0',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource3 PRIORITY 100',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:RESPOOL', 'VAR',     'SET VAR STAFTest/ResPool/Priority=1',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource3 PRIORITY {STAFTest/ResPool/Priority}',
          [ STAFRC.Ok ], 'Resource3'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY DoesNotExist',
          [ STAFRC.DoesNotExist ], None
        ],
        
        [ 'STD:RESPOOL', ResPoolService, 'QUERY POOL {StafTest/PoolName}',
          [ STAFRC.Ok ], None,
          "len(STAFResult['requestList']) == 0 and " +
          "len(STAFResult['resourceList']) == 3 and " +
          "STAFResult['resourceList'][0]['entry'] == 'Resource1' and " +
          "STAFResult['resourceList'][0]['owner'] == None and " +
          "STAFResult['resourceList'][1]['entry'] == 'Resource2' and " +
          "STAFResult['resourceList'][1]['owner'] and " +
          "STAFResult['resourceList'][2]['entry'] == 'Resource3' and " +
          "STAFResult['resourceList'][2]['owner']"
        ],

        [ 'STD:RESPOOL', ResPoolService, 'RELEASE POOL {STAFTest/PoolName} ENTRY Resource2',
         [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 TIMEOUT',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 TIMEOUT XXX',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 TIMEOUT 999999999999999999999999',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 TIMEOUT 9999999w',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 TIMEOUT 1sec',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 TIMEOUT {STAFTest/DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 TIMEOUT 1s',
          [ STAFRC.Ok ], 'Resource2'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'RELEASE POOL {STAFTest/PoolName} ENTRY Resource2',
         [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'REQUEST POOL {STAFTest/PoolName} ENTRY Resource2 TIMEOUT 0w',
          [ STAFRC.Ok ], 'Resource2'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'RELEASE POOL {STAFTest/PoolName} ENTRY Resource2',
         [ STAFRC.Ok ], r'^$'
        ],

        # Test for expected errors on a CANCEL request
        [ 'STD:RESPOOL', ResPoolService, 'CANCEL POOL {STAFTest/PoolName} PRIORITY 0',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'CANCEL POOL {STAFTest/PoolName} PRIORITY 100',
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'CANCEL POOL {STAFTest/PoolName} PRIORITY {DoesNotExist}',
          [ STAFRC.VariableDoesNotExist ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'CANCEL POOL {STAFTest/PoolName} FORCE HANDLE 1 NAME MyHandle',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'CANCEL POOL {STAFTest/PoolName} HANDLE 1',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'CANCEL POOL {STAFTest/PoolName} NAME MyHandle',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'CANCEL POOL {STAFTest/PoolName} FIRST LAST',
          [ STAFRC.InvalidRequestString ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'CANCEL POOL {STAFTest/PoolName}',
          [ STAFRC.DoesNotExist ], r'.*'
        ],
        [ 'STD:RESPOOL', ResPoolService, 'CANCEL POOL {STAFTest/PoolName} ENTRY DoesNotExist',
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # Note: Removing an owned entry (Resource3) with garbage collection enabled should remove the GC notification
        [ 'STD:RESPOOL', ResPoolService, 'REMOVE POOL {STAFTest/PoolName} ENTRY Resource1 ENTRY Resource2 ENTRY Resource3 CONFIRM FORCE',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', ResPoolService, 'DELETE POOL {STAFTest/PoolName} CONFIRM',
          [ STAFRC.Ok ], r'^$'
        ],

        # Perform clean-up

        [ 'STD:RESPOOL', 'VAR',     'DELETE VAR STAFTest/PoolName VAR STAFTest/PoolDesc VAR STAFTest/Timeout VAR STAFTest/GC VAR STAFTest/ResPool/Priority',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:RESPOOL', 'SEM',     'RELEASE MUTEX STAFTest/RESPOOL',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>RESPOOLTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitZIPTests - This function initializes all the ZIP test information      -->
  <!-- ========================================================================== -->

  <function name="InitZIPTests" scope="local">
    <sequence>

      <script>

      zipFile = '{STAF/DataDir}/user/STAFTest.zip'
      fileName1 = '{STAF/DataDir}/user/zipTestFile1.txt'
      fileName2 = '{STAF/DataDir}/user/zipTestFile2.txt'
      fileName3 = '{STAF/DataDir}/user/zipTestFile3.txt'
      excludePrefix = '{STAF/DataDir}/user'
      dirName1 = '{STAF/DataDir}/user/zipTest'
      fileName1Dir1 = '%s/test1.txt' % (dirName1)
      fileName2Dir1 = '%s/test2.htm' % (dirName1)
      noExistFileName = '{STAF/DataDir}/user/nonExistingFile'
      noExistDirName = '{STAF/DataDir}/user/nonExistingDir'
      dirName2 = '{STAF/DataDir}/user/zipTest2'
      dirName3 = '{STAF/DataDir}/user/zipTest3/subdir1'
      relativeToDir = '{STAF/DataDir}/user/'
      toDirName = '{STAF/DataDir}/user/STAFTestZip'

      if TestMachOSType.find('Win') == 0 or TestMachOSType.find('Unknown Win') == 0:
        # Windows - Remove drive letter, colon, and '/' from the file and directory names to be deleted from zip file
        deleteDir = TestMachUserDataDir[3:]

        jarFile = '{STAF/Config/STAFRoot}/bin/JSTAF.jar'
      else:
        # Unix - Remove the leading '/' from the file/directory name to be deleted
        deleteDir = TestMachUserDataDir[1:]
        jarFile = '{STAF/Config/STAFRoot}/lib/JSTAF.jar'

      deleteDir1 = '%s/zipTest' % (deleteDir)
      deleteFile1Dir1 = '%s/test1.txt' % (deleteDir1)
      deleteFile2Dir1 = '%s/test2.htm' % (deleteDir1)
      deleteDir3      = '%s/zipTest3/subdir1/' % (deleteDir)
      deleteFile2     = '%s/zipTestFile2.txt' % (deleteDir)
      deleteFile3     = '%s/zipTestFile3.txt' % (deleteDir)
      listDir  = '%s/%s' % (toDirName, deleteDir)
      listDir1 = '%s/zipTest' % (listDir)

      </script>

      <if expr="TestMachJavaSupport">
        <sequence>
          <!-- Make sure that the jarFile exists.  If it doesn't try the one in the lib directory -->

          <stafcmd>
            <location>TestMach</location>
            <service>'FS'</service>
            <request>'QUERY ENTRY %s' % (jarFile)</request>
          </stafcmd>

          <if expr="RC != STAFRC.Ok">
            <script>jarFile = '{STAF/Config/STAFRoot}/lib/JSTAF.jar'</script>
          </if>
        </sequence>
        <else>
          <sequence>
            
            <!-- Copy the JSTAF.jar file from the local STAX Service machine to the Test Machine -->

            <log message="1">
              'No JSTAF.jar on test machine.  Copy JSTAF.jar from local STAX service machine to test machine.'
            </log>

            <script>
            if STAXMachOSType.find('Win') == 0 or STAXMachOSType.find('Unknown Win') == 0:
              localJarFile = '{STAF/Config/STAFRoot}/bin/JSTAF.jar'
            else:
              localJarFile = '{STAF/Config/STAFRoot}/lib/JSTAF.jar'
            </script>

            <!-- Make sure that the local jarFile exists.  If it doesn't try the one in the lib directory -->

            <stafcmd>
              <location>'local'</location>
              <service>'FS'</service>
              <request>'QUERY ENTRY %s' % (localJarFile)</request>
            </stafcmd>

            <if expr="RC != STAFRC.Ok">
              <script>localJarFile = '{STAF/Config/STAFRoot}/lib/JSTAF.jar'</script>
            </if>

            <script>
            request = 'COPY FILE %s TOFILE %s TOMACHINE %s' % (localJarFile, jarFile, TestMach)
            </script>

            <stafcmd>
              <location>'local'</location>
              <service>'FS'</service>
              <request>request</request>
            </stafcmd>

            <if expr="RC != STAFRC.Ok">
              <log message="1" level="'error'">
               'STAF local FS %s failed with RC=%s STAFResult=%s' % (request, RC, STAFResult)
              </log>
            </if>

          </sequence>
        </else>
      </if>

      <script>
      ZIPTests = [

        #
        # ZIP tests
        #

        [ 'STD:ZIP', 'SEM',  'REQUEST MUTEX STAFTest/ZIP',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', ZipService,  'HELP',
          [ STAFRC.Ok ], r'.*'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:ZIP', ZipService, 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:ZIP', ZipService,  'VERSION',
          [ STAFRC.Ok ], r'.*'
        ],

        # Prepare - make sure zipfile to be created doesn't exist and non-existing files and directories don't exist
        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s CONFIRM' % (zipFile),
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s CONFIRM' % (noExistFileName),
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (noExistDirName),
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (toDirName),
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        # Create files and directories to be zipped
        [ 'STD:ZIP', 'FS',   'COPY FILE {STAF/Config/ConfigFile} TOFILE %s TOMACHINE %s' % (fileName1, TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', 'FS',   'COPY FILE {STAF/Config/ConfigFile} TOFILE %s TOMACHINE %s' % (fileName2, TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', 'FS',   'COPY FILE {STAF/Config/ConfigFile} TOFILE %s TOMACHINE %s' % (fileName3, TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (dirName1),
          [ STAFRC.Ok, STAFRC.DoesNotExist ], None
        ],

        [ 'STD:ZIP', 'FS',   'CREATE DIRECTORY %s' % (dirName1),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', 'FS',   'COPY FILE {STAF/Config/ConfigFile} TOFILE %s TOMACHINE %s' % (fileName1Dir1, TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', 'FS',   'COPY FILE {STAF/Config/ConfigFile} TOFILE %s TOMACHINE %s' % (fileName2Dir1, TestMach),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', 'FS',   'CREATE DIRECTORY %s' % (dirName2),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', 'FS',   'CREATE DIRECTORY %s FULLPATH' % (dirName3),
          [ STAFRC.Ok ], r'^$'
        ],

        # List a jar file that was created without using Java jar cf
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (jarFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['length'] and STAFResult[0]['method'] and " +
          "STAFResult[0]['size'] and STAFResult[0]['ratio'] and " +
          "STAFResult[0]['date'] and STAFResult[0]['time'] and " +
          "STAFResult[0]['crc-32'] and STAFResult[0]['name']"
        ],

        # Unzip a JAR file to make sure it is not zero length
        [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s' % (jarFile, toDirName), [ 0 ], r'^$' ]

      ]
      </script>

      <if expr="TestMachOSType.find('OS/390') != 0">
        <script>
          # XXX: Certain ZIP tests fail on z/OS and z/OS 64-bit because it doesn't handle zip files
          # on other platforms or by other zip utilities.

          ZIPTests = ZIPTests + [

          [ 'STD:ZIP', 'FS',   'QUERY ENTRY %s/com/ibm/staf/STAFUtil.class' % (toDirName),
            [ STAFRC.Ok ], None,
            "STAFResult['name'] and " +
            "STAFResult['linkTarget'] == None and " +
            "STAFResult['type'] == 'F' and " +
            "int(STAFResult['size']) > 0 and " +
            "STAFResult['lastModifiedTimestamp']"
          ]
        ]
        </script>
      </if>

      <script>

        ZIPTests = ZIPTests + [

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (toDirName),
          [ STAFRC.Ok ], None
        ],

        # Create a zipfile
        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s FILE %s RELATIVETO %s' % (zipFile, fileName1, excludePrefix),
          [ STAFRC.Ok ], r'^$'
        ],

        # List the zipfile to verify that it added the file
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (zipFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['length'] and STAFResult[0]['method'] and " +
          "STAFResult[0]['size'] and STAFResult[0]['ratio'] and " +
          "STAFResult[0]['date'] and STAFResult[0]['time'] and " +
          "STAFResult[0]['crc-32'] and STAFResult[0]['name'] == 'zipTestFile1.txt'"
        ],

        # Type adding the name of the zip file being created and verify get an error
        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s FILE %s RELATIVETO %s' % (zipFile, zipFile, excludePrefix),
          [ STAFRC.InvalidValue ], r'.*'
        ],
        
        # Type adding the name of the zip file being created and verify get an error
        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s FILE %s' % (zipFile, zipFile),
          [ STAFRC.InvalidValue ], r'.*'
        ],

        # Try adding a non-existing file name - should get RC STAFRC.DoesNotExist
        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s FILE %s' % (zipFile, noExistFileName),
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # Try adding a non-existing directory name - should get RC STAFRC.DoesNotExist
        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s DIRECTORY %s' % (zipFile, noExistDirName),
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # Try listing a non-existing zipfile name - should get RC STAFRC.DoesNotExist
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (noExistFileName),
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # Try unzipping a non-existing zipfile name - should get RC STAFRC.DoesNotExist
        [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s' % (noExistFileName, toDirName),
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # The unzip request should not create the non-existing zipfile
        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s CONFIRM' % (noExistFileName),
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # The invalid unzip request should not create the to directory
        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (toDirName),
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # Try unzipping a non-existing file name - should get RC STAFRC.DoesNotExist
        [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s FILE %s' % (zipFile, toDirName, noExistFileName),
          [ STAFRC.DoesNotExist ], r'.*'
        ],
        
        # Try unzipping a non-existing directory name - should get RC STAFRC.DoesNotExist
        [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s DIRECTORY %s' % (zipFile, toDirName, noExistDirName),
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # Try deleting a file without specifying the CONFIRM option - should get RC 7
        [ 'STD:ZIP', ZipService,  'DELETE ZIPFILE %s FILE %s' % (zipFile, fileName1),
          [ STAFRC.InvalidRequestString ], r'.*'
        ],

        # Try deleting a non-existing zipfile name - should get RC STAFRC.DoesNotExist
        [ 'STD:ZIP', ZipService,  'DELETE ZIPFILE %s FILE %s CONFIRM' % (noExistFileName, fileName1),
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        # Try deleting a non-existing file name - should get RC STAFRC.DoesNotExist
        [ 'STD:ZIP', ZipService,  'DELETE ZIPFILE %s FILE %s CONFIRM' % (zipFile, noExistDirName),
          [ STAFRC.DoesNotExist ], r'.*'
        ],

        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s DIRECTORY %s' % (zipFile, dirName1),
          [ STAFRC.Ok ], r'.*'
        ],

        # List the zipfile to verify that it added the directory
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (zipFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "(STAFResult[0]['name'] == 'zipTestFile1.txt' and " +
          "(STAFResult[1]['name'].find('/zipTest/test1.txt') > 0 or STAFResult[1]['name'].find('/zipTest/test2.htm') > 0) and " +
          "(STAFResult[2]['name'].find('/zipTest/test2.htm') > 0 or STAFResult[2]['name'].find('zipTest/test1.txt') > 0))"
        ],

        # Verify can't specify RECURSE when specifying the FILE OPTION
        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s FILE %s RECURSE' % (zipFile, fileName3),
          [ STAFRC.InvalidRequestString ], r'.*'
        ],

        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s FILE %s' % (zipFile, fileName3),
          [ STAFRC.Ok ], r'.*'
        ],

        # List the zipfile to verify that it added the file
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (zipFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 4 and " +
          "STAFResult[0]['name'] == 'zipTestFile1.txt' and " +
          "(STAFResult[1]['name'].find('/zipTest/test1.txt') > 0 or STAFResult[1]['name'].find('/zipTest/test2.htm') > 0) and " +
          "(STAFResult[2]['name'].find('/zipTest/test2.htm') > 0 or STAFResult[2]['name'].find('zipTest/test1.txt') > 0) and " +
          "STAFResult[3]['name'].find('zipTestFile3.txt') > 0"
        ],

        # Verify that the deprecated ZIP ADD request works
        [ 'STD:ZIP', ZipService,  'ZIP ADD ZIPFILE %s FILE %s' % (zipFile, fileName2),
          [ STAFRC.Ok ], r'.*'
        ],

        # List the zipfile to verify that it added the file
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (zipFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 5 and " +
          "STAFResult[0]['name'] == 'zipTestFile1.txt' and " +
          "(STAFResult[1]['name'].find('/zipTest/test1.txt') > 0 or STAFResult[1]['name'].find('/zipTest/test2.htm') > 0) and " +
          "(STAFResult[2]['name'].find('/zipTest/test2.htm') > 0 or STAFResult[2]['name'].find('zipTest/test1.txt') > 0) and " +
          "STAFResult[3]['name'].find('zipTestFile3.txt') > 0 and " +
          "STAFResult[4]['name'].find('zipTestFile2.txt') > 0"
        ],

        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s DIRECTORY %s RECURSE RELATIVETO %s' % (zipFile, dirName3, relativeToDir),
          [ STAFRC.Ok ], r'.*'
        ],

        # List the zipfile to verify that it added the directory and its subdirectory
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (zipFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 6 and " +
          "STAFResult[0]['name'] == 'zipTestFile1.txt' and " +
          "(STAFResult[1]['name'].find('/zipTest/test1.txt') > 0 or STAFResult[1]['name'].find('/zipTest/test2.htm') > 0) and " +
          "(STAFResult[2]['name'].find('/zipTest/test2.htm') > 0 or STAFResult[2]['name'].find('zipTest/test1.txt') > 0) and " +
          "STAFResult[3]['name'].find('zipTestFile3.txt') > 0 and " +
          "STAFResult[4]['name'].find('zipTestFile2.txt') > 0 and " +
          "STAFResult[5]['name'] == 'zipTest3/subdir1/' and " +
          "STAFResult[5]['crc-32'] == '00000000'"
        ],

        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s DIRECTORY %s RECURSE' % (zipFile, dirName2),
          [ STAFRC.Ok ], r'.*'
        ],

        # List the zipfile to verify that it added the directory (shows them in the order added)
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (zipFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 7 and " +
          "STAFResult[0]['name'] == 'zipTestFile1.txt' and " +
          "(STAFResult[1]['name'].find('/zipTest/test1.txt') > 0 or STAFResult[1]['name'].find('/zipTest/test2.htm') > 0) and " +
          "(STAFResult[2]['name'].find('/zipTest/test2.htm') > 0 or STAFResult[2]['name'].find('zipTest/test1.txt') > 0) and " +
          "STAFResult[3]['name'].find('zipTestFile3.txt') > 0 and " +
          "STAFResult[4]['name'].find('zipTestFile2.txt') > 0 and " +
          "STAFResult[5]['name'] == 'zipTest3/subdir1/' and " +
          "STAFResult[5]['crc-32'] == '00000000' and " +
          "STAFResult[6]['name'].find('/zipTest2/') > 0 and " +
          "STAFResult[6]['crc-32'] == '00000000'"
        ],

        # Add an empty directory to the zipfile and specify the same relative path name as the path of the
        # empty directory to add.  Should return 4001 since there's nothing to add in this case
        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s DIRECTORY %s RECURSE RELATIVETO %s' % (zipFile, dirName3, dirName3),
          [ 4001 ], r'.*'
        ],
        
        # Add an empty directory to a zipfile that is in the directory being added and specify the same relative path name as the path of the
        # empty directory to add.  Should return 4001 since there's nothing to add in this case since it should ignore the zipfile created in
        # the directory being added.
        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s/STAFTest.zip DIRECTORY %s RECURSE RELATIVETO %s' % (dirName3, dirName3, dirName3),
          [ 4001 ], r'.*'
        ],

        # Try deleting a file name from the zipfile
        [ 'STD:ZIP', ZipService,  'DELETE ZIPFILE %s FILE zipTestFile1.txt CONFIRM' % (zipFile),
          [ STAFRC.Ok ], r'^$'
        ],

        # List the zipfile to verify that it deleted the file
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (zipFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 6 and " +
          "(STAFResult[0]['name'].find('/zipTest/test1.txt') > 0 or STAFResult[0]['name'].find('/zipTest/test2.htm') > 0) and " +
          "(STAFResult[1]['name'].find('/zipTest/test2.htm') > 0 or STAFResult[1]['name'].find('zipTest/test1.txt') > 0) and " +
          "STAFResult[2]['name'].find('zipTestFile3.txt') > 0 and " +
          "STAFResult[3]['name'].find('zipTestFile2.txt') > 0 and " +
          "STAFResult[4]['name'] == 'zipTest3/subdir1/' and " +
          "STAFResult[4]['crc-32'] == '00000000' and " +
          "STAFResult[5]['name'].find('/zipTest2/') > 0 and " +
          "STAFResult[5]['crc-32'] == '00000000'"
        ],

        [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s' % (zipFile, toDirName),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s' % (zipFile, toDirName),
          [ STAFRC.AlreadyExists ], r'.*'
        ],

        [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s RESTOREPERMISSION REPLACE' % (zipFile, toDirName),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', 'FS',   'LIST DIRECTORY %s SORTBYNAME' % (toDirName),
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 2 and " +
          "STAFResult[1] == 'zipTest3'"
        ],

        [ 'STD:ZIP', 'FS',   'LIST DIRECTORY %s/zipTest3/subdir1 SORTBYNAME' % (toDirName),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:ZIP', 'FS',   'LIST DIRECTORY %s SORTBYNAME' % (listDir1),
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 2 and " +
          "STAFResult[0] ==  'test1.txt' and " +
          "STAFResult[1] ==  'test2.htm'"
        ],

        # Deleting multiple files from the zipfile
        [ 'STD:ZIP', ZipService,  'DELETE ZIPFILE %s FILE %s FILE %s FILE %s FILE %s CONFIRM' % (zipFile, deleteFile3, deleteFile1Dir1, deleteFile2Dir1, deleteFile2),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:ZIP', 'FS',   'LIST DIRECTORY %s SORTBYNAME' % (listDir),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 4 and " +
          "STAFResult[0] ==  'zipTest' and " +
          "STAFResult[1] ==  'zipTest2' and " +
          "STAFResult[2] ==  'zipTestFile2.txt' and " +
          "STAFResult[3] ==  'zipTestFile3.txt'"
        ],

        # List the zipfile to verify that it deleted the file
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (zipFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) >= 2 and " +
          "STAFResult[0]['name'] == 'zipTest3/subdir1/' > 0 and " +
          "STAFResult[0]['crc-32'] == '00000000' and "
          "STAFResult[1]['name'].find('/zipTest2/') > 0 and " +
          "STAFResult[1]['crc-32'] == '00000000'"
        ],
 
        [ 'STD:ZIP', ZipService,  'ADD ZIPFILE %s FILE %s RELATIVETO %s' % (zipFile, fileName1, relativeToDir),
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:ZIP', ZipService,  'LIST ZIPFILE %s' % (zipFile),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0]['name'] ==  'zipTest3/subdir1/' and " +
          "STAFResult[1]['name'].find('/zipTest2/') > 0 and " +
          "STAFResult[2]['name'] == 'zipTestFile1.txt'"
        ],

        # Test extracting specific files and directories from a zip archive

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (toDirName),
          [ STAFRC.Ok ], None
        ],
        
        [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s FILE zipTestFile1.txt ' % (zipFile, toDirName),
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:ZIP', 'FS',   'LIST DIRECTORY %s SORTBYNAME' % (toDirName),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0] ==  'zipTestFile1.txt'"
        ]
      ]
      </script>

      <if expr="TestMachOSType.find('OS/390') != 0">
        <script>
        # XXX: Certain ZIP tests fail on z/OS and z/OS 64-bit because it doesn't handle zip files
        # on other platforms or by other zip utilities.

        ZIPTests = ZIPTests + [

        [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s DIRECTORY zipTest3/subdir1/ REPLACE ' % (zipFile, toDirName),
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:ZIP', 'FS',   'LIST DIRECTORY %s SORTBYNAME' % (toDirName),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0] ==  'zipTest3' and " +
          "STAFResult[1] == 'zipTestFile1.txt'"
        ],
  
        # Test specifying a FILE option and a DIRECTORY option in a single UNZIP request
         [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s FILE zipTestFile1.txt DIRECTORY zipTest3/subdir1/ REPLACE ' % (zipFile, toDirName),
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Test specifying multiple DIRECTORY options in a single UNZIP request (where one directory is a subdirectory of the other)
         [ 'STD:ZIP', ZipService,  'UNZIP ZIPFILE %s TODIRECTORY %s FILE zipTestFile1.txt DIRECTORY zipTest3/subdir1/ DIRECTORY zipTest3 REPLACE ' % (zipFile, toDirName),
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:ZIP', 'FS',   'LIST DIRECTORY %s SORTBYNAME RECURSE' % (toDirName),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0] ==  'zipTest3' and " +
          "STAFResult[1].find( 'zipTest3') == 0 and STAFResult[1].find('subdir1') > 8 and " +
          "STAFResult[2] == 'zipTestFile1.txt'"
        ]
      ]
      </script>
    </if>

    <script>
        ZIPTests = ZIPTests + [

        # Clean-up
        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s CONFIRM' % (zipFile),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s CONFIRM' % (fileName1),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s CONFIRM' % (fileName2),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s CONFIRM' % (fileName3),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (dirName1),
          [ STAFRC.Ok ], None
        ],
        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (dirName2),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (dirName3),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY {STAF/DataDir}/user/zipTest3 RECURSE CONFIRM',
          [ STAFRC.Ok ], None
        ],

        [ 'STD:ZIP', 'FS',   'DELETE ENTRY %s RECURSE CONFIRM' % (toDirName),
          [ STAFRC.Ok ], None
        ],

        [ 'STD:ZIP', 'SEM',  'RELEASE MUTEX STAFTest/ZIP',
          [ STAFRC.Ok ], r'^$'
        ]

      ]
      </script>

      <return>ZIPTests</return>

    </sequence>
  </function>


  <!-- ============================================================================== -->
  <!-- InitINSTALLTests - This function initializes all the INSTALL test information  -->
  <!-- ============================================================================== -->

  <function name="InitINSTALLTests" scope="local">
    <sequence>

      <script>

      INSTALLTests = [

        #
        # INSTALL tests
        #

        [ 'STD:INSTALL', 'SEM',  'REQUEST MUTEX STAFTest/INSTALL',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:INSTALL', 'FS',  'QUERY ENTRY {STAF/Config/STAFRoot}{STAF/Config/Sep/File}LICENSE.htm',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) > 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ],

        # XXX: Commented out the following test because will only be present if running STAF from
        # a directory where you used a STAF installer to install STAF (e.g. won't be present if running
        # STAF from directories where you built STAF.

        # Verify that STAFEnv.bat or STAFEnv.sh exists
        #[ 'STD:INSTALL', 'FS',  'LIST DIRECTORY {STAF/Config/STAFRoot}{STAF/Config/Sep/File} NAME STAFEnv',
        #  [ STAFRC.Ok ], None,
        #  "len(STAFResult) > 0"
        #],

        [ 'STD:INSTALL', 'FS',  'QUERY ENTRY {STAF/Config/STAFRoot}{STAF/Config/Sep/File}samples{STAF/Config/Sep/File}c{STAF/Config/Sep/File}LogIt.c',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) > 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ],

        [ 'STD:INSTALL', 'FS',  'QUERY ENTRY {STAF/Config/STAFRoot}{STAF/Config/Sep/File}samples{STAF/Config/Sep/File}cpp{STAF/Config/Sep/File}LogIt.cpp',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) > 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ]

       ]
     </script>

     <if expr="TestMachJavaSupport"> 
       <script>
       INSTALLTests = INSTALLTests + [

        [ 'STD:INSTALL', 'FS',  'QUERY ENTRY {STAF/Config/STAFRoot}{STAF/Config/Sep/File}samples{STAF/Config/Sep/File}demo{STAF/Config/Sep/File}STAFDemo.jar',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) > 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ],

        [ 'STD:INSTALL', 'FS',  'QUERY ENTRY {STAF/Config/STAFRoot}{STAF/Config/Sep/File}samples{STAF/Config/Sep/File}demo{STAF/Config/Sep/File}STAFDemoController.java',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) > 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ],

        [ 'STD:INSTALL', 'FS',  'QUERY ENTRY {STAF/Config/STAFRoot}{STAF/Config/Sep/File}samples{STAF/Config/Sep/File}demo{STAF/Config/Sep/File}STAFProcess.java',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) > 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ]
        
       ]
       </script>
     </if>
        
     <script>
       INSTALLTests = INSTALLTests + [

        [ 'STD:INSTALL', 'FS',  'QUERY ENTRY {STAF/Config/STAFRoot}{STAF/Config/Sep/File}samples{STAF/Config/Sep/File}java{STAF/Config/Sep/File}JPing.java',
          [ STAFRC.Ok ], None,
          "STAFResult['name'] and " +
          "STAFResult['linkTarget'] == None and " +
          "STAFResult['type'] == 'F' and " +
          "int(STAFResult['size']) > 0 and " +
          "STAFResult['lastModifiedTimestamp']"
        ],

        [ 'STD:INSTALL', 'SEM',  'RELEASE MUTEX STAFTest/INSTALL',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>

      <return>INSTALLTests</return>

    </sequence>
  </function>


  <!-- ================================================================================== -->
  <!-- InitEXECPROXYTests - This function initializes all the EXECPROXY test information  -->
  <!-- =================================================================================== -->

  <function name="InitEXECPROXYTests" scope="local">
    <sequence>
      
      <!-- XXX: On Solaris (all types), sometimes STAFExecProxy requests hang
           and don't get cleaned up.  This cleans up any previous STAFExecProxy
           processes that were left running from previous STAFTest jobs -->

      <if expr="TestMachOSType.find('SunOS') == 0">
        <sequence>

          <!-- Remove the execproxytest1 and execproxytest2 services if leftover from a
               previous STAFTest run -->

          <stafcmd>
            <location>TestMach</location>
            <service>'SERVICE'</service>
            <request>'REMOVE SERVICE execproxytest1'</request>
          </stafcmd>

          <stafcmd>
            <location>TestMach</location>
            <service>'SERVICE'</service>
            <request>'REMOVE SERVICE execproxytest2'</request>
          </stafcmd>

          <!-- Check if the STAFExecProxy processes for execproxytest1 and execproxytest2
               were properly cleaned up and if not, kill them -->

          <script>psCmd = "ps -ef | grep STAFExecProxy | grep -v grep | awk '{print $2 $9}'"</script>
          <process>
            <location>TestMach</location>
            <command mode="'shell'">psCmd</command>
            <stderr mode="'stdout'"/>
            <returnstdout/>
          </process>

          <if expr="RC == 0 and STAXResult != None and len(STAXResult[0][1]) > 0">
            <sequence>
              <log message="1">'Output from "%s":\n%s' % (psCmd, STAXResult[0][1])</log>
              <script>
                pid_execproxytest1 = ''
                pid_execproxytest2 = ''
                
                lineList = STAXResult[0][1].splitlines()

                # Read each line in the ps stdout and check if contains execproxytest1 or 2

                for line in lineList:
                  # Check if STAFExecProxy is for execproxytest1 and if so assign its pid
                  index = line.find('execproxytest1')
                  if index != -1:
                    pid_execproxytest1 = line[0:index]
                  
                  # Check if STAFExecProxy is for execproxytest1 and if so assign its pid
                  index = line.find('execproxytest2')
                  if index != -1:
                    pid_execproxytest2 = line[0:index]
              </script>

              <if expr="len(pid_execproxytest1) > 0">
                <sequence>
                  <log message="1">'Kill pid %s for STAFExecProxy execproxytest1 (leftover from a previous run of STAFTest)' % (pid_execproxytest1)</log>
                  <script>killCmd = 'kill -9 %s' % (pid_execproxytest1)</script>
                  <process>
                    <location>TestMach</location>
                    <command mode="'shell'">killCmd</command>
                    <stderr mode="'stdout'"/>
                    <returnstdout/>
                  </process>

                  <if expr="RC != STAFRC.Ok">
                    <log message="1">
                      'Process running "%s" failed.\nRC=%s, STAFResult=%s, STAXResult=%s' % (killCmd, RC, STAFResult, STAXResult)
                    </log>
                  </if>
                </sequence>
              </if>

              <if expr="len(pid_execproxytest2) > 0">
                <sequence>
                  <log message="1">'Kill pid %s for STAFExecProxy execproxytest2 (leftover from a previous run of STAFTest)' % (pid_execproxytest2)</log>
                  <script>killCmd = 'kill -9 %s' % (pid_execproxytest2)</script>
                  <process>
                    <location>TestMach</location>
                    <command mode="'shell'">killCmd</command>
                    <stderr mode="'stdout'"/>
                    <returnstdout/>
                  </process>

                  <if expr="RC != STAFRC.Ok">
                    <log message="1">
                      'Process running "%s" failed.\nRC=%s, STAFResult=%s, STAXResult=%s' % (killCmd, RC, STAFResult, STAXResult)
                    </log>
                  </if>
                </sequence>
              </if>

            </sequence>
          </if>
        </sequence>
      </if>

      <script>
        EXECPROXYTests = [

        #
        # EXECPROXY tests
        #

        [ 'STD:EXECPROXY', 'SEM',  'REQUEST MUTEX STAFTest/EXECPROXY',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EXECPROXY', 'SERVICE', 'ADD SERVICE execproxytest1 LIBRARY STAFEXECPROXY EXECUTE STAFZip',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EXECPROXY', 'execproxytest1', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:EXECPROXY', 'execproxytest1', 'VERSION',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:EXECPROXY', 'SERVICE', 'LIST SERVICES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['name'] and " +
          "STAFResult[0]['library'] and " +
          "STAFResult[0]['executable'] or STAFResult[0]['executable'] == None"
        ],

        [ 'STD:EXECPROXY', 'SERVICE', 'QUERY SERVICE execproxytest1', 
          [ STAFRC.Ok ],  None,
          "STAFResult['name'] == 'EXECPROXYTEST1' and " +
          "STAFResult['library'] == 'STAFEXECPROXY' and " +
          "STAFResult['executable'] == 'STAFZip' and " +
          "len(STAFResult['options']) == 0 and " +
          "STAFResult['parameters'] == None"
        ],

        [ 'STD:EXECPROXY', 'SERVICE', 'ADD SERVICE execproxytest2 LIBRARY STAFEXECPROXY EXECUTE STAFMon PARMS "MAXRECORDSIZE 512"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EXECPROXY', 'execproxytest2', 'HELP',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:EXECPROXY', 'execproxytest2', 'VERSION',
          [ STAFRC.Ok ], r'^.'
        ],

        [ 'STD:EXECPROXY', 'SERVICE', 'QUERY SERVICE execproxytest2', 
          [ STAFRC.Ok ],  None,
          "STAFResult['name'] == 'EXECPROXYTEST2' and " +
          "STAFResult['library'] == 'STAFEXECPROXY' and " +
          "STAFResult['executable'] == 'STAFMon' and " +
          "len(STAFResult['options']) == 0 and " +
          "STAFResult['parameters'] == 'MAXRECORDSIZE 512'"
        ],

        [ 'STD:EXECPROXY', 'SERVICE', 'REMOVE SERVICE execproxytest1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EXECPROXY', 'SERVICE', 'REMOVE SERVICE execproxytest2',
          [ STAFRC.Ok ], r'^$'
        ],
 
        [ 'STD:EXECPROXY', 'SERVICE', 'ADD SERVICE execproxytest2 LIBRARY STAFEXECPROXY EXECUTE testUnknownService',
          [ STAFRC.ServiceConfigurationError ], r'^.'
        ],
        
        [ 'STD:EXECPROXY', 'SEM',  'RELEASE MUTEX STAFTest/EXECPROXY',
          [ STAFRC.Ok ], r'^$'
        ]

        ]
      </script>

      <return>EXECPROXYTests</return>

    </sequence>
  </function>

  <!-- ================================================================================ -->
  <!-- InitOTHERTests - This function initializes all the OTHER test information  -->
  <!-- ================================================================================ -->

  <function name="InitOTHERTests" scope="local"
           requires="CheckListArgType CheckMapArgType STAFTestCallPythonFunc">

    <testcase name="'OTHER'">
      <sequence>

        <!-- These tests don't really fall into testing a particular service and don't
             involve adding tests to the overall list of tests to run -->

        <!-- Test fix for Bug #814783 "Types for function list and map arguments not retained"-->

        <process name="'MyProcess'">
          <location>'local'</location>
          <command mode="'shell'">"echo hello world"</command>
          <stdout/>
          <stderr mode="'stdout'"/>
          <returnstdout/>
        </process>

        <call function="'CheckListArgType'">0, RC</call>
        <call function="'CheckMapArgType'">{'ExpectedReturnCode': 0, 'ActualReturnCode': RC}</call>

        <!-- Test fix for Bug #960415 "Cannot access cloned STAX variables from Python function -->

        <script>
          def STAFTestPythonFunction():
            try:
              return STAFTestPythonFuncVar
            except:
              return 0
        </script>

        <call function="'STAFTestCallPythonFunc'"/>

        <!-- Test fix for Bug #1043148 "Cannot iterate a Java List -->
        <script>
         import java.util.List
         import java.util.ArrayList
         javaList = java.util.ArrayList()
         javaList.add('entry1')
         javaList.add('entry2')
        </script>

        <message>
          'Use iterate element to iterate through javaList...'
        </message>

        <iterate var="entry" in="javaList" indexvar="i">
          <if expr="(i == 0 and entry == 'entry1') or (i == 1 and entry == 'entry2')">
            <tcstatus result="'pass'"/>
            <else>
              <sequence>
                <script>msg = 'OTHER test - ERROR iterating a Java List: i = %s, entry = %s'  % (i, entry)</script>
                <tcstatus result="'fail'">msg</tcstatus>
                <message>msg</message>
                <log level="'error'">msg</log>
              </sequence>
            </else>
          </if>
        </iterate>

        <message>
          'Use paralleliterate element to iterate through javaList...'
        </message>

        <paralleliterate var="entry" in="javaList" indexvar="i">
          <if expr="(i == 0 and entry == 'entry1') or (i == 1 and entry == 'entry2')">
            <tcstatus result="'pass'"/>
            <else>
              <sequence>
                <script>msg = 'OTHER test - ERROR parallel iterating a Java List: i = %s, entry = %s'  % (i, entry)</script>
                <tcstatus result="'fail'">msg</tcstatus>
                <message>msg</message>
                <log level="'error'">msg</log>
              </sequence>
            </else>
          </if>
        </paralleliterate>

        <!-- Test fix for Bug #1457971 "Trouble marshalling STAXGlobal".  To handle, implemented a stafMarshall method for STAXGlobal -->
        <message>
          'Testing marshalling a STAXGlobal object...'
        </message>
        <script>
          attachments = STAXGlobal( ['machA', 'machB'] )
          marshalledData = STAFMarshalling.marshall({'jobResult': 0, 'attachments': attachments})
          mc =STAFMarshalling.unmarshall(marshalledData)
          resultMap = mc.getRootObject()
          myAttachments = resultMap['attachments']
        </script>
        <if expr="type(myAttachments) == types.ListType">
          <tcstatus result="'pass'"/>
          <else>
            <sequence>
              <script>
               msg = 'OTHER test - ERROR marshalling a STAXGlobal:\n ' + \
                         '  type(myAttachments)=%s instead of ListType\n' % (type(myAttachments)) + \
                         '  myAttachments=%s' % (myAttachments)
              </script>
              <tcstatus result="'fail'">msg</tcstatus>
              <log message="1">msg</log>
            </sequence>
          </else>
        </if>

        <!-- Test fix for Bug #1679340  Python NameError: false when comparing a STAXGlobal
              variable that is an integer or a string without using it's get() method -->
        <message>
          'Testing comparing a STAXGlobal that contains an integer...'
        </message>
        <script>
          A = STAXGlobal(0)
        </script>
              
        <if expr="A == 0">
          <tcstatus result="'pass'"/>
          <else>
            <sequence>
              <script>msg = 'OTHER test - ERROR checking if STAXGlobal variable A == 0:  A=%s'  % (A)</script>
              <tcstatus result="'fail'">msg</tcstatus>
              <log level="'error'" message="1">msg</log>
            </sequence>
          </else>
        </if>

        <if expr="A != 1">
          <tcstatus result="'pass'"/>
          <else>
            <sequence>
              <script>msg = 'OTHER test - ERROR checking if STAXGlobal variable A != 1:  A=%s'  % (A)</script>
              <tcstatus result="'fail'">msg</tcstatus>
              <log level="'error'" message="1">msg</log>
            </sequence>
          </else>
        </if>
          
        <if expr="A">
          <sequence>
            <script>msg = 'OTHER test - ERROR checking if STAXGlobal variable A:  A=%s'  % (A)</script>
            <tcstatus result="'fail'">msg</tcstatus>
            <log level="'error'" message="1">msg</log>
          </sequence>
          <else>
            <tcstatus result="'pass'"/>
          </else>
        </if>
        
        <if expr="A &lt; 1">
          <tcstatus result="'pass'"/>
          <else>
            <sequence>
              <script>msg = 'OTHER test - ERROR checking if STAXGlobal variable A &lt; 1:  A=%s'  % (A)</script>
              <tcstatus result="'fail'">msg</tcstatus>
              <log level="'error'" message="1">msg</log>
            </sequence>
          </else>
        </if>
        
        <if expr="A >= 0">
          <tcstatus result="'pass'"/>
          <else>
            <sequence>
              <script>msg = 'OTHER test - ERROR checking if STAXGlobal variable A >= 1:  A=%s'  % (A)</script>
              <tcstatus result="'fail'">msg</tcstatus>
              <log level="'error'" message="1">msg</log>
            </sequence>
          </else>
        </if>

        <!-- Test fix for Bug #1798346 - "Slicing a STAXGlobal variable fails" -->

        <log message="1">'Testing fix for slicing a STAXGlobal variable'</log>
        <script>
          errMsg = ''
          try:
            gVar = STAXGlobal([])
            gVar[:] = [1, 2, 3]   # Test __setslice__
            x = gVar[0:2]  # Test __getslice__
            del gVar[2:]  # Test __delslice__
          except:
            errMsg = 'Error slicing a STAXGlobal variable'
        </script>

        <if expr="errMsg == '' and gVar == [1, 2]">
          <tcstatus result="'pass'"/>
          <else>
            <sequence>
              <script>msg = 'OTHER test - %s' % (errMsg)</script>
              <tcstatus result="'fail'">msg</tcstatus>
              <log level="'error'" message="1">msg</log>
            </sequence>
          </else>
        </if>

        <!-- Test Feature #149566 - "Add minimize window option when starting a process" -->
        
        <message log="1">
          'Testing using the minimize window option when starting a process...'
        </message>

        <process name="'Test minimized focus starting a process'">
          <location>TestMach</location>
          <command mode="'shell'">'STAF local DELAY DELAY 1m'</command>
          <focus mode="'minimized'"/>
          <stderr mode="'stdout'"/>
          <returnstdout/>
          <process-action>
            <sequence>
              <script>request = 'QUERY JOB %s PROCESS %s:%s' % (STAXJobID, TestMach, STAXProcessHandle)</script> 
              <stafcmd>
                <location>'local'</location>
                <service>STAXService</service>
                <request>request</request>
              </stafcmd>
              <if expr="RC == 0 and STAFResult['focus'] == 'Minimized'">
                <tcstatus result="'pass'"/>
                <else>
                  <sequence>
                    <script>
                      msg = 'OTHER test - ERROR running a process with the focus set to minimized.\n' + \
                        '%s, RC=%s, STAFResult=\n%s' % (request, RC, STAFResult)
                    </script>
                    <tcstatus result="'fail'">msg</tcstatus>
                    <log message="1">msg</log>
                  </sequence>
                </else>
              </if>
              <stafcmd>
                <location>TestMach</location>
                <service>'PROCESS'</service>
                <request>'STOP HANDLE %s' % (STAXProcessHandle)</request>
              </stafcmd>
              <stafcmd>
                <location>TestMach</location>
                <service>'PROCESS'</service>
                <request>'FREE HANDLE %s' % (STAXProcessHandle)</request>
              </stafcmd>
            </sequence>
          </process-action>
        </process>
        
        <!-- Test Bug #1711464 - Make sure a loop's until expression is evaluated at the bottom of the loop -->
        
        <log message="1">'Test to make sure a loop until expression is evaluated at the bottom of the loop'</log>
        <script>loopCounter = 0</script>

        <loop var="myIndex" to="4" until="myRC != 0"> 
          <sequence>
            <script>loopCounter = loopCounter + 1</script>
            <if expr="myIndex == 3">
              <script>myRC = 1</script>
              <else>
                <script>myRC = 0</script>
              </else>
            </if>
          </sequence> 
        </loop> 

        <if expr="loopCounter != 3 or myRC != 1 or myIndex != 3">
          <sequence>
            <script>
              msg = 'OTHER test - ERROR on loop until test checking if loopCounter !=3 or myRC != 1 or myIndex != 3:  loopCounter=%s myRC=%s myIndex=%s'  % \
                        (loopCounter, myRC, myIndex)
            </script>
            <tcstatus result="'fail'">msg</tcstatus>
            <log level="'error'" message="1">msg</log>
          </sequence>
          <else>
            <tcstatus result="'pass'"/>
          </else>
        </if>

        <if expr="TestMachJavaSupport">
          <sequence>
            <!-- Test TestJSTAF -->

            <process name="'TestJSTAFProcess'">
              <location>TestMach</location>
              <command mode="'shell'">"java com.ibm.staf.TestJSTAF local MISC VERSION"</command>
              <stdout/>
              <stderr mode="'stdout'"/>
              <returnstdout/>
            </process>
            <log message="1">'Testing "java com.ibm.staf.TestJSTAF local MISC VERSION" RC=%s, STAXResult=%s' % (RC, STAXResult)</log>

            <script>
              testJSTAFResult = STAXResult[0][1]
              expectedResult = """TestJSTAF using STAF handle xx
              RC=0
              Result=3.x.x"""
            </script>

            <call function="'CheckMapArgType'">{'ExpectedReturnCode': 0, 'ActualReturnCode': RC}</call>

            <if expr="testJSTAFResult.find('TestJSTAF using STAF handle ') != -1 and testJSTAFResult.find('RC=0') != -1 and testJSTAFResult.find('Result=3.') != -1"> 
              <tcstatus result="'pass'"/>
              <else>
                <sequence>
                  <script>
                    msg = 'OTHER test = TestJSTAF output error.\n\nExpected:\n\n%s\n\nActual:\n\n%s' % (expectedResult, testJSTAFResult)
                  </script>
                  <tcstatus result="'fail'">msg</tcstatus>
                  <log message="1" level="'error'">msg</log>
                </sequence>
              </else>
            </if>

          </sequence>
        </if>

        <script>
        OTHERTests = [

          [ 'STD:OTHER', 'SEM',  'REQUEST MUTEX STAFTest/OTHER',
            [ STAFRC.Ok ], r'^$'
          ],

          [ 'STD:OTHER', 'SEM',  'RELEASE MUTEX STAFTest/OTHER',
            [ STAFRC.Ok ], r'^$'
          ]
        ]
        </script>

        <return>OTHERTests</return>

      </sequence>
    </testcase>
  </function>

  <function name="CheckListArgType" scope="local">

    <function-list-args>
      <function-required-arg name="ExpectedReturnCode"/>
      <function-required-arg name="ActualReturnCode"/>
    </function-list-args>

    <sequence>
      <if expr="ActualReturnCode == ExpectedReturnCode">
        <tcstatus result="'pass'"/>
      <else>
        <sequence>
          <script>
             msg = 'OTHER test - ERROR on CheckListArgType: Expected return code=%s with type %s, actual return code=%s with type %s'  % (ExpectedReturnCode, type(ExpectedReturnCode), ActualReturnCode, type(ActualReturnCode))
          </script>
          <tcstatus result="'fail'">msg</tcstatus>
          <message>msg</message>
          <log level="'error'">msg</log>
        </sequence>
      </else>
      </if>

    </sequence>
  </function>

  <function name="CheckMapArgType" scope="local">

    <function-map-args>
      <function-required-arg name="ExpectedReturnCode"/>
      <function-required-arg name="ActualReturnCode"/>
    </function-map-args>

    <sequence>
      <if expr="ActualReturnCode == ExpectedReturnCode">
        <tcstatus result="'pass'"/>
      <else>
        <sequence>
          <script>
            msg = 'OTHER test - ERROR on CheckMapArgType: Expected return code=%s with type %s, actual return code=%s with type %s'  % (ExpectedReturnCode, type(ExpectedReturnCode), ActualReturnCode, type(ActualReturnCode))
          </script>
          <tcstatus result="'fail'">msg</tcstatus>
          <message>msg</message>
          <log level="'error'">msg</log>
        </sequence>
      </else>
      </if>

    </sequence>
  </function>

  <function name="STAFTestCallPythonFunc" scope="local" requires="STAFTestCallPythonFuncB">
    <paralleliterate var="STAFTestPythonFuncVar" in="[1, 2]">
      <call function="'STAFTestCallPythonFuncB'">STAFTestPythonFuncVar</call>
    </paralleliterate>
  </function>

  <function name="STAFTestCallPythonFuncB" scope="local">
    <sequence>

      <if expr="STAFTestPythonFunction() != 0">
        <tcstatus result="'pass'"/>
        <else>
          <sequence>
            <script>
               msg = 'OTHER test - ERROR on STAFTestCallPythonFunction: STAFTestCallPythonFuncB = 0'
            </script>
            <tcstatus result="'fail'">msg</tcstatus>
            <message>msg</message>
            <log level="'error'">msg</log>
          </sequence>
        </else>
      </if>

    </sequence>
  </function>


  <!-- ==================================================================================================== -->
  <!-- InitDEVICEC++Tests - This function initializes all the DEVICE C++ service information                -->
  <!-- ==================================================================================================== -->

  <function name="InitDEVICECTests" scope="local">
    <sequence>

      <script>
        ServiceName = 'DEVICE_C++'
        deviceLibraryExecInfo = 'LIBRARY STAFDeviceService'
      </script>

      <call function="'InitDEVICETests'"/>

      <return>STAXResult</return>

    </sequence>
  </function>

  <!-- ==================================================================================================== -->
  <!-- InitDEVICEJavaTests - This function initializes all the DEVICE Java service information              -->
  <!-- ==================================================================================================== -->

  <function name="InitDEVICEJavaTests" scope="local" requires="InitDEVICETests">
    <sequence>

      <testcase name="'DEVICE_Java'">
        <sequence>

          <script>
            TestMachDeviceServiceJarFile = '{STAF/Config/STAFRoot}/bin/STAFDeviceService.jar'
            fromMachine = 'local'
            request = 'COPY FILE %s TOFILE %s TOMACHINE %s' % (DeviceServiceJarFile, TestMachDeviceServiceJarFile, TestMach)
          </script>

          <message>
            'Copy STAFDeviceService.jar file to test machine: STAF %s FS %s' % (fromMachine, request)
          </message>

          <stafcmd>
            <location>fromMachine</location>
            <service>'FS'</service>
            <request>request</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == STAFRC.Ok,
              'failMsg': 'Error copying STAFDeviceService.jar file to test machine: STAF %s FS %s.  RC=%s Result=%s' % \
                         (fromMachine, request, RC, STAFResult),
              'sendToMonitor': 1,
              'recordStatus': 1 }
          </call>

        </sequence>
      </testcase>

      <script>
        ServiceName = 'DEVICE_Java'
        deviceLibraryExecInfo = 'LIBRARY JSTAF EXECUTE %s OPTION JVMName=JDevice %s' % (TestMachDeviceServiceJarFile, RequiredJVMOptions)
      </script>

      <call function="'InitDEVICETests'"/>

      <return>STAXResult</return>

    </sequence>
  </function>

  <!-- ==================================================================================================== -->
  <!-- InitDEVICEPerlTests - This function initializes all the DEVICE Perl service information              -->
  <!-- ==================================================================================================== -->

  <function name="InitDEVICEPerlTests" scope="local" requires="InitDEVICETests">
    <sequence>

      <testcase name="'DEVICE_Perl'">
        <sequence>

          <script>
              ServiceName = 'DEVICE_PERL'
              deviceLibraryExecInfo = 'LIBRARY PLSTAF EXECUTE {STAF/Config/STAFRoot}/bin/DeviceService.pl OPTION PERLPARMS="-Id:{STAF/Config/STAFRoot}/lib"'
          </script>

          <call function="'InitDEVICETests'"/>

          <return>STAXResult</return>

        </sequence>

      </testcase>

    </sequence>
  </function>

  <!-- ==================================================================================================== -->
  <!-- InitDEVICETests - This function initializes all the DEVICE test information (used by both the C++    -->
  <!--                   and Java versions of this service)                                                 -->
  <!-- ==================================================================================================== -->

  <function name="InitDEVICETests" scope="local">
    <sequence>

      <script>
        DEVICETests = []
      </script>

      <!-- Only run DEVICE_Java tests if the test machine has STAF Java Support built -->
      <if expr="ServiceName == 'DEVICE_Java' and TestMachJavaSupport">
      <sequence>
      <script>

      DEVICETests = [

        #
        # DEVICE tests
        #

        [ 'STD:%s' % ServiceName, 'SEM',  'REQUEST MUTEX STAFTest/DEVICE', [ STAFRC.Ok ], r'^$' ],

        [ 'STD:%s' % ServiceName, 'SERVICE', 'REMOVE SERVICE DEVICE', [ STAFRC.Ok, STAFRC.DoesNotExist ], None ],

        [ 'STD:%s' % ServiceName, 'SERVICE', 'ADD SERVICE DEVICE %s' % (deviceLibraryExecInfo), [ STAFRC.Ok, STAFRC.AlreadyExists ], r'^$' ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'HELP', [ STAFRC.Ok ], r'^.' ],
        
        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:%s' % ServiceName, 'DEVICE', 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'VERSION', [ STAFRC.Ok ], r'^.' ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD PRINTER canon1 MODEL S750 SN 34349', [ STAFRC.Ok ], None ],
        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD PRINTER epson MODEL color500 SN 1023', [ STAFRC.Ok ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'canon1' and " +
          "STAFResult[0]['type'] == 'Printer' and " +
          "STAFResult[0]['model'] == 'S750' and " +
          "STAFResult[0]['serial#'] == '34349' and " +
          "STAFResult[1]['name'] == 'epson' and " +
          "STAFResult[1]['type'] == 'Printer' and " +
          "STAFResult[1]['model'] == 'color500' and " +
          "STAFResult[1]['serial#'] == '1023'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'canon1' and " +
          "STAFResult[0]['type'] == 'Printer' and " +
          "STAFResult[0]['model'] == 'S750' and " +
          "STAFResult[0]['serial#'] == '34349' and " +
          "STAFResult[1]['name'] == 'epson' and " +
          "STAFResult[1]['type'] == 'Printer' and " +
          "STAFResult[1]['model'] == 'color500' and " +
          "STAFResult[1]['serial#'] == '1023'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'canon1' and " +
          "STAFResult[0]['type'] == 'Printer' and " +
          "STAFResult[0]['model'] == 'S750' and " +
          "STAFResult[0]['serial#'] == '34349' and " +
          "STAFResult[1]['name'] == 'epson' and " +
          "STAFResult[1]['type'] == 'Printer' and " +
          "STAFResult[1]['model'] == 'color500' and " +
          "STAFResult[1]['serial#'] == '1023'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER canon1',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'S750' and " +
          "STAFResult['serial#'] == '34349'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER epson',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'color500' and " +
          "STAFResult['serial#'] == '1023'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD MODEM Linksys MODEL d59xp SN 554371', [ STAFRC.Ok ], None ],
        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD MODEM lucent MODEL tlxa SN 3030', [ STAFRC.Ok ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 4 and " +
          "STAFResult[0]['name'] == 'canon1' and " +
          "STAFResult[0]['type'] == 'Printer' and " +
          "STAFResult[0]['model'] == 'S750' and " +
          "STAFResult[0]['serial#'] == '34349' and " +
          "STAFResult[1]['name'] == 'epson' and " +
          "STAFResult[1]['type'] == 'Printer' and " +
          "STAFResult[1]['model'] == 'color500' and " +
          "STAFResult[1]['serial#'] == '1023' and " +
          "STAFResult[2]['name'] == 'Linksys' and " +
          "STAFResult[2]['type'] == 'Modem' and " +
          "STAFResult[2]['model'] == 'd59xp' and " +
          "STAFResult[2]['serial#'] == '554371' and " +
          "STAFResult[3]['name'] == 'lucent' and " +
          "STAFResult[3]['type'] == 'Modem' and " +
          "STAFResult[3]['model'] == 'tlxa' and " +
          "STAFResult[3]['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 4 and " +
          "STAFResult[0]['name'] == 'canon1' and " +
          "STAFResult[0]['type'] == 'Printer' and " +
          "STAFResult[0]['model'] == 'S750' and " +
          "STAFResult[0]['serial#'] == '34349' and " +
          "STAFResult[1]['name'] == 'epson' and " +
          "STAFResult[1]['type'] == 'Printer' and " +
          "STAFResult[1]['model'] == 'color500' and " +
          "STAFResult[1]['serial#'] == '1023' and " +
          "STAFResult[2]['name'] == 'Linksys' and " +
          "STAFResult[2]['type'] == 'Modem' and " +
          "STAFResult[2]['model'] == 'd59xp' and " +
          "STAFResult[2]['serial#'] == '554371' and " +
          "STAFResult[3]['name'] == 'lucent' and " +
          "STAFResult[3]['type'] == 'Modem' and " +
          "STAFResult[3]['model'] == 'tlxa' and " +
          "STAFResult[3]['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'canon1' and " +
          "STAFResult[0]['type'] == 'Printer' and " +
          "STAFResult[0]['model'] == 'S750' and " +
          "STAFResult[0]['serial#'] == '34349' and " +
          "STAFResult[1]['name'] == 'epson' and " +
          "STAFResult[1]['type'] == 'Printer' and " +
          "STAFResult[1]['model'] == 'color500' and " +
          "STAFResult[1]['serial#'] == '1023'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'Linksys' and " +
          "STAFResult[0]['type'] == 'Modem' and " +
          "STAFResult[0]['model'] == 'd59xp' and " +
          "STAFResult[0]['serial#'] == '554371' and " +
          "STAFResult[1]['name'] == 'lucent' and " +
          "STAFResult[1]['type'] == 'Modem' and " +
          "STAFResult[1]['model'] == 'tlxa' and " +
          "STAFResult[1]['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM Linksys',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'd59xp' and " +
          "STAFResult['serial#'] == '554371'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM lucent',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'tlxa' and " +
          "STAFResult['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER lexmark',
          [ STAFRC.DoesNotExist ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM logitech',
          [ STAFRC.DoesNotExist ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'DELETE PRINTER canon1 CONFIRM',
          [ STAFRC.Ok ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0]['name'] == 'epson' and " +
          "STAFResult[0]['type'] == 'Printer' and " +
          "STAFResult[0]['model'] == 'color500' and " +
          "STAFResult[0]['serial#'] == '1023' and " +
          "STAFResult[1]['name'] == 'Linksys' and " +
          "STAFResult[1]['type'] == 'Modem' and " +
          "STAFResult[1]['model'] == 'd59xp' and " +
          "STAFResult[1]['serial#'] == '554371' and " +
          "STAFResult[2]['name'] == 'lucent' and " +
          "STAFResult[2]['type'] == 'Modem' and " +
          "STAFResult[2]['model'] == 'tlxa' and " +
          "STAFResult[2]['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0]['name'] == 'epson' and " +
          "STAFResult[0]['type'] == 'Printer' and " +
          "STAFResult[0]['model'] == 'color500' and " +
          "STAFResult[0]['serial#'] == '1023' and " +
          "STAFResult[1]['name'] == 'Linksys' and " +
          "STAFResult[1]['type'] == 'Modem' and " +
          "STAFResult[1]['model'] == 'd59xp' and " +
          "STAFResult[1]['serial#'] == '554371' and " +
          "STAFResult[2]['name'] == 'lucent' and " +
          "STAFResult[2]['type'] == 'Modem' and " +
          "STAFResult[2]['model'] == 'tlxa' and " +
          "STAFResult[2]['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['name'] == 'epson' and " +
          "STAFResult[0]['type'] == 'Printer' and " +
          "STAFResult[0]['model'] == 'color500' and " +
          "STAFResult[0]['serial#'] == '1023'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'Linksys' and " +
          "STAFResult[0]['type'] == 'Modem' and " +
          "STAFResult[0]['model'] == 'd59xp' and " +
          "STAFResult[0]['serial#'] == '554371' and " +
          "STAFResult[1]['name'] == 'lucent' and " +
          "STAFResult[1]['type'] == 'Modem' and " +
          "STAFResult[1]['model'] == 'tlxa' and " +
          "STAFResult[1]['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER epson',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'color500' and " +
          "STAFResult['serial#'] == '1023'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM Linksys',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'd59xp' and " +
          "STAFResult['serial#'] == '554371'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM lucent',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'tlxa' and " +
          "STAFResult['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER canon1', [ STAFRC.DoesNotExist ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'DELETE PRINTER epson CONFIRM', [ STAFRC.Ok ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'Linksys' and " +
          "STAFResult[0]['type'] == 'Modem' and " +
          "STAFResult[0]['model'] == 'd59xp' and " +
          "STAFResult[0]['serial#'] == '554371' and " +
          "STAFResult[1]['name'] == 'lucent' and " +
          "STAFResult[1]['type'] == 'Modem' and " +
          "STAFResult[1]['model'] == 'tlxa' and " +
          "STAFResult[1]['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'Linksys' and " +
          "STAFResult[0]['type'] == 'Modem' and " +
          "STAFResult[0]['model'] == 'd59xp' and " +
          "STAFResult[0]['serial#'] == '554371' and " +
          "STAFResult[1]['name'] == 'lucent' and " +
          "STAFResult[1]['type'] == 'Modem' and " +
          "STAFResult[1]['model'] == 'tlxa' and " +
          "STAFResult[1]['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0]['name'] == 'Linksys' and " +
          "STAFResult[0]['type'] == 'Modem' and " +
          "STAFResult[0]['model'] == 'd59xp' and " +
          "STAFResult[0]['serial#'] == '554371' and " +
          "STAFResult[1]['name'] == 'lucent' and " +
          "STAFResult[1]['type'] == 'Modem' and " +
          "STAFResult[1]['model'] == 'tlxa' and " +
          "STAFResult[1]['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER epson',
          [ STAFRC.DoesNotExist ], None],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER canon1',
          [ STAFRC.DoesNotExist ], None],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM Linksys',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'd59xp' and " +
          "STAFResult['serial#'] == '554371'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM lucent',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'tlxa' and " +
          "STAFResult['serial#'] == '3030'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'DELETE MODEM lucent CONFIRM',
          [ STAFRC.Ok ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['name'] == 'Linksys' and " +
          "STAFResult[0]['type'] == 'Modem' and " +
          "STAFResult[0]['model'] == 'd59xp' and " +
          "STAFResult[0]['serial#'] == '554371'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['name'] == 'Linksys' and " +
          "STAFResult[0]['type'] == 'Modem' and " +
          "STAFResult[0]['model'] == 'd59xp' and " +
          "STAFResult[0]['serial#'] == '554371'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['name'] == 'Linksys' and " +
          "STAFResult[0]['type'] == 'Modem' and " +
          "STAFResult[0]['model'] == 'd59xp' and " +
          "STAFResult[0]['serial#'] == '554371'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER epson',
          [ STAFRC.DoesNotExist ], None],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER canon1',
          [ STAFRC.DoesNotExist ], None],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM Linksys',
          [ STAFRC.Ok ], None,
          "STAFResult['model'] == 'd59xp' and " +
          "STAFResult['serial#'] == '554371'"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM lucent',
          [ STAFRC.DoesNotExist ], None],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'DELETE MODEM Linksys CONFIRM',
          [ STAFRC.Ok ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST MODEMS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER epson',
          [ STAFRC.DoesNotExist ], None],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER canon1',
          [ STAFRC.DoesNotExist ], None],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM Linksys',
          [ STAFRC.DoesNotExist ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM lucent',
          [ STAFRC.DoesNotExist ], None],

        # Test invalid request
        [ 'STD:%s' % ServiceName, 'DEVICE', 'PING',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD SCANNER',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD PRINTER',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD PRINTER prtname',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD PRINTER prtname MODEL abc',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD PRINTER prtname SN abc',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD MODEM',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD MODEM prtname',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD MODEM mdmname MODEL abc',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'ADD MODEM mdmname SN abc',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'DELETE',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'DELETE PRINTER CONFIRM',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'DELETE MODEM CONFIRM',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'DELETE PRINTER prtname MODEM mdmname CONFIRM',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'DELETE PRINTER prtname CONFIRM VERIFY',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST SCANNERS',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'LIST PRINTERS MODEMS SCANNERS',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY MODEM',
          [ STAFRC.InvalidRequestString ], None ],

        [ 'STD:%s' % ServiceName, 'DEVICE', 'QUERY PRINTER MODEM',
          [ STAFRC.InvalidRequestString ], None ],

        # Test invalid service name
        [ 'STD:%s' % ServiceName, 'DEVICESERVICE', 'LIST',
          [ STAFRC.UnknownService ], None ],

        [ 'STD:%s' % ServiceName, 'SEM', 'RELEASE MUTEX STAFTest/DEVICE',
          [ STAFRC.Ok ], r'^$' ]
        ]
      </script>
      </sequence>
      </if>
     
      <return>DEVICETests</return>

    </sequence>
  </function>

  <!-- ========================================================================== -->
  <!-- InitSTAXTests - This function initializes all the STAX test information    -->
  <!-- ========================================================================== -->

  <function name="InitSTAXTests" scope="local">
    <sequence>

      <script>
        # Assign current STAX job test directory
        theSTAXJobTestDir = '%s/service/%s/job/Job%s' % (STAXMachDataDir,STAXServiceName.lower(), STAXJobID)
        theSTAXJobTestDir = theSTAXJobTestDir.replace('\\', '/')

        # Create a STAX xml job to be used on a STAX EXECUTE request using the FILE option.
        # Create file STAXExecuteTest.xml in theSTAXJobTestDir on the STAX (local) machine
        # with line-endings appropriate for the STAX machine's platform
        theXmlFileName = '%s/STAXExecuteTest.xml' % (theSTAXJobTestDir)

        # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
        xmlFile = open(theXmlFileName, 'wt')

        xmlFile.writelines([ '&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>\n',
                              '&lt;!DOCTYPE stax SYSTEM "stax.dtd">\n',
                              '&lt;stax>\n',
                              '  &lt;function name="FunctionA">\n',
                              "    &lt;return>'Success'&lt;/return>\n",
                              '  &lt;/function>\n',
                              '&lt;/stax>\n' ])
        xmlFile.close()

        # Create XML data to be used on a STAX EXECUTE request using the DATA option
        xml = "&lt;?xml version='1.0' encoding='UTF-8' standalone='no'?>&lt;!DOCTYPE stax SYSTEM 'stax.dtd'>&lt;stax>&lt;function name='FunctionA'>&lt;return>'Success'&lt;/return>&lt;/function>&lt;/stax>"

        STAXTests = []
      </script>

      <testcase name="'STAX'">
        <sequence>

          <log message="1">'STAX: Test "Python Output" and "Python Log Level"'</log>

          <if expr="STAXPythonOutput in ['JobUserLog', 'JobUserLogAndMsg']">
            <sequence>

              <message log="1">
                'STAX: Verify that a print statement in a script element is logged in the STAX Job User Log'
              </message>

              <script>
                pythonStdoutMsg = 'Python Stdout Output Test: '
                print '%sWas log level %s used?' % (pythonStdoutMsg, STAXPythonLogLevel)
              </script>

              <script>
                request = 'QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME "STAX_Job_%s_User" LEVELMASK "%s" STARTSWITH "%s" LAST 1' % \
                              (STAXJobID, STAXPythonLogLevel, pythonStdoutMsg)
              </script>

              <log message="1">'STAF local LOG %s' % (request)</log>

              <stafcmd>
                <location>'local'</location>
                <service>'LOG'</service>
                <request>request</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == 0 and len(STAFResult) == 1,
                'failMsg': 'Error:  Python print statement did not write a message beginning with %s with log level %s to %s.  RC=%s STAFResult=%s' % \
                              (pythonStdoutMsg, STAXPythonLogLevel, STAXJobUserLog, RC, STAFResult),
                'sendToMonitor': 1,
                'recordStatus': 1 }
              </call>
              
              <message log="1">
                'STAX: Verify that a print >>sys.stderr statement in a script element is logged in the STAX Job User Log'
              </message>

              <script>
                pythonStderrMsg = 'Python Stderr Output Test: '
                import sys
                print >>sys.stderr, '%sWas log level Error used?' % (pythonStderrMsg)
              </script>

              <script>
                request = 'QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME "STAX_Job_%s_User" LEVELMASK "Error" STARTSWITH "%s" LAST 1' % \
                               (STAXJobID, pythonStderrMsg)
              </script>

              <log message="1">'STAF local LOG %s' % (request)</log>

              <stafcmd>
                <location>'local'</location>
                <service>'LOG'</service>
                <request>request</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == 0 and len(STAFResult) == 1,
                'failMsg': 'Error:  Python print >>sys.stderr statement did not write a message beginning with %s with log level Error to %s.  RC=%s STAFResult=%s' % \
                              (pythonStderrMsg, STAXJobUserLog, RC, STAFResult),
                'sendToMonitor': 1,
                'recordStatus': 1 }
              </call>

            </sequence>
          </if>
          
          <!-- Test running a STAX job that returns a STAXGlobal variable that contains a Python list -->

          <log message="1">'STAX: Test running a job that returns a STAXGlobal variable that contains a Python list'</log>

          <script> 
            gList = STAXGlobal([1, 'One', {'key1': 'value1'}])

            # Create a xml file to be used on a STAX EXECUTE request that returns a STAXGlobal that contains a Python list
            # Create a file called STAXReturnGlobalList.xml in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            xmlFileName = '%s/STAXReturnGlobalList.xml' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            xmlFile = open(xmlFileName, 'wt')

            # Write a STAX xml job to the file that includes { in a message logged
            xmlFile.writelines([ '&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>\n',
                                  '&lt;!DOCTYPE stax SYSTEM "stax.dtd">\n',
                                  '&lt;stax>\n',
                                  '  &lt;function name="FunctionA">\n',
                                  '    &lt;return>"%s"&lt;/return>\n' % (gList),
                                  '  &lt;/function>\n',
                                  '&lt;/stax>\n' ])
            xmlFile.close()

            request = 'EXECUTE JOBNAME "Return Job Result Test" FUNCTION FunctionA WAIT 10m RETURNRESULT FILE "%s"' % (xmlFileName)
          </script>
          
          <log message="1">'STAX:  %s' % (request)</log>
          
          <stafcmd>
            <location>'local'</location>
            <service>'STAX'</service>
            <request>request</request>
          </stafcmd>
          
          <script>
            if RC == 0:
              completedJobID = STAFResult['jobID']
            else:
              completedJobID = None
          </script>

          <!-- XXX: On following call, get "TypeError: sequence subscript must be an integer or slice" and STAXPythonEvaluationError
              and STAFTest terminates on solaris-x64-64 and other operating systems.  Maybe when move to Jython 2.5.2 this
              problem will be resolved?  But, for now, commenting out.
          
          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0 and STAFResult['status'] == 'Normal' and eval(STAFResult['result']) == gList, 
            'passMsg':  'STAX job returned expected result: %s' % (STAFResult['result']),
            'failMsg': 'Error:  STAX job did not return expected result.  RC=%s JobID=%s Status=%s STAFResult=%s\nJob Result=%s\nExpected Job Result: %s' % \
            (RC, STAFResult['jobID'], STAFResult['status'], STAFResult, eval(STAFResult['result']), gList),
            'sendToMonitor': 1,
            'recordStatus': 1 }
          </call>
          -->

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0 and STAFResult['status'] == 'Normal' and str(STAFResult['jobLogErrors']) == '[]',
            'failMsg': 'Error:  "STAF local STAX %s" did not return expected result.  RC: %s Result:\n%s' % \
                       (request, RC, STAFResultContext),
            'sendToMonitor': 1,
            'recordStatus': 1 }
          </call>

          <if expr="completedJobID != None">
            <sequence>
              <!-- Test the STAX GET RESULT request -->
              
              <script>
                request = 'GET RESULT JOB %s' % (completedJobID)
              </script>

              <log message="1">'STAX:  %s' % (request)</log>

              <stafcmd>
                <location>'local'</location>
                <service>'STAX'</service>
                <request>request</request>
              </stafcmd>

              <if expr="RC == 0">
                <sequence>
                  <if expr="str(STAFResult['jobLogErrors']) != '[]'">
                    <call function="'STAXUtilCheckSuccess'">
                      { 'result': 1 == 1,
                        'failMsg': 'Error:  "STAF local STAX %s" did not return expected result because jobLogErrors is not an empty list, Result:\n%s' % \
                                   (request, STAFResultContext),
                        'sendToMonitor': 1,
                        'recordStatus': 1 }
                    </call>
                  </if>
                </sequence>
              </if>

              <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == 0 and STAFResult['status'] == 'Normal',
                'failMsg': 'Error:  "STAF local STAX %s" did not return expected result.  RC: %s Result:\n%s' % \
                           (request, RC, STAFResultContext),
                'sendToMonitor': 1,
                'recordStatus': 1 }
              </call>

              <!-- Test the STAX GET RESULT DETAILS request -->

              <script>
                request = 'GET RESULT JOB %s DETAILS' % (completedJobID)
              </script>

              <log message="1">'STAX:  %s' % (request)</log>

              <stafcmd>
                <location>'local'</location>
                <service>'STAX'</service>
                <request>request</request>
              </stafcmd>

              <if expr="RC == 0">
                <sequence>
                  <if expr="str(STAFResult['jobLogErrors']) != '[]'">
                    <call function="'STAXUtilCheckSuccess'">
                      { 'result': 1 == 1,
                        'failMsg': 'Error:  "STAF local STAX %s" did not return expected result because jobLogErrors is not an empty list, Result:\n%s' % \
                                   (request, STAFResultContext),
                        'sendToMonitor': 1,
                        'recordStatus': 1 }
                    </call>
                  </if>
                </sequence>
              </if>

              <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == 0 and STAFResult['status'] == 'Normal',
                'failMsg': 'Error:  "STAF local STAX %s" did not return expected result.  RC: %s Result:\n%s' % \
                           (request, RC, STAFResultContext),
                'sendToMonitor': 1,
                'recordStatus': 1 }
              </call>
            </sequence>
          </if>

          <!-- Delete the xml file now that we're done with it -->
          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'DELETE ENTRY %s CONFIRM' % (xmlFileName)</request>
          </stafcmd>

          <!-- Test running a STAX sub-job that returns a STAXGlobal variable that contains a Python list -->

          <log message="1">'STAX: Test running a sub-job that returns a STAXGlobal variable that contains a Python list'</log>
          <script>
            # Create a file called STAXReturnResultTest.xml in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            xmlFileName = '%s/STAXReturnResultTest.xml' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            xmlFile = open(xmlFileName, 'wt')

            # Write a STAX xml job to the file that returns a STAXGlobal variable that contains a list
            xmlFile.writelines([ '&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>\n',
                                  '&lt;!DOCTYPE stax SYSTEM "stax.dtd">\n',
                                  '&lt;stax>\n',
                                  '  &lt;defaultcall function="FunctionA"/>\n',
                                  '  &lt;function name="FunctionA">\n',
                                  "    &lt;return>STAXGlobal([1, 'One', {'key1': 'value1'}])&lt;/return>\n",
                                  '  &lt;/function>\n',
                                  '&lt;/stax>\n' ])
            xmlFile.close()
          </script>

          <job>
            <job-file>xmlFileName</job-file>
          </job>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0 and STAXSubJobStatus == 'Normal' and STAXResult == gList, 
            'passMsg':  'STAX sub-job returned expected result: %s' % (STAXResult),
            'failMsg': 'Error:  STAX sub-job did not return expected result.' + \
                         '\nRC=%s STAFResult=%s STAXSubJobID=%s STAXSubJobStatus=%s STAXResult=%s\nExpected STAXResult: %s' % \
                         (RC, STAFResult, STAXSubJobID, STAXSubJobStatus, STAXResult, gList),
            'sendToMonitor': 1,
            'recordStatus': 1 }
          </call>
          
          <!-- Delete the xml file now that we're done with it -->
          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'DELETE ENTRY %s CONFIRM' % (xmlFileName)</request>
          </stafcmd>

          <!-- Test running a STAX sub-job that includes a testcase element and specify
                logtcstartstop="'Enabled'" and verify that a Start and Stop record for the testcase
                is logged in the sub-job's job log. -->
             
          <log message="1">'STAX: Test that running a sub-job with the logtcstartstop enabled logs start/stop testcase entries in its STAX Job Log'</log>
          <script>
            # Create a file called STAXSubJobTest.xml in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            xmlFileName = '%s/STAXSubJobTest.xml' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            xmlFile = open(xmlFileName, 'wt')

            # Write a STAX xml job to the file that includes a testcase element
            xmlFile.writelines([ '&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>\n',
                                  '&lt;!DOCTYPE stax SYSTEM "stax.dtd">\n',
                                  '&lt;stax>\n',
                                  '  &lt;defaultcall function="FunctionA"/>\n',
                                  '  &lt;function name="FunctionA">\n',
                                  '    &lt;testcase name="\'TestA\'">\n',
                                  '      &lt;tcstatus result="\'pass\'"/>\n',
                                  '    &lt;/testcase>\n',
                                  '  &lt;/function>\n',
                                  '&lt;/stax>\n' ])
            xmlFile.close()
          </script>

          <job logtcstartstop="'enabled'" clearlogs="'enabled'">
            <job-file>xmlFileName</job-file>
          </job>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0 and STAXSubJobStatus == 'Normal', 
            'failMsg': 'Error:  STAX sub-job using logtcstartstop did not run successfully.' + \
                         '\nRC=%s STAFResult=%s STAXSubJobID=%s STAXSubJobStatus=%s STAXResult=%s' % \
                         (RC, STAFResult, STAXSubJobID, STAXSubJobStatus, STAXResult),
            'sendToMonitor': 1,
            'recordStatus': 1 }
          </call>

          <!-- Verify that the STAX sub job's STAX Job Log contains a start and stop record for testcase 'TestA' -->
          
          <script>
            testcaseString = 'Testcase: TestA'
            request = 'QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME "STAX_Job_%s" LEVELMASK Start STARTSWITH "%s" LAST 1' % \
                          (STAXSubJobID, testcaseString)
          </script>

          <log message="1">'STAF local LOG %s' % (request)</log>

          <stafcmd>
            <location>'local'</location>
            <service>'LOG'</service>
            <request>request</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0 and len(STAFResult) == 1,
            'failMsg': 'Error:  A testcase start record for "Testcase: TestA" was not written to STAX_Job_%s.  RC=%s STAFResult=%s' % \
                          (STAXSubJobID, RC, STAFResult),
            'sendToMonitor': 1,
            'recordStatus': 1 }
          </call>

          <!-- Delete the xml file now that we're done with it -->
          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'DELETE ENTRY %s CONFIRM' % (xmlFileName)</request>
          </stafcmd>

          <!-- Test with LOG service resolving variables in messages.
                 Make sure that messages containing { but not for a variable get logged properly in the STAX Service log and STAX Job Log
                 and make sure that messages containing STAF variables in the STAX Job User Log get resolved correctly. -->

          <log message="1">'STAX: Test when using LOG service configured to resolve variables in messages'</log>

          <stafcmd>      
            <location>'local'</location>
            <service>'LOG'</service>
            <request>'SET RESOLVEMESSAGE'</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0, 
            'failMsg': 'Error:  STAF local LOG SET RESOLVEMESSAGE failed.  RC=%s STAFResult=%s' % \
            (RC, STAFResult), 'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <script> 
            # Create a file called STAXXmlResVarTest.xml in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            xmlFileName = '%s/STAXXMLResVarTest.xml' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            xmlFile = open(xmlFileName, 'wt')

            # Write a STAX xml job to the file that includes { in a message logged
            xmlFile.writelines([ '&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>\n',
                                  '&lt;!DOCTYPE stax SYSTEM "stax.dtd">\n',
                                  '&lt;stax>\n',
                                  '  &lt;defaultcall function="main"/>\n',
                                  '  &lt;function name="main">\n',
                                  '    &lt;sequence>\n',
                                  '      &lt;log>"STAXArg=%s" % (STAXArg)&lt;/log>\n',
                                  '      &lt;log>"Machine={STAF/Config/Machine}"&lt;/log>\n',
                                  '      &lt;log>"{NoExist}"&lt;/log>\n',
                                  '    &lt;/sequence>\n',
                                  '  &lt;/function>\n',
                                  '&lt;/stax>\n' ])

            xmlFile.close()
            
            request = 'EXECUTE JOBNAME "Resolve Vars in Logged Messages Test"  ARGS "{\'x\':1}" CLEARLOGS WAIT 10m FILE "%s"' % (xmlFileName)
          </script>
          
          <log message="1">'STAX:  %s' % (request)</log>
          
          <stafcmd>
            <location>'local'</location>
            <service>'STAX'</service>
            <request>request</request>
          </stafcmd>

          <script>
            staxRC = RC
            if RC == 0:
              jobID = STAFResult
          </script>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0, 
            'passMsg':  'STAX job completed successfully: %s' % (STAFResult),
            'failMsg': 'Error:  STAX job did not complete successfully.  RC=%s STAFResult=%s' % \
            (RC, STAFResult),
            'sendToMonitor': 1, 'recordStatus': 1 }
          </call>
          
          <!-- Delete the xml file now that we're done with it -->
          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'DELETE ENTRY %s CONFIRM' % (xmlFileName)</request>
          </stafcmd>

          <if expr="staxRC == 0">
            <sequence>
              <script>
              subjobID = int(jobID)
              requestList = []
            
              # Verify that a start record exists in the STAX_Service log for this sub-job
              requestList.append('QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME STAX_Service LEVELMASK "Start" CSCONTAINS "JobID: %s," LAST 1' % (subjobID))
            
              # Verify that a start record exists in the STAX Job Log for this sub-job
              requestList.append('QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME STAX_Job_%s LEVELMASK "Start" CSCONTAINS "JobID: %s," LAST 1' % (subjobID, subjobID))

              # Verify that the STAX Job User Log for this sub-job contains these messages:
              requestList.append('QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME STAX_Job_%s_User LEVELMASK "Info" CSCONTAINS "STAXArg=" LAST 1' % (subjobID))
              requestList.append('QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME STAX_Job_%s_User LEVELMASK "Info" CSCONTAINS "Machine=" LAST 1' % (subjobID))
              requestList.append('QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME STAX_Job_%s_User LEVELMASK "Info" CSCONTAINS "^{NoExist}" LAST 1' % (subjobID))
              </script>

              <iterate var="request" in="requestList">
                <sequence>

                  <stafcmd>
                    <location>'local'</location>
                    <service>'LOG'</service>
                    <request>request</request>
                  </stafcmd>

                  <call function="'STAXUtilCheckSuccess'">
                  { 'result': RC == 0 and len(STAFResult) == 1, 
                    'failMsg': 'Error:  STAF local LOG %s failed.  RC=%s STAFResult=%s' % (request, RC, STAFResult),
                    'sendToMonitor': 1, 'recordStatus': 1 }
                  </call>

                </sequence>
              </iterate>
            </sequence>
          </if>
          
          <stafcmd>      
            <location>'local'</location>
            <service>'LOG'</service>
            <request>'SET NORESOLVEMESSAGE'</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0, 
            'failMsg': 'Error:  STAF local LOG SET RESOLVEMESSAGE failed.  RC=%s STAFResult=%s' % \
            (RC, STAFResult), 'sendToMonitor': 1, 'recordStatus': 1 }
          </call>

          <!-- Test that terminated stafcmds are removed from STAX LIST STAFCMDS (Bug #2230305) -->

          <log message="1">'STAX: Test that terminated stafcmds are removed from STAX LIST STAFCMDS request'</log>
          <block name="'TimerTermStafcmd'">
            <sequence>

              <script>
                # Must be a unique stafcmd name for this job
                stafcmdName = 'STAFTest/STAX/TimerTermStafcmd: Delay 30s'
              </script>

              <timer duration="'3s'">
                <sequence>

                  <stafcmd name="stafcmdName">
                    <location>'local'</location>
                    <service>'DELAY'</service>
                    <request>'DELAY 30s'</request>
                  </stafcmd>

                </sequence>
              </timer>

              <if expr="RC != 1">
                <call function="'STAXUtilCheckSuccess'">
                  { 'result': RC != 1, 
                    'failMsg': 'Error:  Timer did not pop after 3s and terminate the DELAY 30s request, Timer RC=%s' % (RC),
                    'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
              </if>

              <!-- Now verify that the stafcmd does not show up in a STAX LIST JOB STAFCMDS request -->

              <script>
                request = 'LIST JOB %s STAFCMDS' % (STAXJobID)
              </script>

              <stafcmd name="'Check if DELAY stafcmd has been removed'">
                <location>'local'</location>
                <service>'STAX'</service>
                <request>request</request>
              </stafcmd>
              
              <if expr="RC != 0">
                <call function="'STAXUtilCheckSuccess'">
                  { 'result': RC == 0, 
                    'failMsg': 'Error:  STAF local STAX %s failed.  RC=%s STAFResult=%s' % \
                    (request, RC, STAFResult), 'sendToMonitor': 1, 'recordStatus': 1 }
                </call>
                <else>
                  <sequence>
                    <script>
                      stafcmdExists = 0
                      if len(STAFResult) > 0:
                        for stafcmd in STAFResult:
                          if stafcmd['stafcmdName'] == stafcmdName:
                            stafcmdExists = 1
                    </script>
                    <call function="'STAXUtilCheckSuccess'">
                      { 'result': not stafcmdExists, 
                        'passMsg': 'STAX LIST JOB STAFCMDS does not show timer terminated stafcmd',
                        'failMsg': 'Error:  Timer terminated DELAY stafcmd is still in result from "STAF local STAX %s".  STAFResult=%s' % \
                                     (request, STAFResultContext), 'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                  </sequence>
                </else>
              </if>

              <parallel>

                <block name="'DelayBlock'">
                  <sequence>
                    <stafcmd name="stafcmdName">
                      <location>'local'</location>
                      <service>'DELAY'</service>
                      <request>'DELAY 30s'</request>
                    </stafcmd>
                  </sequence>
                </block>

                <sequence>

                  <stafcmd name="'Delay 3s'">
                    <location>'local'</location>
                    <service>'DELAY'</service>
                    <request>'DELAY 3s'</request>
                  </stafcmd>

                  <script>
                    request = 'TERMINATE JOB %s BLOCK %s.DelayBlock' % (STAXJobID, STAXCurrentBlock)
                  </script>

                  <stafcmd name="'Terminate DelayBlock'">
                    <location>'local'</location>
                    <service>'STAX'</service>
                    <request>request</request>
                  </stafcmd>

                  <call function="'STAXUtilCheckSuccess'">
                    { 'result': RC == 0, 
                      'failMsg': 'Error:  STAF local STAX %s failed.  RC=%s STAFResult=%s' % \
                      (request, RC, STAFResult), 'sendToMonitor': 1, 'recordStatus': 1 }
                  </call>

                  <!-- Now check if the stafcmd still exists in a STAX LIST JOB STAFCMDS request -->

                  <script>
                    request = 'LIST JOB %s STAFCMDS' % (STAXJobID)
                  </script>

                  <stafcmd name="'Check if DELAY stafcmd still exists in STAX LIST STAFCMDS'">
                    <location>'local'</location>
                    <service>'STAX'</service>
                    <request>request</request>
                  </stafcmd>

                  <if expr="RC != 0">
                    <call function="'STAXUtilCheckSuccess'">
                      { 'result': RC == 0, 
                        'failMsg': 'Error:  STAF local STAX %s failed.  RC=%s STAFResult=%s' % \
                        (request, RC, STAFResult), 'sendToMonitor': 1, 'recordStatus': 1 }
                    </call>
                    <else>
                      <sequence>
                        <script>
                          stafcmdExists = 0
                          if len(STAFResult) > 0:
                            for stafcmd in STAFResult:
                              if stafcmd['stafcmdName'] == stafcmdName:
                                stafcmdExists = 1
                        </script>
                        <call function="'STAXUtilCheckSuccess'">
                          { 'result': not stafcmdExists, 
                            'passMsg': 'STAX LIST JOB STAFCMDS does not show block terminated stafcmd',
                            'failMsg': 'Error:  Block terminated DELAY stafcmd is still in result from "STAF local STAX %s".  STAFResult=%s' % \
                                         (request, STAFResultContext), 'sendToMonitor': 1, 'recordStatus': 1 }
                        </call>
                      </sequence>
                    </else>
                  </if>

                </sequence>
              </parallel>

            </sequence>
          </block>

          <!-- Test the Jython unmarshall method. Test passing input data that is invalid marshalled data -->
          
          <log message="1">'STAX: Test Jython unmarshall() passing in invalid marshalled data'</log>

          <script>
            data = (
                "@SDT/{:177::2:RC@SDT/$S:1:0:6:IPInfo@SDT/$S:36:" +
                "9.42.126.76|255.255.252.0|9.42.124.1:3:Msg@SDT/$S:46:Static IP " +
                "arguments are processed successfully:9:Timestamp@SDT/$S:19:2009-01-16 14:41:45" +
                "Connecting to: http://9.42.106.28:8080")
            mc = STAFMarshalling.unmarshall(data)
            rootObject = mc.getRootObject()
          </script>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': rootObject == data, 
              'failMsg': 'Error:  Jython unmarshall method did not work correctly for invalid marshalled data' + \
              '\n  rootObject: %s\n  data      : %s' % (rootObject, data),  'sendToMonitor': 1, 'recordStatus': 1
            }
          </call>
          
          <!-- Test that a process can return a file containing valid marshalled data and that it will be
                provided in its marshalled string format  -->

          <log message="1">'STAX: Test process can return a file containing valid marshalled data as a string'</log>
          <script> 
            # Create a file called STAXMarshalledData.out in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            mdFileName = '%s/STAXMarshalledData.out' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            mdFile = open(mdFileName, 'wt')

            # Write valid marshalled data to the file
            marshalledData = '@SDT/{:177::2:RC@SDT/$S:1:0:6:IPInfo@SDT/$S:36:9.42.126.76x255.255.252.0x9.42.124.1' + \
                ':3:Msg@SDT/$S:46:Static IP arguments are processed successfully' + \
                ':9:Timestamp@SDT/$S:19:2009-01-16 14:41:45'

            mdFile.writelines([marshalledData])
            mdFile.close()
          </script>

          <process name="'Process that returns marshalled data'">
            <location>'local'</location>
            <command mode="'shell'">'echo xyz'</command>
            <returnfile>mdFileName</returnfile>
          </process>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == 0 and STAXResult != None and STAXResult[0][1] == marshalledData, 
              'failMsg': 'Error:  File returned by process does not contain the original valid marshalled data string' + \
              '\n  Process RC=%s, STAFResult=%s\n  STAXResult  : %s\n  Original Data: %s' % \
              (RC, STAFResult, STAXResult, marshalledData),
              'sendToMonitor': 1, 'recordStatus': 1
            }
          </call>
          
          <!-- Test that a process can return a file containing invalid marshalled data and that it will be
                provided in its marshalled string format  -->

          <log message="1">'STAX: Test process can return a file containing invalid marshalled data as a string'</log>
          <script> 
            # Create a file called STAXMarshalledData.out in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            mdFileName = '%s/STAXMarshalledData.out' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            mdFile = open(mdFileName, 'wt')

            # Write valid marshalled data to the file
            marshalledData = '@SDT/{:177::2:RC@SDT/$S:1:0:6:IPInfo@SDT/$S:36:9.42.126.76x255.255.252.0x9.42.124.1' + \
                ':3:Msg@SDT/$S:46:Static IP arguments are processed successfully' + \
                ':9:Timestamp@SDT/$S:19:2009-01-16 14:41:45' + 'XXXXX'

            mdFile.writelines([marshalledData])
            mdFile.close()
          </script>

          <process name="'Process that returns marshalled data'">
            <location>'local'</location>
            <command mode="'shell'">'echo xyz'</command>
            <returnfile>mdFileName</returnfile>
          </process>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == 0 and STAXResult != None and STAXResult[0][1] == marshalledData, 
              'failMsg': 'Error:  File returned by process does not contain the original invalid marshalled data string' + \
              '\n  Process RC=%s, STAFResult=%s\n  STAXResult  : %s\n  Original Data: %s' % \
             (RC, STAFResult, STAXResult, marshalledData),
              'sendToMonitor': 1, 'recordStatus': 1
            }
          </call>

          <!-- Test that a stafcmd sets variable STAFResultString to the result string by
                doing a FS GET FILE of a file that contains valid marshalled data and verify
                that the STAFResultString contains the file contents.  -->

          <log message="1">'STAX: Test stafcmd sets variable STAFResultString'</log>

          <script> 
            # Create a file called STAXMarshalledData.out in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            mdFileName = '%s/STAXMarshalledData.out' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            mdFile = open(mdFileName, 'wt')

            # Write valid marshalled data to the file
            marshalledData = '@SDT/{:177::2:RC@SDT/$S:1:0:6:IPInfo@SDT/$S:36:9.42.126.76x255.255.252.0x9.42.124.1' + \
                ':3:Msg@SDT/$S:46:Static IP arguments are processed successfully' + \
                ':9:Timestamp@SDT/$S:19:2009-01-16 14:41:45'

            mdFile.writelines([marshalledData])
            mdFile.close()
          </script>

          <stafcmd name="'FS GET FILE'">
            <location>'local'</location>
            <service>'FS'</service>
            <request>'GET FILE %s' % (mdFileName)</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == 0 and STAFResultString == marshalledData, 
              'failMsg': 'Error:  STAFResultString does not contain a marshalled data string (the contents of the file)' + \
              '\n  RC=%s, STAFResult=%s\n  STAFResultString: %s\n  File Contents   : %s' % \
              (RC, STAFResult, STAFResultString, marshalledData),
              'sendToMonitor': 1, 'recordStatus': 1
            }
          </call>

          <!-- Test that when a stafcmd returns a result that contains invalid marshalled
                data, no errors occur in the Java unmarshall method (called due to auto-
                unmarshalling) or in the Jython unmarshall method (called by
                STAXSTAFCommandAction.java).  Verify that the result contains the
                invalid data is properly unmarshalled as much as possible.   -->

          <log message="1">'STAX: Test Java and Jython unmarshall methods for invalid marshalled data'</log>

          <script> 
            # Create a file called STAXMarshalledData.out in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            mdFileName = '%s/STAXMarshalledData.out' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            mdFile = open(mdFileName, 'wt')

            # Write a combination of valid and invalid marshalled data to the file
            marshalledData = '@SDT/{:177::2:RC@SDT/$S:1:0:6:IPInfo@SDT/$S:36:9.42.126.76x255.255.252.0x9.42.124.1' + \
                ':3:Msg@SDT/$S:46:Static IP arguments are processed successfully' + \
                ':9:Timestamp@SDT/$S:19:2009-01-16 14:41:45' + 'XXXXX'

            mdFile.writelines([marshalledData])
            mdFile.close()
          </script>

          <stafcmd name="'FS GET FILE'">
            <location>'local'</location>
            <service>'FS'</service>
            <request>'GET FILE %s' % (mdFileName)</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == 0 and STAFResult == marshalledData, 
              'failMsg': 'Error:  STAFResult does not contain the invalid marshalled data string (the contents of the file)' + \
              '\n  RC=%s, STAFResult=%s\n  File Contents   : %s' % (RC, STAFResult, marshalledData),
              'sendToMonitor': 1, 'recordStatus': 1
            }
          </call>

          <log message="1">'STAX: Test Java and Jython unmarshall methods for partially invalid marshalled data'</log>

          <script> 
            # Create a file called STAXMarshalledData.out in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            mdFileName = '%s/STAXMarshalledData.out' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            mdFile = open(mdFileName, 'wt')

            # Write a combination of valid and invalid marshalled data to the file
            marshalledData = '@SDT/{:177::2:RC@SDT/$S:1:0:6:IPInfo@SDT/$S:36:9.42.126.76,255.255.252.0,9.42.124.1' + \
                ':3:Msg@SDT/$S:46:Static IP arguments are processed successfully' + \
                ':9:Timestamp@SDT/{:39::4:Year:@SDT/$S:4:2009:5:Month:@SDT/xxx'

            mdFile.writelines([marshalledData])
            mdFile.close()
          </script>

          <stafcmd name="'FS GET FILE'">
            <location>'local'</location>
            <service>'FS'</service>
            <request>'GET FILE %s' % (mdFileName)</request>
          </stafcmd>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC == 0 and STAFResult == marshalledData, 
              'failMsg': 'Error:  STAFResult does not contain the invalid marshalled data in the file' + \
              '\n  RC=%s, STAFResult=%s\n' % (RC, STAFResult),
              'sendToMonitor': 1, 'recordStatus': 1
            }
          </call>

          <!-- Test running a STAX sub-job that uses the exception stack trace -->

          <log message="1">'STAX: Test running a STAX sub-job that uses the exception stack trace'</log>
          <script>
            # Create a file called STAXTestExceptionStackTrace.xml in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            xmlFileName = '%s/STAXTestExceptionStackTrace.xml' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            xmlFile = open(xmlFileName, 'wt')

            # Write a STAX xml job to the file that uses the exception stack trace
            xmlFile.writelines([ '&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>\n',
                                  '&lt;!DOCTYPE stax SYSTEM "stax.dtd">\n',
                                  '&lt;stax>\n',
                                  '  &lt;defaultcall function="FunctionA"/>\n',
                                  '  &lt;function name="FunctionA">\n',
                                  '    &lt;try>\n',
                                  '      &lt;throw exception="\'STAFTestException\'"/>\n',
                                  '      &lt;catch exception="\'...\'" typevar="exceptionType" var="eInfo" sourcevar="eSource">\n',
                                  '        &lt;return>eSource&lt;/return>\n',
                                  '      &lt;/catch>\n',
                                  '    &lt;/try>\n'
                                  '  &lt;/function>\n',
                                  '&lt;/stax>\n' ])
            xmlFile.close()
          </script>

          <job>
            <job-file>xmlFileName</job-file>
          </job>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': (RC == 0 and STAXSubJobStatus == 'Normal' and
                       STAXResult.getSource().find('throw: STAFTestException (Line: 7,') == 0 and
                       STAXResult.getStackTrace()[0].find('function: FunctionA (Line: 5,') == 0),
            'failMsg': 'Error:  STAX sub-job did not return expected result.' + \
                         '\nRC=%s STAFResult=%s STAXSubJobID=%s STAXSubJobStatus=%s STAXResult=%s\n' % \
                         (RC, STAFResult, STAXSubJobID, STAXSubJobStatus, STAXResult),
            'sendToMonitor': 1,
            'recordStatus': 1 }
          </call>

          <!-- Delete the xml file now that we're done with it -->
          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'DELETE ENTRY %s CONFIRM' % (xmlFileName)</request>
          </stafcmd>

          <!-- Test that if a finally element completes very quickly, it does not hang the STAX job (Bug #2832883) -->

          <log message="1">'STAX: Test that the STAX job does not hang if a finally element completes very quickly'</log>
           
          <try>
            <stafcmd>
              <location>'local'</location> 
              <service>'DELAY'</service>
              <request>'DELAY 1s'</request>
            </stafcmd>
            <finally>
              <nop/>
            </finally>
          </try>
          
          <!-- To not hang in the above finally element, e.g. to be here, indicates success -->
          <call function="'STAXUtilCheckSuccess'">
            { 'result': 1 == 1, 
              'failMsg': 'Error:  Problem when finally element completed very quickly',
              'sendToMonitor': 1, 'recordStatus': 1
            }
          </call>

          <!-- Test maxthreads attribute on paralleliterate element -->

          <log message="1">'STAX: Test using paralleliterate maxthreads attribute'</log>

          <script>
            listSize = 100
            maxThreads = 5
            gNumPassList = STAXGlobal([])

            # Initialize each entry in the list to be 0
            for i in range(listSize):
              gNumPassList.append(0)
          </script>

          <paralleliterate var="counter" in="range(0, listSize)" maxthreads="maxThreads">
            <script>gNumPassList[counter] += 1</script>
          </paralleliterate>

          <script>
            # Accumulate passes for each paralleliteration
            totalPasses = 0
            for i in range(listSize):
              totalPasses += gNumPassList[i]
          </script>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': totalPasses == listSize,
              'failMsg': 'Error using maxthreads on paralleliterate, totalPasses(%s) != listSize(%s)' % \
                         (totalPasses, listSize),
              'sendToMonitor': 1, 'recordStatus': 1
            }
          </call>
          
          <!-- Test the hold element -->

          <log message="1">'STAX: Test holding job with a 2s timeout'</log>
          <hold timeout="'2s'"/>

          <log message="1">'STAX: Test holding job with a if attribute that evaluates to false and an infinite timeout'</log>
          <hold if="0" timeout="0"/>
          
          <!-- Test the job-hold element -->

          <log message="1">'STAX: Test running a sub-job with a 5 second hold'</log>
          <script>
            # Create a file called STAXReturnResultTest.xml in theSTAXJobTestDir on the
            # STAX (local) machine with line-endings appropriate for the STAX machine's platform
            xmlFileName = '%s/STAXReturnResultTest.xml' % (theSTAXJobTestDir)

            # Open the file in write ('w') and text('t') mode.  Text mode means the appropriate line-endings with be set by Python.
            xmlFile = open(xmlFileName, 'wt')

            # Write a STAX xml job to the file that returns a STAXGlobal variable that contains a list
            xmlFile.writelines([ '&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>\n',
                                  '&lt;!DOCTYPE stax SYSTEM "stax.dtd">\n',
                                  '&lt;stax>\n',
                                  '  &lt;defaultcall function="FunctionA"/>\n',
                                  '  &lt;function name="FunctionA">\n',
                                  "    &lt;return>0&lt;/return>\n",
                                  '  &lt;/function>\n',
                                  '&lt;/stax>\n' ])
            xmlFile.close()
          </script>

          <job>
            <job-file>xmlFileName</job-file>
            <job-hold timeout="'5s'"/>
          </job>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0 and STAXSubJobStatus == 'Normal' and STAXResult == 0, 
            'passMsg':  'STAX sub-job returned expected result: %s' % (STAXResult),
            'failMsg': 'Error:  STAX sub-job did not return expected result.' + \
                         '\nRC=%s STAFResult=%s STAXSubJobID=%s STAXSubJobStatus=%s STAXResult=%s\nExpected STAXResult: %s' % \
                         (RC, STAFResult, STAXSubJobID, STAXSubJobStatus, STAXResult, 0),
            'sendToMonitor': 1,
            'recordStatus': 1 }
          </call>

          <log message="1">'STAX: Test running a sub-job with a 2 second hold'</log>
          <job>
            <job-file>xmlFileName</job-file>
            <job-hold if="1" timeout="'2s'"/>
          </job>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0 and STAXSubJobStatus == 'Normal' and STAXResult == 0, 
            'passMsg':  'STAX sub-job returned expected result: %s' % (STAXResult),
            'failMsg': 'Error:  STAX sub-job did not return expected result.' + \
                         '\nRC=%s STAFResult=%s STAXSubJobID=%s STAXSubJobStatus=%s STAXResult=%s\nExpected STAXResult: %s' % \
                         (RC, STAFResult, STAXSubJobID, STAXSubJobStatus, STAXResult, 0),
            'sendToMonitor': 1,
            'recordStatus': 1 }
          </call>
          
          <log message="1">'STAX: Test running a sub-job with the job-hold if attribute set to false'</log>
          <job>
            <job-file>xmlFileName</job-file>
            <job-hold if="0" timeout="0"/>
          </job>

          <call function="'STAXUtilCheckSuccess'">
          { 'result': RC == 0 and STAXSubJobStatus == 'Normal' and STAXResult == 0, 
            'passMsg':  'STAX sub-job returned expected result: %s' % (STAXResult),
            'failMsg': 'Error:  STAX sub-job did not return expected result.' + \
                         '\nRC=%s STAFResult=%s STAXSubJobID=%s STAXSubJobStatus=%s STAXResult=%s\nExpected STAXResult: %s' % \
                         (RC, STAFResult, STAXSubJobID, STAXSubJobStatus, STAXResult, 0),
            'sendToMonitor': 1,
            'recordStatus': 1 }
          </call>
          
          <!-- Delete the xml file now that we're done with it -->
          <stafcmd>
            <location>'local'</location>
            <service>'FS'</service>
            <request>'DELETE ENTRY %s CONFIRM' % (xmlFileName)</request>
          </stafcmd>

        </sequence>
      </testcase>

      <!--  These STAX tests can only be run on the local machine -->
      <if expr="testMachineIsLocal">
      <script>

      STAXTests = [

        #
        # STAX tests
        #

        [ 'STD:STAX', 'SEM',  'REQUEST MUTEX STAFTest/STAX',
          [ STAFRC.Ok ], r'^$'
        ],
        
        # *** HELP/VERSION Request Tests ***

        [ 'STD:STAX', STAXService, 'VERSION',
          [ STAFRC.Ok ], r'^.*'
        ],

        [ 'STD:STAX', STAXService, 'HELP',
          [ STAFRC.Ok ], r'^.*'
        ],

        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:STAX', STAXService, 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.*'
        ],

        # *** EXECUTE Request Tests ***

        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FUNCTION FunctionA WAIT 10m RETURNRESULT FILE "%s"' % (theXmlFileName),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['jobID']) > 1 and "
          "STAFResult['status'] == 'Normal' and "
          "STAFResult['result'] == 'Success'"
        ],

        [ 'STD:STAX', 'VAR',  'SET VAR STAFTest/STAX/PythonOutput=JVMLog VAR STAFTest/STAX/PythonLogLevel=Debug VAR STAFTest/STAX/Wait=10m',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT {STAFTest/STAX/Wait} RETURNRESULT PYTHONOUTPUT {STAFTest/STAX/PythonOutput} PYTHONLOGLEVEL {STAFTest/STAX/PythonLogLevel}' % (theXmlFileName),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['jobID']) > 2 and "
          "STAFResult['status'] == 'Normal' and "
          "STAFResult['result'] == 'Success'"
        ],

        # Verify specifying an invalid PYTHONOUTPUT value causes an Invalid Value RC to be returned
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 10m RETURNRESULT PYTHONOUTPUT InvalidOutput PYTHONLOGLEVEL Debug' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        
        # Verify specifying an invalid PYTHONLOGLEVEL value causes an Invalid Value RC to be returned
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 10m RETURNRESULT PYTHONOUTPUT Message PYTHONLOGLEVEL InvalidLogLevel' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],

        # Verify specifying an invalid WAIT value causes an Invalid Value RC to be returned

        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT x RETURNRESULT' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 1sec RETURNRESULT' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 9999999999999 RETURNRESULT' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 4294967295 RETURNRESULT' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 4294968s RETURNRESULT' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 71583m RETURNRESULT' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 1194h RETURNRESULT' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 50d RETURNRESULT' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT 8w RETURNRESULT' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],

        # Verify specifying a STAF variable that doesn't exist for the WAIT value causes a VariableDoesNotExist RC to be returned
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA WAIT {DoesNotExist} RETURNRESULT' % (theXmlFileName),
          [ STAFRC.VariableDoesNotExist ], None
        ],

        # Test specifying an invalid HOLD value causes an Invalid Value RC to be returned

        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD x' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD 1sec' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD 9999999999999' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD 4294967295' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD 4294968s' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD 71583m' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD 1194h' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD 50d' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD 8w' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD 1y' % (theXmlFileName),
          [ STAFRC.InvalidValue ], None
        ],

        # Verify specifying a STAF variable that doesn't exist for the HOLD value causes a VariableDoesNotExist RC to be returned
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FILE "%s" FUNCTION FunctionA HOLD {DoesNotExist}' % (theXmlFileName),
          [ STAFRC.VariableDoesNotExist ], None
        ],


        # Verify specifying a valid hold value works
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FUNCTION FunctionA FILE "%s" HOLD 2s' % (theXmlFileName),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult) > 3"
        ],

        # Test the HOLD reques

        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FUNCTION FunctionA FILE "%s" NOTIFY ONEND' % (theXmlFileName),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult) > 3"
        ],

        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FUNCTION FunctionA FILE "%s" NOTIFY ONEND BYNAME' % (theXmlFileName),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult) > 4"
        ],
        
        [ 'STD:STAX', STAXService, 'EXECUTE JOBNAME MySTAFTest FUNCTION FunctionA FILE "%s" NOTIFY ONEND PRIORITY 1' % (theXmlFileName),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult) > 5"
        ],

        # Make sure that testing the job returns 0 even if no starting function is specified
        [ 'STD:STAX', STAXService, 'EXECUTE FILE "%s" JOBNAME MySTAFTest TEST' % (theXmlFileName),
          [ STAFRC.Ok ], None,
          "int(STAFResult) > STAXJobID"
        ],

        # Make sure that testing the job returns 0 if a valid starting function is specified
        [ 'STD:STAX', STAXService, 'EXECUTE FILE "%s" JOBNAME MySTAFTest FUNCTION FunctionA TEST' % (theXmlFileName),
          [ STAFRC.Ok ], None,
          "int(STAFResult) > STAXJobID"
        ],

        # Make sure that testing the job returns 4001 if an invalid starting function is specified
        [ 'STD:STAX', STAXService, 'EXECUTE FILE "%s" JOBNAME MySTAFTest FUNCTION NonExistingFunction TEST' % (theXmlFileName),
          [ 4001 ], None,
          "int(STAFResult['jobID']) > STAXJobID and " +
          "len(STAFResult['errorMsg']) > 0"
        ],

        [ 'STD:STAX', STAXService, 'EXECUTE FILE "%s" JOBNAME MySTAFTest FUNCTION FunctionA TEST RETURNDETAILS' % (theXmlFileName),
          [ STAFRC.Ok ], None,
          "int(STAFResult['jobID']) > STAXJobID and " +
          "STAFResult['defaultCall'] and " +
          "len(STAFResult['functionList']) == 1 and " +
          "STAFResult['functionList'][0]['functionName'] == 'FunctionA' and " +
          "STAFResult['functionList'][0]['prolog'] == '' and " +
          "STAFResult['functionList'][0]['epilog'] == '' and " +
          "STAFResult['functionList'][0]['argDefinition'] == 'FUNCTION_DEFINES_NO_ARGS' and " +
          "len(STAFResult['functionList'][0]['argList']) == 0"
        ],

        [ 'STD:STAX', STAXService, 'EXECUTE DATA "%s" JOBNAME MySTAFTest FUNCTION FunctionA ARGS "[1, 2]" SCRIPT "xyz = 99" SCRIPT "abc = 40" CLEARLOGS Disabled LOGTCELAPSEDTIME Enabled LOGTCNUMSTARTS Enabled LOGTCSTARTSTOP Disabled WAIT 600000 RETURNRESULT' % (xml),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['jobID']) > 1 and " +
          "STAFResult['result'] == 'Success'"
        ],

        # *** GET RESULT Tests ***

        [ 'STD:STAX', STAXService, 'GET RESULT JOB %s' % (STAXJobID),
          [ 4004 ], r'.*'
        ],

        # Test the HOLD request with invalid TIMEOUT values

        [ 'STD:STAX', STAXService, 'HOLD JOB %s TIMEOUT x' % (STAXJobID),
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:STAX', STAXService, 'HOLD JOB %s TIMEOUT 99999999999' % (STAXJobID),
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:STAX', STAXService, 'HOLD JOB %s TIMEOUT 1y' % (STAXJobID),
          [ STAFRC.InvalidValue ], r'.*'
        ],
        [ 'STD:STAX', STAXService, 'HOLD JOB %s TIMEOUT 99999999h' % (STAXJobID),
          [ STAFRC.InvalidValue ], r'.*'
        ],

        # Test the HOLD request with a valid TIMEOUT

        [ 'STD:STAX', STAXService, 'HOLD JOB %s TIMEOUT 5s' % (STAXJobID),
          [ STAFRC.Ok ], r'^$'
        ],

        # *** SET and LIST SETTINGS Request Tests ***

        [ 'STD:STAX', 'VAR',  'SET VAR STAFTest/STAX/Enabled=Enabled VAR STAFTest/STAX/Disabled=Disabled VAR STAFTest/STAX/CacheSize=15 VAR STAFTest/STAX/MaxReturnFileSize=500M VAR STAFTest/STAX/MaxSTAXThreads=500',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'SET CLEARLOGS Disabled',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:STAX', STAXService, 'SET FILECACHING Disabled',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:STAX', STAXService, 'SET MAXSTAXTHREADS 2147483647',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "(STAFResult['resetJobID'] == 'Enabled' or STAFResult['resetJobID'] == 'Disabled') and " +
          "STAFResult['clearLogs'] == 'Disabled' and " +
          "STAFResult['eventMachine'] and STAFResult['eventService'] and " +
          "string.atoi(STAFResult['numThreads']) > 0 and " +
          "string.atoi(STAFResult['processTimeout']) > 0 and " +
          "STAFResult['fileCaching'] == 'Disabled' and " +
          "string.atoi(STAFResult['maxFileCacheSize']) > 0 and " +
          "STAFResult['fileCacheAlgorithm'][0] == 'L' and " +  #  'LRU' | 'LFU'
          "STAFResult['maxFileCacheAge'] and " +
          "string.atoi(STAFResult['maxSTAXThreads']) == 2147483647 and " +
          "len(STAFResult['extensions']) >= 0"
        ],

        [ 'STD:STAX', STAXService, 'SET CLEARLOGS {STAFTest/STAX/Enabled} FILECACHING {STAFTest/STAX/Enabled} MAXFILECACHESIZE {STAFTest/STAX/CacheSize} MAXSTAXTHREADS {STAFTest/STAX/MaxSTAXThreads}',
          [ STAFRC.Ok ], r'^$'
        ],

        # Test setting invalid value for PYTHONOUTPUT
        [ 'STD:STAX', STAXService, 'SET PYTHONOUTPUT InvalidOutput',
          [ STAFRC.InvalidValue ], None
        ],
        
        # Test setting invalid value for PYTHONLOGLEVEL
        [ 'STD:STAX', STAXService, 'SET PYTHONLOGLEVEL InvalidLogLevel',
          [ STAFRC.InvalidValue ], None
        ],

        # Set to default values for PythonOutput and PythonLogLevel
        [ 'STD:STAX', 'VAR',  'SET VAR STAFTest/STAX/PythonOutput=JobUserLogAndMsg VAR STAFTest/STAX/PythonLogLevel=User1',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'SET LogTCElapsedTime DISABLED LogTCNumStarts DISABLED LogTCStartStop DISABLED PYTHONOUTPUT {STAFTest/STAX/PythonOutput} PYTHONLOGLEVEL {STAFTest/STAX/PythonLogLevel}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['clearLogs'] == 'Enabled' and " +
          "STAFResult['logTCElapsedTime'] == 'Disabled' and " +
          "STAFResult['logTCNumStarts'] == 'Disabled' and " +
          "STAFResult['logTCStartStop'] == 'Disabled' and " +
          "STAFResult['fileCaching'] == 'Enabled' and " +
          "string.atoi(STAFResult['maxFileCacheSize']) == 15 and " +
          "string.atoi(STAFResult['maxSTAXThreads']) == 500 and " +
          "STAFResult['pythonOutput'] == 'JobUserLogAndMsg' and " +
          "STAFResult['pythonLogLevel'] == 'User1'"
        ],

        # Delete variables after done using them
        [ 'STD:STAX', 'VAR',  'DELETE VAR STAFTest/STAX/PythonOutput VAR STAFTest/STAX/PythonLogLevel VAR STAFTest/STAX/Wait VAR STAFTest/STAX/MaxSTAXThreads',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'SET LogTCElapsedTime {STAFTest/STAX/Enabled} LogTCNumStarts {STAFTest/STAX/Enabled} LogTCStartStop {STAFTest/STAX/Enabled} MaxFileCacheSize 20 PYTHONOUTPUT JobUserLOG PYTHONLOGLEVEL inFO MaxSTAXThreads 0',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['clearLogs'] == 'Enabled' and " +
          "STAFResult['logTCElapsedTime'] == 'Enabled' and " +
          "STAFResult['logTCNumStarts'] == 'Enabled' and " +
          "STAFResult['logTCStartStop'] == 'Enabled' and " +
          "string.atoi(STAFResult['maxFileCacheSize']) == 20 and " +
          "string.atoi(STAFResult['maxSTAXThreads']) == 0 and " +
          "STAFResult['pythonOutput'] == 'JobUserLog' and " +
          "STAFResult['pythonLogLevel'] == 'Info'"
        ],

        # Test invalid request
        [ 'STD:STAX', STAXService, 'SET',
          [ STAFRC.InvalidRequestString ], None
        ],

        # Test setting MAXRETURNFILESIZE setting
        
        [ 'STD:STAX', STAXService, 'SET MaxReturnFileSize 4294967295',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:STAX', STAXService, 'SET MaxReturnFileSize 4194304K',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:STAX', STAXService, 'SET MaxReturnFileSize 4096M',
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:STAX', STAXService, 'SET MaxReturnFileSize {STAFTest/STAX/MaxReturnFileSize}',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:STAX', STAXService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "string.atol(STAFResult['maxReturnFileSize']) == 524288000L"
        ],

        # Delete variable after done using them
        [ 'STD:STAX', 'VAR',  'DELETE VAR STAFTest/STAX/MaxReturnFileSize',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:STAX', STAXService, 'SET MaxReturnFileSize 4294967294',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:STAX', STAXService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "string.atol(STAFResult['maxReturnFileSize']) == 4294967294L"
        ],

        [ 'STD:STAX', STAXService, 'SET MaxReturnFileSize 4194303K',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:STAX', STAXService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "string.atol(STAFResult['maxReturnFileSize']) == 4294966272L"
        ],

        [ 'STD:STAX', STAXService, 'SET MaxReturnFileSize 4095M',
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:STAX', STAXService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "string.atol(STAFResult['maxReturnFileSize']) == 4293918720L"
        ],
        
        # Return to default settings
        [ 'STD:STAX', STAXService, 'SET ClearLogs Disabled LogTCElapsedTime ENABLED LogTCNumStarts ENABLED LogTCStartStop DISABLED MaxReturnFileSize 0',
          [ STAFRC.Ok ], r'^$'
        ],

        # Test setting FileCacheAlgorithm and MaxFileCacheAge

        [ 'STD:STAX', STAXService, 'SET FileCacheAlgorithm NoExist',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge -1',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge 2147483648',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge 2147483648m',
          [ STAFRC.InvalidValue ], None
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge 2147483647',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', STAXService, 'SET FileCacheAlgorithm LFU',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge 2147483647s',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge 2147483647m',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge 2147483647h',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge 2147483647d',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge 2147483647w',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', STAXService, 'SET MaxFileCacheAge 0d',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', 'VAR',  'SET VAR STAFTest/STAX/FileCacheAlgorithm=LRU VAR STAFTest/STAX/MaxFileCacheAge=0',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', STAXService, 'SET FileCacheAlgorithm {STAFTest/STAX/FileCacheAlgorithm} MaxFileCacheAge {STAFTest/STAX/MaxFileCacheAge}',
          [ STAFRC.Ok ], r'^$'
        ],
        [ 'STD:STAX', 'VAR',  'DELETE VAR STAFTest/STAX/FileCacheAlgorithm VAR STAFTest/STAX/MaxFileCacheAge',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'LIST SETTINGS',
          [ STAFRC.Ok ], None,
          "STAFResult['fileCacheAlgorithm'] == 'LRU' and " +
          "STAFResult['maxFileCacheAge'] == '0' and " +
          "string.atoi(STAFResult['maxReturnFileSize']) == 0 and " +
          "string.atoi(STAFResult['maxSTAXThreads']) == 0 and " +
          "STAFResult['clearLogs'] == 'Disabled' and " +
          "STAFResult['logTCElapsedTime'] == 'Enabled' and " +
          "STAFResult['logTCNumStarts'] == 'Enabled' and " +
          "STAFResult['logTCStartStop'] == 'Disabled'"
        ],

        # LIST FILECACHE Tests

        [ 'STD:STAX', STAXService, 'LIST FILECACHE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['machine'] and " +
          "STAFResult[0]['file'] and " +
          "string.atoi(STAFResult[0]['hits']) >= 0 and " +
          "STAFResult[0]['lastHit'] and " +
          "STAFResult[0]['addDate']"
        ],
        
        [ 'STD:STAX', STAXService, 'LIST FILECACHE SORTBYLRU',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['machine'] and " +
          "STAFResult[0]['file'] and " +
          "string.atoi(STAFResult[0]['hits']) >= 0 and " +
          "STAFResult[0]['lastHit'] and " +
          "STAFResult[0]['addDate']"
        ],
        
        [ 'STD:STAX', STAXService, 'LIST FILECACHE SORTBYLFU',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['machine'] and " +
          "STAFResult[0]['file'] and " +
          "string.atoi(STAFResult[0]['hits']) >= 0 and " +
          "STAFResult[0]['lastHit'] and " +
          "STAFResult[0]['addDate']"
        ],
        
        [ 'STD:STAX', STAXService, 'LIST FILECACHE SUMMARY',
          [ STAFRC.Ok ], None,
          "STAFResult['hitRatio'] >= '0%' and " +
          "string.atoi(STAFResult['hitCount']) >= 0 and " +
          "string.atoi(STAFResult['missCount']) >= 0 and " +
          "string.atoi(STAFResult['requestCount']) >= 0 and " +
          "STAFResult['lastPurgeDate']"
        ],
        
        # LIST MACHINECACHE Tests

        [ 'STD:STAX', STAXService, 'LIST MACHINECACHE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['machine'] and " +
          " STAFResult[0]['fileSep'] and " +
          " string.atoi(STAFResult[0]['hits']) >= 0 and " +
          " STAFResult[0]['lastHit'] and " +
          " STAFResult[0]['addDate'])"
        ],

        # *** LIST EXTENSIONS and LIST EXTENSIONJARFILES and Tests ***

        [ 'STD:STAX', STAXService, 'LIST EXTENSIONS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['extensionElement'] and " +
          " STAFResult[0]['extensionJarFile'])"
        ],

        [ 'STD:STAX', STAXService, 'LIST EXTENSIONJARFILES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['extensionJarFile'] and " +
          " STAFResult[0]['version'] and " +
          " STAFResult[0]['description'])"
        ],

        # *** LIST JOBS Tests ***

        [ 'STD:STAX', STAXService, 'LIST JOBS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "string.atoi(STAFResult[0]['jobID']) > 0 and " +
          "(STAFResult[0]['jobName'] == None or STAFResult[0]['jobName']) and " +
          "STAFResult[0]['startTimestamp'] and " +
          "STAFResult[0]['function']"
        ],

        # *** LIST JOBS TOTAL Tests ***

        [ 'STD:STAX', STAXService, 'LIST JOBS TOTAL',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult) > 0"
        ],

        # *** LIST JOB JobID THREADS Tests ***

        [ 'STD:STAX', STAXService, 'LIST JOB %s THREADS' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 1 and " +
          "string.atoi(STAFResult[0]['threadID']) == 1 and " +
          "STAFResult[0]['parentTID'] == None and " +
          "STAFResult[0]['state'] == 'Running' or STAFResult[0]['state'] == 'Blocked' and "
          "string.atoi(STAFResult[1]['threadID']) > 1 and " +
          "string.atoi(STAFResult[1]['parentTID']) > 0 and " +
          "STAFResult[1]['state'] == 'Running' or STAFResult[0]['state'] == 'Blocked'"
        ],

        [ 'STD:STAX', STAXService, 'LIST JOB %s THREADS LONG' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 1 and " +
          "string.atoi(STAFResult[0]['threadID']) == 1 and " +
          "STAFResult[0]['parentTID'] == None and " +
          "STAFResult[0]['parentHierarchy'] == None and " +
          "STAFResult[0]['state'] == 'Running' or STAFResult[0]['state'] == 'Blocked' and " +
          "STAFResult[0]['startTimestamp'] and " +
          "len(STAFResult[0]['callStack']) > 0 and " +
          "len(STAFResult[0]['conditionStack']) > 0 and " +
          "string.atoi(STAFResult[1]['threadID']) > 1 and " +
          "string.atoi(STAFResult[1]['parentTID']) > 0 and " +
          "STAFResult[1]['parentHierarchy'] and " +
          "STAFResult[1]['state'] == 'Running' or STAFResult[0]['state'] == 'Blocked' and " +
          "STAFResult[1]['startTimestamp'] and " +
          "len(STAFResult[1]['callStack']) > 0 and " +
          "len(STAFResult[1]['conditionStack']) > 0"
        ],

        # *** LIST JOB JobID FUNCTIONS Tests ***

        [ 'STD:STAX', STAXService, 'LIST JOB %s FUNCTIONS' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['function'] and " +
          " STAFResult[0]['file'] and " +
          " STAFResult[0]['machine'])"
        ],

        # *** LIST JOB JobID TESTCASES Tests ***

        [ 'STD:STAX', STAXService, 'LIST JOB %s TESTCASES' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['testcaseName'] and " +
          " string.atoi(STAFResult[0]['numPasses']) >= 0 and " +
          " string.atoi(STAFResult[0]['numFails']) >= 0 and " +
          " STAFResult[0]['elapsedTime'] and " +
          " string.atoi(STAFResult[0]['numStarts']) >= 0) and " +
          " (STAFResult[0]['information'] == '' or STAFResult[0]['information'])"
        ],

        # *** LIST JOB JobID PROCESSES Tests ***

        [ 'STD:STAX', STAXService, 'LIST JOB %s PROCESSES' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['processName'] and " +
          " STAFResult[0]['location'] and " +
          " string.atoi(STAFResult[0]['handle']) > 1 and " +
          " STAFResult[0]['command'] and " +
          # XXX: Should parms be None instead of '' if not assigned?
          " (STAFResult[0]['parms'] == '' or STAFResult[0]['parms']))"
        ],

        # *** LIST JOB JobID STAFCMDS Tests ***

        [ 'STD:STAX', STAXService, 'LIST JOB %s STAFCMDS' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['stafcmdName'] and " +
          " STAFResult[0]['location'] and " +
          " string.atoi(STAFResult[0]['requestNum']) > 0 and " +
          " STAFResult[0]['service'] and " +
          " STAFResult[0]['request'])"
        ],

        # *** LIST JOB JobID SUBJOBS Tests ***

        [ 'STD:STAX', STAXService, 'LIST JOB %s SUBJOBS' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(len(STAFResult) > 0 and " +
          " STAFResult[0]['jobName'] and " +
          " STAFResult[0]['location'] and " +
          " string.atoi(STAFResult[0]['jobID']) > 0 and " +
          " STAFResult[0]['startTimestamp'] and " +
          " STAFResult[0]['function'] and " +
          " STAFResult[0]['request'])"
        ],

        # *** QUERY EXTENSIONJARFILES and QUERY EXTENSIONJARFILE Tests ***

        [ 'STD:STAX', STAXService, 'QUERY EXTENSIONJARFILES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0 or " +
          "(STAFResult[0]['extensionJarFile'] and" +
          " STAFResult[0]['version'] and" +
          " STAFResult[0]['description'] and" +
          " len(STAFResult[0]['parameterList']) >= 0 and" +
          " (STAFResult[0]['serviceExtensions'] == None or" +
          "  (len(STAFResult[0]['serviceExtensions']) > 0 and" +
          "   STAFResult[0]['serviceExtensions']['requiredServiceVersion'] and" +
          "   len(STAFResult[0]['serviceExtensions']['includedElementList']) >= 0 and " +
          "   len(STAFResult[0]['serviceExtensions']['excludedElementList']) >= 0)) and " +
          " (STAFResult[0]['monitorExtensions'] == None or" +
          "  (len(STAFResult[0]['monitorExtensions']) > 0 and" +
          "   STAFResult[0]['monitorExtensions']['requiredMonitorVersion'] and" +
          "   len(STAFResult[0]['monitorExtensions']['extensionNameList']) >= 0)))"
        ],

        [ 'STD:STAX', STAXService, 'QUERY EXTENSIONJARFILE DoesNotExist',
          [ STAFRC.DoesNotExist ], r'^.'
        ],

        # *** QUERY Request Tests ***
        
        [ 'STD:STAX', STAXService, 'QUERY JOB %s' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['jobID']) == %s and " % (STAXJobID) +
          "(STAFResult['jobName'] == None or STAFResult['jobName']) and " +
          "STAFResult['xmlFileName'] and " +
          "STAFResult['fileMachine'] and " +
          "STAFResult['function'] and " +
          "(STAFResult['arguments'] == None or STAFResult['arguments']) and " +
          "len(STAFResult['scriptList']) >= 0 and " +
          "len(STAFResult['scriptFileList']) >= 0 and " +
          "(STAFResult['scriptMachine'] == None or STAFResult['scriptMachine']) and " +
          "STAFResult['startTimestamp'] and " +
          "STAFResult['sourceMachine'] and " +
          "(STAFResult['clearLogs'] == 'Disabled' or STAFResult['clearLogs'] == 'Enabled') and " +
          "(STAFResult['logTCElapsedTime'] == 'Enabled' or STAFResult['logTCElapsedTime'] == 'Disabled') and " +
          "(STAFResult['logTCNumStarts'] == 'Enabled' or STAFResult['logTCNumStarts'] == 'Disabled') and " +
          "(STAFResult['logTCStartStop'] == 'Disabled' or STAFResult['logTCStartStop'] == 'Enabled') and " +
          "(STAFResult['pythonOutput'] == 'JobUserLog' or STAFResult['pythonOutput'] == 'Message' or " +
          " STAFResult['pythonOutput'] == 'JobUserLogAndMsg' or STAFResult['pythonOutput'] == 'JVMLog') and " +
          "STAFResult['pythonLogLevel'] and " +
          "string.atoi(STAFResult['numThreadsRunning']) > 0 and " +
          "string.atoi(STAFResult['numBlocksRunning']) >= 0 and " +
          "string.atoi(STAFResult['numBlocksHeld']) >= 0 and " +
          "string.atoi(STAFResult['numBlocksUnknown']) >= 0"
        ],

        [ 'STD:STAX', STAXService, 'QUERY JOB %s THREAD 1' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['threadID']) == 1 and " +
          "STAFResult['parentTID'] == None and " +
          "STAFResult['startTimestamp'] and " +
          "len(STAFResult['callStack']) > 0 and " +
          "len(STAFResult['conditionStack']) >= 0"
        ],

        [ 'STD:STAX', STAXService, 'QUERY JOB %s FUNCTION DoAll' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "STAFResult['function'] == 'DoAll' and " +
          "STAFResult['file'] and " +
          "STAFResult['machine'] and " +
          "(STAFResult['scope'] == 'local' or STAFResult['scope'] == 'global') and " +
          "len(STAFResult['requires']) > 0 and " +
          "len(STAFResult['imports']) >= 0"
        ],

        [ 'STD:STAX', STAXService, 'QUERY JOB %s TESTCASE TestSTAF' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "STAFResult['testcaseName'] == 'TestSTAF' and " +
          "string.atoi(STAFResult['numPasses']) >= 0 and " +
          "string.atoi(STAFResult['numFails']) >= 0 and " +
          "STAFResult['startedTimestamp'] and " +
          "(STAFResult['lastStatus'] == 'pass' or STAFResult['lastStatus'] == 'fail' or STAFResult['lastStatus'] == 'info' or STAFResult['lastStatus'] == '') and " +
          "(STAFResult['lastStatusTimestamp'] == None or STAFResult['lastStatusTimestamp']) and " +
          "(STAFResult['information'] == '' or STAFResult['information']) and " +
          "STAFResult['elapsedTime'] and " +
          "string.atoi(STAFResult['numStarts']) >= 1 and " +
          "len(STAFResult['testcaseStack']) == 1 and STAFResult['testcaseStack'][0] == 'TestSTAF'"
        ],

        [ 'STD:STAX', STAXService, 'QUERY JOB %s PROCESS nonExistingMachine:99' % (STAXJobID),
          [ STAFRC.DoesNotExist ], r'^.'
        ],

        [ 'STD:STAX', STAXService, 'QUERY JOB %s STAFCMD 99999999' % (STAXJobID),
          [ STAFRC.DoesNotExist ], r'^.'
        ],
 
       # *** NOTIFY Request Tests ***
   
        [ 'STD:STAX', STAXService, 'NOTIFY REGISTER ONENDOFJOB %s' % (STAXJobID),
          [ STAFRC.Ok ], r'^$',
        ],
 
        [ 'STD:STAX', STAXService, 'NOTIFY LIST JOB %s' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['machine'] and " +
          "string.atoi(STAFResult[0]['handle']) > 0 and " +
          "STAFResult[0]['handleName'] and " +
          "STAFResult[0]['notifyBy'] == 'Handle' and " +
          "string.atoi(STAFResult[0]['priority']) == 5"
        ],

        [ 'STD:STAX', STAXService, 'NOTIFY LIST',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "string.atoi(STAFResult[0]['jobID']) > 0 and " +
          "STAFResult[0]['machine'] and " +
          "string.atoi(STAFResult[0]['handle']) > 0 and " +
          "STAFResult[0]['handleName'] and " +
          "(STAFResult[0]['notifyBy'] == 'Handle' or STAFResult[0]['notifyBy'] == 'Name') and " +
          "(string.atoi(STAFResult[0]['priority']) > 0 and string.atoi(STAFResult[0]['priority']) &lt; 6)"
        ],
        
        [ 'STD:STAX', STAXService, 'NOTIFY UNREGISTER ONENDOFJOB %s' % (STAXJobID),
          [ STAFRC.Ok ], r'^$',
        ],
        
        [ 'STD:STAX', STAXService, 'NOTIFY UNREGISTER ONENDOFJOB %s' % (STAXJobID),
          [ STAFRC.DoesNotExist], r'^.',
        ],
        
        [ 'STD:STAX', STAXService, 'NOTIFY LIST JOB %s' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        [ 'STD:STAX', STAXService, 'NOTIFY REGISTER ONENDOFJOB %s BYNAME PRIORITY 1' % (STAXJobID),
          [ STAFRC.Ok ], r'^$',
        ],
 
        # Verify that cannot register again with the same handle/handleName/Machine
        [ 'STD:STAX', STAXService, 'NOTIFY REGISTER ONENDOFJOB %s PRIORITY 4' % (STAXJobID),
          [ STAFRC.AlreadyExists ], r'^.',
        ],

        [ 'STD:STAX', STAXService, 'NOTIFY LIST JOB %s' % (STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['machine'] and " +
          "string.atoi(STAFResult[0]['handle']) > 0 and " +
          "STAFResult[0]['handleName'] and " +
          "STAFResult[0]['notifyBy'] == 'Name' and " +
          "string.atoi(STAFResult[0]['priority']) == 1"
        ],

        # *** LOG MESSAGE Request Tests ***

        [ 'STD:STAX', STAXService, 'LOG JOB %s MESSAGE "Log this message."' % (STAXJobID),
          [ STAFRC.Ok ], r'^$'
        ],

        # Check that an info level record for the above message logged exists in the STAX Job User Log
        [ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s_User LEVELMASK Info LAST 1 CONTAINS "Log this message."' % (STAXMachineNickname, STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1"
        ],

        # Check if non-existing Job ID is specified, get DoesNotExist error
        [ 'STD:STAX', STAXService, 'LOG JOB 9999999 MESSAGE "This message will not be logged."',
          [ STAFRC.DoesNotExist ], None
        ],

        # Check if invalid log level is specified, get InvalidValue error
        [ 'STD:STAX', STAXService, 'LOG JOB %s MESSAGE "This message has an invalid level." LEVEL InvalidLevel' % (STAXJobID),
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:STAX', STAXService, 'LOG JOB %s MESSAGE "This message has level Start." LEVEL Start' % (STAXJobID),
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Check that a start level record for the above message logged exists in the STAX Job User Log
        [ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s_User LEVELMASK Start LAST 1 CONTAINS "This message has level Start."' % (STAXMachineNickname, STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1"
        ],
        
        [ 'STD:STAX', STAXService, 'LOG JOB %s MESSAGE "This message has level Stop." LEVEL Stop SEND' % (STAXJobID),
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Check that a stop level record for the above message logged exists in the STAX Job User Log
        [ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s_User LEVELMASK Stop LAST 1 CONTAINS "This message has level Stop."' % (STAXMachineNickname, STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1"
        ],
        
        # *** SEND MESSAGE Request Tests ***

        [ 'STD:STAX', STAXService, 'SEND JOB %s MESSAGE "Send this message to the STAX Monitor."' % (STAXJobID),
          [ STAFRC.Ok ], r'^$'
        ],

        # Check if non-existing Job ID is specified, get DoesNotExist error
        [ 'STD:STAX', STAXService, 'SEND JOB 9999999 MESSAGE "This message will not be logged."',
          [ STAFRC.DoesNotExist ], None
        ],

        # *** START TESTCASE Request Tests ***

        [ 'STD:STAX', STAXService, 'START JOB %s TESTCASE "%s.test1"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Query the testcase just added and verify its information including its testcase stack
        [ 'STD:STAX', STAXService, 'QUERY JOB %s TESTCASE "%s.test1"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], None,
          "STAFResult['testcaseName'] == '%s.test1' and " % (STAXCurrentTestcase) +
          "string.atoi(STAFResult['numPasses']) == 0 and " +
          "string.atoi(STAFResult['numFails']) == 0 and " +
          "STAFResult['startedTimestamp'] and " +
          "STAFResult['lastStatus'] == None and " +
          "STAFResult['lastStatusTimestamp'] == None and " +
          "STAFResult['information'] == '' and " +
          "STAFResult['elapsedTime'] and " +
          "string.atoi(STAFResult['numStarts']) == 1 and " +
          "len(STAFResult['testcaseStack']) >= 4 and STAFResult['testcaseStack'][0] == 'TestSTAF' and STAFResult['testcaseStack'][len(STAFResult['testcaseStack']) - 1] == '%s.test1'" % (STAXCurrentTestcase)
        ],

        # Check that a start record for the testcase exists in the STAX Job Log
        # XXX: Comment out since "Log TC Starts/Stops may not be enabled"
        #[ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s LEVELMASK Start LAST 1 CONTAINS %s.test1' % (STAXMachineNickname, STAXJobID, STAXCurrentTestcase),
        #  [ STAFRC.Ok ], None,
        #  "len(STAFResult) == 1"
        #],

        # Check if non-existing Job ID is specified, get DoesNotExist error
        [ 'STD:STAX', STAXService, 'START JOB 9999999 TESTCASE newTestname',
          [ STAFRC.DoesNotExist ], None
        ],

        # Check if non-integer Job ID is specified, get InvalidValue error
        [ 'STD:STAX', STAXService, 'START JOB 99999999999999999 TESTCASE newTestname',
          [ STAFRC.InvalidValue ], None
        ],

        # Check if existing testcase name is specified, get AlreadyExists error
        [ 'STD:STAX', STAXService, 'START JOB %s TESTCASE "%s.test1"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.AlreadyExists ], None
        ],
        
        # Check if an invalid parent testcase name is specified, get an InvalidValue error

        [ 'STD:STAX', STAXService, 'START JOB %s TESTCASE "%s.test1" PARENT XXX' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.InvalidValue ], None
        ],

        [ 'STD:STAX', STAXService, 'START JOB %s TESTCASE "%s.test1" PARENT "%s.test1"' % (STAXJobID, STAXCurrentTestcase, STAXCurrentTestcase),
          [ STAFRC.InvalidValue ], None
        ],
        
        [ 'STD:STAX', STAXService, 'START JOB %s TESTCASE "%s.test1" PARENT "%s.tes"' % (STAXJobID, STAXCurrentTestcase, STAXCurrentTestcase),
          [ STAFRC.InvalidValue ], None
        ],

        # Make sure that the START request is resolving JOB and TESTCASE and PARENT values
        [ 'STD:STAX', 'VAR',  'SET VAR STAFTest/STAX/JobID=%s VAR STAFTest/STAX/TestName=%s.test2 VAR STAFTest/STAX/Parent=%s' % (STAXJobID, STAXCurrentTestcase, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'START JOB {STAFTest/STAX/JobID} TESTCASE "{STAFTest/STAX/TestName}" PARENT "{STAFTest/STAX/Parent}"',
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Query the testcase just added and verify its information including its testcase stack
        [ 'STD:STAX', STAXService, 'QUERY JOB %s TESTCASE "%s.test2"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], None,
          "STAFResult['testcaseName'] == '%s.test2' and " % (STAXCurrentTestcase) +
          "string.atoi(STAFResult['numPasses']) == 0 and " +
          "string.atoi(STAFResult['numFails']) == 0 and " +
          "STAFResult['startedTimestamp'] and " +
          "STAFResult['lastStatus'] == None and " +
          "STAFResult['lastStatusTimestamp'] == None and " +
          "STAFResult['information'] == '' and " +
          "STAFResult['elapsedTime'] and " +
          "string.atoi(STAFResult['numStarts']) == 1 and " +
          "len(STAFResult['testcaseStack']) == 3 and STAFResult['testcaseStack'][0] == 'TestSTAF' and STAFResult['testcaseStack'][1] == '%s' and STAFResult['testcaseStack'][2] == '%s.test2'" % (STAXCurrentTestcase, STAXCurrentTestcase)
        ],

        # Check that a start record for the testcase exists in the STAX Job Log
        # XXX: Comment out since "Log TC Starts/Stops may not be enabled"
        #[ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s LEVELMASK Start LAST 1 CONTAINS {STAFTest/STAX/TestName}' % (STAXMachineNickname, STAXJobID),
        #  [ STAFRC.Ok ], None,
        #  "len(STAFResult) == 1"
        #],

        # Start a testcase specifying a key
        [ 'STD:STAX', 'VAR',  'SET VAR STAFTest/STAX/Key=First',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'START JOB {STAFTest/STAX/JobID} TESTCASE "%s.test3"' % (STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'START JOB {STAFTest/STAX/JobID} TESTCASE "%s.test3" KEY {STAFTest/STAX/Key}' % (STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        # Check if existing testcase and key are specified, get AlreadyExists error
        [ 'STD:STAX', STAXService, 'START JOB {STAFTest/STAX/JobID} TESTCASE "%s.test3" KEY {STAFTest/STAX/Key}' % (STAXCurrentTestcase),
          [ STAFRC.AlreadyExists ], None
        ],

        # Start the same testcase but with a different key
        [ 'STD:STAX', STAXService, 'START JOB {STAFTest/STAX/JobID} TESTCASE "%s.test3" KEY Second' % (STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Record an info testcase message for the second instance of testcase test3
        [ 'STD:STAX', STAXService, 'UPDATE JOB {STAFTest/STAX/JobID} TESTCASE "%s.test3" STATUS "Info" MESSAGE "Info status message"' % (STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        # *** UPDATE TESTCASE Request Tests ***

        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.test2" STATUS pass' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Query the testcase just added and verify its information including its testcase stack
        [ 'STD:STAX', STAXService, 'QUERY JOB %s TESTCASE "%s.test2"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], None,
          "STAFResult['testcaseName'] == '%s.test2' and " % (STAXCurrentTestcase) +
          "string.atoi(STAFResult['numPasses']) == 1 and " +
          "string.atoi(STAFResult['numFails']) == 0 and " +
          "STAFResult['startedTimestamp'] and " +
          "STAFResult['lastStatus'] == 'pass' and " +
          "STAFResult['lastStatusTimestamp'] and " +
          "STAFResult['information'] == '' and " +
          "STAFResult['elapsedTime'] and " +
          "string.atoi(STAFResult['numStarts']) == 1 and " +
          "len(STAFResult['testcaseStack']) == 3 and STAFResult['testcaseStack'][0] == 'TestSTAF' and STAFResult['testcaseStack'][1] == '%s' and STAFResult['testcaseStack'][2] == '%s.test2'" % (STAXCurrentTestcase, STAXCurrentTestcase)
        ],

        # Check that a status record for the testcase is NOT the last record in the STAX Job Log since no message was specifed
        #[ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s LEVELMASK Pass LAST 1 CONTAINS %s.test2' % (STAXMachineNickname, STAXJobID, STAXCurrentTestcase),
        #  [ STAFRC.Ok ], None,
        #  "len(STAFResult) == 1"
        #],

        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.test1" STATUS pass MESSAGE "It passed!"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        # Check that a start record for the testcase exists in the STAX Job Log
        [ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s LEVELMASK Pass LAST 1 CONTAINS {STAFTest/STAX/TestName}.test1 CONTAINS "It passed!"' % (STAXMachineNickname, STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1"
        ],

        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.test1" STATUS pass MESSAGE "It passed again!"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        # Check that a start record for the testcase exists in the STAX Job Log
        [ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s LEVELMASK Pass LAST 1 CONTAINS {STAFTest/STAX/TestName}.test1 CONTAINS "It passed again!"' % (STAXMachineNickname, STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1"
        ],

        # Check if non-existing Job ID is specified, get DoesNotExist error
        [ 'STD:STAX', STAXService, 'UPDATE JOB 9999999 TESTCASE newTestname STATUS pass',
          [ STAFRC.DoesNotExist ], None
        ],

        # Check if non-integer Job ID is specified, get InvalidValue error
        [ 'STD:STAX', STAXService, 'UPDATE JOB 99999999999999999 TESTCASE newTestname STATUS pass',
          [ STAFRC.InvalidValue ], None
        ],

        # Check if non-existing testcase name is specified, get DoesNotExist error
        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.DoesNotExistTestname" STATUS pass' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.DoesNotExist ], None
        ],
        
        # Check if non-existing testcase name is specified with FORCE option and an invalid parent, that it fails
        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.A.B.C" STATUS pass FORCE PARENT "XXX"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.InvalidValue ], None
        ],
        
        # Check if non-existing testcase name is specified with FORCE option and an invalid parent, that it fails
        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.A.B.C" STATUS pass FORCE PARENT "%s.mach1.company.com"' % (STAXJobID, STAXCurrentTestcase, STAXCurrentTestcase),
          [ STAFRC.InvalidValue ], None
        ],

        # Check if a non-existing testcase name is specified with FORCE option and a valid PARENT option, that it works
        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.A.B.C" STATUS pass FORCE PARENT "%s"' % (STAXJobID, STAXCurrentTestcase, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        # Query the testcase just added and verify its information including its testcase stack

        [ 'STD:STAX', STAXService, 'QUERY JOB %s TESTCASE "%s.A.B.C"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], None,
          "STAFResult['testcaseName'] == '%s.A.B.C' and " % (STAXCurrentTestcase) +
          "string.atoi(STAFResult['numPasses']) == 1 and " +
          "string.atoi(STAFResult['numFails']) == 0 and " +
          "STAFResult['startedTimestamp'] and " +
          "STAFResult['lastStatus'] == 'pass' and " +
          "STAFResult['lastStatusTimestamp'] and " +
          "STAFResult['information'] == '' and " +
          "STAFResult['elapsedTime'] and " +
          "string.atoi(STAFResult['numStarts']) == 1 and " +
          "len(STAFResult['testcaseStack']) == 3 and STAFResult['testcaseStack'][1] == '%s' and STAFResult['testcaseStack'][2] == '%s.A.B.C'" % (STAXCurrentTestcase, STAXCurrentTestcase)
        ],

        # Check if existing testcase name is specified with FORCE option, that it works
        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.test1" STATUS pass FORCE' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Check if the PARENT option is specified without the FORCE option, that get InvalidRequest error
        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.test1" STATUS pass PARENT "%s"' % (STAXJobID, STAXCurrentTestcase, STAXCurrentTestcase),
          [ STAFRC.InvalidRequestString], None
        ],

        # Check if invalid status is specified, get InvalidValue error
        [ 'STD:STAX', STAXService, 'UPDATE JOB %s TESTCASE "%s.test1" STATUS InvalidStatus' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.InvalidValue ], None
        ],

        # Make sure that the UPDATE request is resolving JOB, TESTCASE, STATUS, MESSAGE, and PARENT values
        [ 'STD:STAX', 'VAR',  'SET VAR STAFTest/STAX/Status=pass VAR "STAFTest/STAX/Message=It really passed"',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'UPDATE JOB {STAFTest/STAX/JobID} TESTCASE "{STAFTest/STAX/TestName}" STATUS {STAFTest/STAX/Status} MESSAGE {STAFTest/STAX/Message} FORCE PARENT "{STAFTest/STAX/Parent}"',
          [ STAFRC.Ok ], r'^$'
        ],

        # Check that a start record for the testcase exists in the STAX Job Log
        [ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s LEVELMASK Pass LAST 1 CONTAINS {STAFTest/STAX/TestName}' % (STAXMachineNickname, STAXJobID),
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1"
        ],

        # *** STOP PROCESS Request Tests ***

        [ 'STD:STAX', STAXService, 'STOP JOB %s PROCESS "local:999999999"' % (STAXJobID),
          [ STAFRC.DoesNotExist ], None
        ],

        [ 'STD:STAX', STAXService, 'STOP JOB %s UNSUPPORTEDOPTION xxx' % (STAXJobID),
          [ STAFRC.InvalidRequestString ], None
        ],

        # *** STOP TESTCASE Request Tests ***

        [ 'STD:STAX', STAXService, 'STOP JOB %s TESTCASE "%s.test1"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Query the testcase that was just stopped and verify its information including its testcase stack
        [ 'STD:STAX', STAXService, 'QUERY JOB %s TESTCASE "%s.test1"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.Ok ], None,
          "STAFResult['testcaseName'] == '%s.test1' and " % (STAXCurrentTestcase) +
          "string.atoi(STAFResult['numPasses']) == 3 and " +
          "string.atoi(STAFResult['numFails']) == 0 and " +
          "STAFResult['startedTimestamp'] and " +
          "STAFResult['lastStatus'] == 'pass' and " +
          "STAFResult['lastStatusTimestamp'] and " +
          "STAFResult['information'] == 'It passed again!' and " +
          "STAFResult['elapsedTime'] != '&lt;Pending>' and " +
          "string.atoi(STAFResult['numStarts']) == 1 and " +
          "len(STAFResult['testcaseStack']) >= 4 and STAFResult['testcaseStack'][0] == 'TestSTAF' and STAFResult['testcaseStack'][len(STAFResult['testcaseStack']) - 1] == '%s.test1'" % (STAXCurrentTestcase)
        ],

        # Check that a stop record for the testcase exists in the STAX Job Log
        # XXX: Comment out since "Log TC Starts/Stops my not be enabled"
        #[ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s LEVELMASK Stop LAST 1 CONTAINS %s.test1' % (STAXMachineNickname, STAXJobID, STAXCurrentTestcase),
        #  [ STAFRC.Ok ], None,
        #  "len(STAFResult) == 1"
        #],

        # Check that get a DoesNotExist error if try a stop an existing test that is not active
        [ 'STD:STAX', STAXService, 'STOP JOB %s TESTCASE "%s.test1"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.DoesNotExist ], None
        ],

        # Check if non-existing Job ID is specified, get DoesNotExist error
        [ 'STD:STAX', STAXService, 'STOP JOB 9999999 TESTCASE "%s.test1"' % (STAXCurrentTestcase),
          [ STAFRC.DoesNotExist ], None
        ],

        # Check if non-integer Job ID is specified, get InvalidValue error
        [ 'STD:STAX', STAXService, 'STOP JOB 99999999999999999 TESTCASE "%s.test1"' % (STAXCurrentTestcase),
          [ STAFRC.InvalidValue ], None
        ],

        # Check if non-existing testcase name is specified, get DoesNotExist error
        [ 'STD:STAX', STAXService, 'STOP JOB %s TESTCASE "%s.DoesNotExistTestname"' % (STAXJobID, STAXCurrentTestcase),
          [ STAFRC.DoesNotExist ], None
        ],

        # Make sure that the STOP request is resolving JOB, TESTCASE, and KEY values
        [ 'STD:STAX', STAXService, 'STOP JOB {STAFTest/STAX/JobID} TESTCASE "{STAFTest/STAX/TestName}"',
          [ STAFRC.Ok ], r'^$'
        ],

        # Check that a start record for the testcase exists in the STAX Job Log
        # XXX: Comment out since "Log TC Starts/Stops my not be enabled"
        #[ 'STD:STAX', LogService,  'QUERY MACHINE %s LOGNAME STAX_Job_%s LEVELMASK Stop LAST 1 CONTAINS {STAFTest/STAX/TestName}' % (STAXMachineNickname, STAXJobID),
        #  [ STAFRC.Ok ], None,
        #  "len(STAFResult) == 1"
        #],

        # Check that stopping a testcase specifying a key works
        [ 'STD:STAX', STAXService, 'STOP JOB {STAFTest/STAX/JobID} TESTCASE "%s.test3" KEY {STAFTest/STAX/Key}' % (STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        # Check if specify an existing testcase and key that has already been stopped, get a DoesNotExist error
        [ 'STD:STAX', STAXService, 'STOP JOB {STAFTest/STAX/JobID} TESTCASE "%s.test3" KEY {STAFTest/STAX/Key}' % (STAXCurrentTestcase),
          [ STAFRC.DoesNotExist ], None
        ],

        # Stop the same testcase but with a different key
        [ 'STD:STAX', STAXService, 'STOP JOB {STAFTest/STAX/JobID} TESTCASE "%s.test3" KEY Second' % (STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', STAXService, 'STOP JOB {STAFTest/STAX/JobID} TESTCASE "%s.test3"' % (STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],
        
        [ 'STD:STAX', STAXService, 'STOP JOB {STAFTest/STAX/JobID} TESTCASE "%s.A.B.C"' % (STAXCurrentTestcase),
          [ STAFRC.Ok ], r'^$'
        ],

        # Check that purging the file cache works and that it clears the file cache summary information
        [ 'STD:STAX', STAXService, 'PURGE FILECACHE CONFIRM',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['numPurged']) > 0 and " +
          "string.atoi(STAFResult['numRemaining']) == 0"
        ], 
        [ 'STD:STAX', STAXService, 'LIST FILECACHE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ], 
        [ 'STD:STAX', STAXService, 'LIST FILECACHE SUMMARY',
          [ STAFRC.Ok ], None,
          "STAFResult['hitRatio'] == '0%' and " +
          "string.atoi(STAFResult['hitCount']) == 0 and " +
          "string.atoi(STAFResult['missCount']) == 0 and " +
          "string.atoi(STAFResult['requestCount']) == 0 and " +
          "STAFResult['lastPurgeDate']"
        ],
        
        # Check that purging the machine cache works
        [ 'STD:STAX', STAXService, 'PURGE MACHINECACHE CONFIRM',
          [ STAFRC.Ok ], None,
          "string.atoi(STAFResult['numPurged']) >= 0 and " +
          "string.atoi(STAFResult['numRemaining']) == 0"
        ],
        
        [ 'STD:STAX', STAXService, 'LIST MACHINECACHE',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 0"
        ],

        # Remove any variables created for STAX tests
        [ 'STD:STAX', 'VAR',  'DELETE VAR STAFTest/STAX/JobID VAR STAFTest/STAX/TestName VAR STAFTest/STAX/Key VAR STAFTest/STAX/Parent',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:STAX', 'SEM', 'RELEASE MUTEX STAFTest/STAX',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>
      </if>

      <return>STAXTests</return>

    </sequence>
  </function>


  <!-- ========================================================================== -->
  <!-- InitEVENTTests - This function initializes all the EVENT test information    -->
  <!-- ========================================================================== -->

  <function name="InitEVENTTests" scope="local">
    <sequence>

       <script>
           EVENTTests = []
       </script>

      <!--  These Event tests can only be run on the local machine -->
      <if expr="testMachineIsLocal">
      <script>

      EVENTTests = [

        #
        # EVENT tests
        #

        [ 'STD:EVENT', 'SEM',  'REQUEST MUTEX STAFTest/EVENT',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', 'VAR',  'SET VAR STAFTest/EVENT/Type=myType VAR STAFTest/EVENT/Subtype=mySubType1',
          [ STAFRC.Ok ], r'^.*'
        ],

        [ 'STD:EVENT', 'VAR',  'SET VAR STAFTest/EVENT/MaxAttempts=3 VAR STAFTest/EVENT/Timeout=30000',
          [ STAFRC.Ok ], r'^.*'
        ],

        [ 'STD:EVENT', 'VAR',  'SET VAR STAFTest/EVENT/Priority=4 VAR STAFTest/EVENT/PriorityDelta=2',
          [ STAFRC.Ok ], r'^.*'
        ],

        # *** HELP/VERSION Request Tests ***

        [ 'STD:EVENT', EventService, 'VERSION',
          [ STAFRC.Ok ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'HELP',
          [ STAFRC.Ok ], r'^.*'
        ],
        
        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:EVENT', EventService, 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.*'
        ],

        # *** REGISTER Request Tests ***

        [ 'STD:EVENT', EventService, 'REGISTER TYPE {STAFTest/EVENT/Type}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', EventService, 'REGISTER TYPE myType SUBTYPE {STAFTest/EVENT/Subtype} BYNAME',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', EventService, 'REGISTER TYPE myType SUBTYPE mySubType2 BYHANDLE MAXATTEMPTS {STAFTest/EVENT/MaxAttempts} ACKNOWLEDGETIMEOUT {STAFTest/EVENT/Timeout} PRIORITY {STAFTest/EVENT/Priority} PRIORITYDELTA {STAFTest/EVENT/PriorityDelta}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', EventService, 'LIST REGISTRATIONS TYPE NoExist',
          [ 4003 ], r'^.*'
        ],

        # *** LIST Request Tests ***

        [ 'STD:EVENT', EventService, 'LIST REGISTRATIONS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and "
          "STAFResult[0]['type'] and " +
          "(STAFResult[0]['subtype'] == None or STAFResult[0]['subtype']) and " +
          "STAFResult[0]['machine'] and " +
          "(STAFResult[0]['notifyBy'] in ['Name', 'Handle']) and " +
          "STAFResult[0]['notifiee']"
        ],

        [ 'STD:EVENT', EventService, 'LIST REGISTRATIONS LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and "
          "STAFResult[0]['type'] and " +
          "(STAFResult[0]['subtype'] == None or STAFResult[0]['subtype']) and " +
          "STAFResult[0]['machine'] and " +
          "(STAFResult[0]['notifyBy'] in ['Name', 'Handle']) and " +
          "STAFResult[0]['notifiee'] and " +
          "int(STAFResult[0]['attempts']) >= 1 and " +
          "int(STAFResult[0]['timeout']) > 0 and " +
          "int(STAFResult[0]['priority']) > 0 and " +
          "int(STAFResult[0]['priorityDelta']) > 0"
        ],

        [ 'STD:EVENT', EventService, 'LIST REGISTRATIONS TYPE {STAFTest/EVENT/Type}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and " +
          "STAFResult[0]['type'] == 'myType' and " +
          "STAFResult[0]['subtype'] == None and " +
          "STAFResult[0]['machine'] and " +
          "STAFResult[0]['notifyBy'] == 'Name' and " +
          "STAFResult[0]['notifiee'] == 'STAX/Job/%s' and " % (STAXJobID) +
          "STAFResult[1]['type'] == 'myType' and " +
          "STAFResult[1]['subtype'] == 'mysubtype2' and " +
          "STAFResult[1]['machine'] and " +
          "STAFResult[1]['notifyBy'] == 'Handle' and " +
          "int(STAFResult[1]['notifiee']) > 1 and " +
          "STAFResult[2]['type'] == 'myType' and " +
          "STAFResult[2]['subtype'] == 'mysubtype1' and " +
          "STAFResult[2]['machine'] and " +
          "STAFResult[2]['notifyBy'] == 'Name' and " +
          "STAFResult[2]['notifiee'] == 'STAX/Job/%s'" % (STAXJobID)
        ],

        [ 'STD:EVENT', EventService, 'LIST REGISTRATIONS TYPE MYType LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 3 and "
          "STAFResult[0]['type'] == 'MYType' and " +
          "STAFResult[0]['subtype'] == None and " +
          "STAFResult[0]['machine'] and " +
          "STAFResult[0]['notifyBy'] == 'Name' and " +
          "STAFResult[0]['notifiee'] == 'STAX/Job/%s' and " % (STAXJobID) +
          "int(STAFResult[0]['attempts']) == 1 and " +
          "int(STAFResult[0]['timeout']) == 60000 and " +
          "int(STAFResult[0]['priority']) == 5 and " +
          "int(STAFResult[0]['priorityDelta']) == 1 and " +
          "STAFResult[1]['type'] == 'MYType' and " +
          "STAFResult[1]['subtype'] == 'mysubtype2' and " +
          "STAFResult[1]['machine'] and " +
          "STAFResult[1]['notifyBy'] == 'Handle' and " +
          "int(STAFResult[1]['notifiee']) > 1 and " +
          "int(STAFResult[1]['attempts']) == 3 and " +
          "int(STAFResult[1]['timeout']) == 30000 and " +
          "int(STAFResult[1]['priority']) == 4 and " +
          "int(STAFResult[1]['priorityDelta']) == 2 and " +
          "STAFResult[2]['type'] == 'MYType' and " +
          "STAFResult[2]['subtype'] == 'mysubtype1' and " +
          "STAFResult[2]['machine'] and " +
          "STAFResult[2]['notifyBy'] == 'Name' and " +
          "STAFResult[2]['notifiee'] == 'STAX/Job/%s' and " % (STAXJobID) +
          "int(STAFResult[2]['attempts']) == 1 and " +
          "int(STAFResult[2]['timeout']) == 60000 and " +
          "int(STAFResult[2]['priority']) == 5 and " +
          "int(STAFResult[2]['priorityDelta']) == 1"
        ],

        [ 'STD:EVENT', EventService, 'LIST REGISTRATIONS TYPE myType SUBTYPE {STAFTest/EVENT/Subtype}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and " +
          "STAFResult[0]['machine'] and " +
          "STAFResult[0]['notifyBy'] == 'Name' and " +
          "STAFResult[0]['notifiee'] == 'STAX/Job/%s'" % (STAXJobID)
        ],

        [ 'STD:EVENT', EventService, 'LIST REGISTRATIONS LONG TYPE myType SUBTYPE mySubType1',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 1 and "
          "STAFResult[0]['type'] == 'myType' and " +
          "STAFResult[0]['subtype'] == 'mySubType1' and " +
          "STAFResult[0]['machine'] and " +
          "STAFResult[0]['notifyBy'] == 'Name' and " +
          "STAFResult[0]['notifiee'].find('STAX/Job/') == 0 and " +
          "int(STAFResult[0]['attempts']) == 1 and " +
          "int(STAFResult[0]['timeout']) == 60000 and " +
          "int(STAFResult[0]['priority']) == 5 and " +
          "int(STAFResult[0]['priorityDelta']) == 1"
        ],

        # *** LIST TYPES/SUBTYPES Request Tests ***

        [ 'STD:EVENT', EventService, 'LIST TYPES',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0"
        ],

        [ 'STD:EVENT', EventService, 'LIST TYPES LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and " +
          "STAFResult[0]['type'] and " +
          "len(STAFResult[0]['subtypeList']) >= 0"
        ],

        [ 'STD:EVENT', EventService, 'LIST SUBTYPES TYPE {STAFTest/EVENT/Type}',
          [ STAFRC.Ok ], None,
          "len(STAFResult) == 2 and " +
          "STAFResult[0] == 'mysubtype2' and " +
          "STAFResult[1] == 'mysubtype1'"
        ],

        [ 'STD:EVENT', EventService, 'LIST SUBTYPES TYPE DoesNotExist',
          [ 4003 ], r'.*',
        ],

        # *** QUERY EVENTID Request Tests ***

        [ 'STD:EVENT', 'VAR',   'SET VAR STAFTest/EVENT/EventID=XYZ',
          [ STAFRC.Ok ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'QUERY EVENTID {STAFTest/EVENT/EventID}',
          [ STAFRC.InvalidValue ], r'^\d*'
        ],

        # XXX: Can't query an event ID because don't have a way to get the number of an event id.
        #[ 'STD:EVENT', EventService, 'QUERY EVENTID {STAFTest/EVENT/EventID} LONG',
        #  "len(STAFResult) == 3 and "
        #  "STAFResult[0].eventID and " +
        #  "STAFResult[0].type == 'mytype' and " +
        #  "STAFResult[0].subtype == '' and " +
        #  "len(STAFResult[0].properties) == 0 and " +
        #  "STAFResult[0].generatedBy.machine and " +
        #  "STAFResult[0].generatedBy.handleName and " +
        #  "int(STAFResult[0].generatedBy.handle) > 0 and " +
        #  "len(STAFResult[0].notificationList) > 0 and " +
        #  "STAFResult[0].notificationList[0].machine and " +
        #  "STAFResult[0].notificationList[0].notifyBy and " +
        #  "int(STAFResult[0].notificationList[0].attempts) >=01 and " +
        #  "int(STAFResult[0].notificationList[0].timeout) > 0 and " +
        #  "int(STAFResult[0].notificationList[0].priority) > 0 and " +
        #  "int(STAFResult[0].notificaitonList[0].priorityDelta) >= 0"

        [ 'STD:EVENT', EventService, 'QUERY LONG EVENTID 909090',
          [ 4005 ], r'^\d*'
        ],

        [ 'STD:EVENT', EventService, 'QUERY EVENTID {STAFTest/EVENT/EventID}',
          [ STAFRC.InvalidValue ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'QUERY EVENTID 909090',
          [ 4005 ], r'^.*'
        ],

        # *** GENERATE/ACKNOWLEDGE Request Tests ***

        [ 'STD:EVENT', EventService, 'GENERATE TYPE {STAFTest/EVENT/Type} SUBTYPE {STAFTest/EVENT/Subtype}',
          [ STAFRC.Ok ], r'^\d*'
        ],

        [ 'STD:EVENT', EventService, 'ACKNOWLEDGE EVENTID {STAFTest/EVENT/EventID}',
          [ STAFRC.InvalidValue ], r'^\d*'
        ],

        [ 'STD:EVENT', 'VAR',   'SET VAR STAFTest/EVENT/EventID=909090 % (EventServiceEndpoint)',
          [ STAFRC.Ok ], r'^.*'
        ],

        [ 'STD:EVENT', 'VAR',   'SET VAR STAFTest/EVENT/Handle=1 VAR STAFTest/EVENT/Name=MyName',
          [ STAFRC.Ok ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'ACKNOWLEDGE EVENTID {STAFTest/EVENT/EventID} MACHINE local',
          [ STAFRC.InvalidRequestString ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'ACKNOWLEDGE EVENTID 909090 FORCE MACHINE local',
          [ 4002 ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'ACKNOWLEDGE EVENTID 909090 FORCE MACHINE local HANDLE {STAFTest/EVENT/Handle}',
          [ 4002 ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'ACKNOWLEDGE EVENTID 909090 FORCE MACHINE local NAME {STAFTest/EVENT/Name}',
          [ 4002 ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'ACKNOWLEDGE EVENTID 909090',
          [ 4002 ], r'^\d*'
        ],

        [ 'STD:EVENT', 'VAR',   'SET VAR STAFTest/EVENT/Property=2.1.0',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', EventService, 'GENERATE TYPE myType SUBTYPE mySubType2 PROPERTY Version={STAFTest/EVENT/Property} PROPERTY "Status=Passed BVT"',
          [ STAFRC.Ok ], r'^\d*'
        ],

        [ 'STD:EVENT', EventService, 'LIST EVENTIDS',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and "
          "int(STAFResult[0]['eventID']) > 0 and " +
          "STAFResult[0]['type'] and " +
          "STAFResult[0]['subtype'] and " +
          "int(STAFResult[0]['numNotifiees']) > 0"
        ],

        [ 'STD:EVENT', EventService, 'LIST EVENTIDS LONG',
          [ STAFRC.Ok ], None,
          "len(STAFResult) > 0 and "
          "int(STAFResult[0]['eventID']) > 0 and " +
          "STAFResult[0]['type'] and " +
          "STAFResult[0]['subtype'] and " +
          "len(STAFResult[0]['propertyMap']) >= 0 and " +
          "STAFResult[0]['generatedBy']['machine'] and " +
          "STAFResult[0]['generatedBy']['handleName'] and " +
          "int(STAFResult[0]['generatedBy']['handle']) > 0 and " +
          "len(STAFResult[0]['notificationList']) > 0 and " +
          "STAFResult[0]['notificationList'][0]['machine'] and " +
          "(STAFResult[0]['notificationList'][0]['notifyBy'] in ['Name', 'Handle']) and " +
          "STAFResult[0]['notificationList'][0]['notifiee'] and " +
          "int(STAFResult[0]['notificationList'][0]['attempts']) >= 0 and " +
          "int(STAFResult[0]['notificationList'][0]['timeout']) >= 0 and " +
          "int(STAFResult[0]['notificationList'][0]['priority']) >= 0 and " +
          "int(STAFResult[0]['notificationList'][0]['priorityDelta']) >= 0"
        ],

        # *** UNREGISTER Request Tests ***

        [ 'STD:EVENT', EventService, 'UNREGISTER TYPE NoExist',
          [ 4003 ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'UNREGISTER TYPE myType SUBTYPE NoExist',
          [ 4004 ], r'^.*'
        ],

        [ 'STD:EVENT', EventService, 'UNREGISTER TYPE myType SUBTYPE {STAFTest/EVENT/Subtype} FORCE NAME STAX/Job/%s' % (STAXJobID),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', EventService, 'UNREGISTER TYPE myTYPE SUBTYPE mysubTYPE2 FORCE HANDLE %s' % (JobHandle),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', 'VAR',   'SET VAR STAFTest/EVENT/Name=STAX/Job/%s' % (STAXJobID),
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', EventService, 'UNREGISTER TYPE {STAFTest/EVENT/Type} FORCE NAME {STAFTest/EVENT/Name}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', EventService, 'LIST SUBTYPES TYPE MyType',
          [ 4003 ], r'.*'
        ],

        # Remove any variables created for EVENT tests
        [ 'STD:EVENT', 'VAR',  'DELETE VAR STAFTest/EVENT/Type        VAR STAFTest/EVENT/Subtype',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', 'VAR',  'DELETE VAR STAFTest/EVENT/MaxAttempts VAR STAFTest/EVENT/Timeout',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', 'VAR',  'DELETE VAR STAFTest/EVENT/Priority    VAR STAFTest/EVENT/PriorityDelta',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', 'VAR',  'DELETE VAR STAFTest/EVENT/EventID     VAR STAFTest/EVENT/Name',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', 'VAR',  'DELETE VAR STAFTest/EVENT/Handle',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', 'VAR',  'DELETE VAR STAFTest/EVENT/Property',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:EVENT', 'SEM', 'RELEASE MUTEX STAFTest/EVENT',
          [ STAFRC.Ok ], r'^$'
        ]

      ]

      </script>
      </if>

      <return>EVENTTests</return>

    </sequence>
  </function>

  <!-- ========================================================================== -->
  <!-- InitFTPTests - This function initializes all the FTP test information    -->
  <!-- ========================================================================== -->

  <function name="InitFTPTests" scope="local">
    <sequence>

      <script>
        FTPTests = []
      </script>

      <if expr="not TestMachJavaSupport">
        <sequence>
          <log message="1">
            'FTP Test: Cannot run FTP tests on machine %s because STAF Java support is not provided for %s %s' % \
            (TestMach, TestMachOSType, TestMachOSMajorVersion)
          </log>
          <return>FTPTests</return>
        </sequence>
        <elseif expr="TestMachOSType.find('OS/390') == 0">
          <sequence>
            <log message="1">
              'FTP Test: Cannot run FTP tests on machine %s because ZIP service has a bug on  %s' % \
              (TestMach, TestMachOSType)
            </log>
            <return>FTPTests</return>
          </sequence>
        </elseif>
      </if>

      <script>
        FtpService = 'FTP'
        unregisterFtpService = 0
      </script>

      <testcase name="'FTP'">
        <sequence>

          <!-- Check if the FTP service is already registered on the test machine.
                If not, copy the FTP service jar file from the ftp machine and register it
                on the test machine. -->
           
          <stafcmd>
            <location>TestMach</location>
            <service>'SERVICE'</service>
            <request>'QUERY SERVICE %s' % (FtpService)</request>
          </stafcmd>

          <if expr="RC != 0">
            <sequence>

              <script>
                FtpZipFile = '%s/ftp/FTPV%s.zip' % (FtpBuildDir, FtpServiceVersion)
                TestMachineServicesDir = '{STAF/Config/STAFRoot}/services'
                request = 'CREATE DIRECTORY %s' % (TestMachineServicesDir)
              </script>

              <stafcmd>
                <location>TestMach</location>
                <service>'FS'</service>
                <request>request</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == 0,
                  'failMsg': 'Error creating STAF services directory on testmachine: STAF %s FS %s.  RC=%s Result=%s' % \
                         (TestMach, request, RC, STAFResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

              <script>
                TestMachFtpZipFile = '%s/FTPV%s.zip' % (TestMachineServicesDir, FtpServiceVersion)
                if testMachineIsLocal:
                  request = 'COPY FILE %s TOFILE %s' % (FtpZipFile, TestMachFtpZipFile)
                else:
                  request = 'COPY FILE %s TOFILE %s TOMACHINE %s' % (FtpZipFile, TestMachFtpZipFile, TestMach)
              </script>

              <stafcmd>
                <location>FtpMachine</location>
                <service>'FS'</service>
                <request>request</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == 0,
                  'failMsg': 'Error copying STAF Service zip file to testmachine: STAF %s FS %s.  RC=%s Result=%s' % \
                         (FtpMachine, request, RC, STAFResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

              <script>
                request = 'UNZIP ZIPFILE %s TODIRECTORY %s REPLACE' % (TestMachFtpZipFile, TestMachineServicesDir)
              </script>

              <stafcmd>
                <location>TestMach</location>
                <service>'ZIP'</service>
                <request>request</request>
              </stafcmd>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == 0,
                  'failMsg': 'Error unzipping FTP Service zip file on testmachine: STAF %s ZIP %s.  RC=%s Result=%s' % \
                         (TestMach, request, RC, STAFResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

              <script>
                TestMachFTPJarFile = '{STAF/Config/STAFRoot}/services/ftp/STAFFTP.jar'
                request = 'ADD SERVICE %s LIBRARY JSTAF EXECUTE %s OPTION JVMName=%s %s' % (FtpService, TestMachFTPJarFile, FtpService, RequiredJVMOptions)
              </script>

              <log message="1">'Registering the FTP service: STAF %s SERVICE %s' % (TestMach, request)</log>

              <stafcmd>
                <location>TestMach</location>
                <service>'SERVICE'</service>
                <request>request</request>
              </stafcmd>
             
              <script>
                registerRC = RC
                if RC == 0:
                  unregisterFtpService = 1
              </script>

              <call function="'STAXUtilCheckSuccess'">
                { 'result': RC == 0,
                  'failMsg': 'Error registering FTP service on test machine: STAF %s SERVICE %s.  RC=%s Result=%s' % \
                         (TestMach, request, RC, STAFResult),
                  'sendToMonitor': 1,
                  'recordStatus': 1 }
              </call>

              <if expr="registerRC != 0">
                <return>FTPTests</return>
              </if>

            </sequence>
          </if>

        </sequence>
      </testcase>

      <script>
      ftpHost = '9.3.211.204'    # 'staf1e.austin.ibm.com'
      ftpPort = 21
      ftpUser = 'test'
      ftpPassword = '!!@test111pwd@!!'  # Must update every 90 days - Last changed 09/25/13
      ftpUrlPath = './ftpTest'

      FTPTests = [

        #
        # FTP tests
        #

        [ 'STD:FTP', 'SEM',  'REQUEST MUTEX STAFTest/FTP',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FTP', 'VAR',  'SET VAR STAFTest/FTP/Host=%s VAR STAFTest/FTP/Port=%s VAR STAFTest/FTP/UrlPath=%s VAR STAFTest/FTP/User=%s VAR STAFTest/FTP/Password=%s' % (ftpHost, ftpPort, ftpUrlPath, ftpUser, ftpPassword),
          [ STAFRC.Ok ], r'^.*'
        ],

        # *** HELP/VERSION Request Tests ***

        [ 'STD:FTP', FtpService, 'VERSION',
          [ STAFRC.Ok ], '1.0.3'
        ],

        [ 'STD:FTP', FtpService, 'HELP',
          [ STAFRC.Ok ], r'^.*'
        ],
        
        # Verify that get RC 7 and an error message if specify an invalid request command
        [ 'STD:FTP', FtpService, 'HELPIT',
          [ STAFRC.InvalidRequestString ], r'^.'
        ],

        # *** PUT Request Tests ***

        # Verify get appropriate error when an unknown host is specified
        [ 'STD:FTP', FtpService, 'PUT HOST XXXUnknownHost URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE {STAF/Config/ConfigFile} USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ 4001 ], r'.*',
        ],
        
        # Verify get appropriate error when an invalid user is specified
        [ 'STD:FTP', FtpService, 'PUT HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE {STAF/Config/ConfigFile} USER InvalidUser PASSWORD STAFTest/FTP/Password}',
          [ 4001 ], r'.*',
        ],
        
        # Verify get appropriate error when an invalid password is specified
        [ 'STD:FTP', FtpService, 'PUT HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE {STAF/Config/ConfigFile} USER {STAFTest/FTP/User} PASSWORD !!@badPassword@!!',
          [ 4001 ], r'.*',
        ],
        
        # Verify get appropriate error when an invalid url path is specified
        [ 'STD:FTP', FtpService, 'PUT HOST {STAFTest/FTP/Host} URLPATH ./DoesNotExist/test.txt FILE {STAF/Config/ConfigFile} USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.FileWriteError ], r'.*',
        ],

        # Verify get appropriate error when an invalid FILE option is specified
        [ 'STD:FTP', FtpService, 'PUT HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE /DoesNotExist/badfile.txt USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.FileReadError ], r'.*',
        ],

        [ 'STD:FTP', FtpService, 'PUT HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE {STAF/Config/ConfigFile} USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.Ok ], r'^$'
        ],

        # Verify replacing an existing file on the FTP server works
        [ 'STD:FTP', FtpService, 'PUT HOST {STAFTest/FTP/Host} PORT {STAFTest/FTP/Port} URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE {STAF/Config/ConfigFile} USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.Ok ], r'^$'
        ],

        # *** DIR Request Tests ***

        # Verify get appropriate error when an unknown host is specified
        [ 'STD:FTP', FtpService, 'DIR HOST XXXUnknownHost URLPATH {STAFTest/FTP/UrlPath} USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ 4001 ], r'.*',
        ],

        # Verify get appropriate error when an invalid user is specified
        [ 'STD:FTP', FtpService, 'DIR HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath} USER InvalidUser PASSWORD {STAFTest/FTP/Password}',
          [ 4001 ], r'.*',
        ],
        
        # Verify get appropriate error when an invalid url path is specified
        [ 'STD:FTP', FtpService, 'DIR HOST {STAFTest/FTP/Host} URLPATH ./DoesNotExist USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.FileOpenError ], r'.*',
        ],

        [ 'STD:FTP', FtpService, 'DIR HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath} USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.Ok ], r'.*'
        ],

        # Verify specifying the port to use to connect to the ftp host works
        [ 'STD:FTP', FtpService, 'DIR HOST {STAFTest/FTP/Host} PORT {STAFTest/FTP/Port} URLPATH {STAFTest/FTP/UrlPath} USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.Ok ], r'.*'
        ],
        
        # Verify doing a DIR on a subdirectory on the ftp host works
        [ 'STD:FTP', FtpService, 'DIR HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath}/test/ USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.Ok ], r'.*'
        ],

        # *** GET Request Tests ***

        # Verify get appropriate error when an unknown host is specified
        [ 'STD:FTP', FtpService, 'GET HOST XXXUnknownHost URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE {STAF/DataDir}/tmp/ftpTest.txt USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ 4001 ], r'.*',
        ],
        
        # Verify get appropriate error when an invalid user is specified
        [ 'STD:FTP', FtpService, 'GET HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE {STAF/DataDir}/tmp/ftpTest.txt USER InvalidUser PASSWORD {STAFTest/FTP/Password}',
          [ 4001 ], r'.*',
        ],
        
        # Verify get appropriate error when an invalid url path is specified
        [ 'STD:FTP', FtpService, 'GET HOST {STAFTest/FTP/Host} URLPATH ./DoesNotExist/test.txt FILE {STAF/DataDir}/tmp/ftpTest.txt USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.FileOpenError ], r'.*',
        ],
        
        # Verify get appropriate error when an invalid file on on the FTP service machine is specified
        [ 'STD:FTP', FtpService, 'GET HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE /DoesNotExist/ftpTest.txt USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.FileWriteError ], r'.*',
        ],

        [ 'STD:FTP', FtpService, 'GET HOST {STAFTest/FTP/Host} URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE {STAF/DataDir}/tmp/ftpTest.txt USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.Ok ], r'^$'
        ],
        
        # Verify replacing an existing file on the FTP service machine works
        [ 'STD:FTP', FtpService, 'GET HOST {STAFTest/FTP/Host} PORT {STAFTest/FTP/Port} URLPATH {STAFTest/FTP/UrlPath}/test.txt FILE {STAF/DataDir}/tmp/ftpTest.txt USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.Ok ], r'^$'
        ],

        [ 'STD:FTP', FtpService, 'GET HOST {STAFTest/FTP/Host} URLPATH ftpTest/test.txt FILE {STAF/DataDir}/tmp/ftpTest.txt USER {STAFTest/FTP/User} PASSWORD {STAFTest/FTP/Password}',
          [ STAFRC.Ok ], r'^$'
        ],

        # Delete any test files created for FTP tests
        [ 'STD:FTP', 'FS', 'DELETE ENTRY {STAF/DataDir}/tmp/ftpTest.txt CONFIRM',
          [ STAFRC.Ok ], None
        ],

        # Remove any variables created for FTP tests
        [ 'STD:FTP', 'VAR',  'DELETE VAR STAFTest/FTP/Host VAR STAFTest/FTP/Port VAR STAFTest/FTP/UrlPath VAR STAFTest/FTP/User VAR STAFTest/FTP/Password',
          [ STAFRC.Ok ], r'^$'
        ]
        
      ]
      </script>

      <if expr="unregisterFtpService">
        <script>
        FTPTests = FTPTests + [
          [ 'STD:SERVICE', 'SERVICE', 'REMOVE SERVICE %s' % (FtpService),
            [ STAFRC.Ok ], r'^$'
          ]
        ]
        </script>
      </if>

      <script>
        FTPTests = FTPTests + [
        [ 'STD:FTP', 'SEM', 'RELEASE MUTEX STAFTest/FTP',
          [ STAFRC.Ok ], r'^$'
        ]
      ]
      </script>

      <return>FTPTests</return>

    </sequence>
  </function>

  <!-- ================================================================= -->
  <!-- check-stafcmd - This function determines whether an arbitrary     -->
  <!--                 staf command worked.  If not, it generates some   -->
  <!--                 messages and log data, and then terminates the    -->
  <!--                 whole job.                                        -->
  <!-- ================================================================= -->

  <function name="check-stafcmd">
    <if expr="RC != STAFRC.Ok">
      <sequence>
        <message>
          'Failed (RC=%d): %s, Result: %s' % (RC, failMessage, STAFResult)
        </message>
        <log level="'error'">
          'Failed (RC=%d): %s, Result: %s' % (RC, failMessage, STAFResult)
        </log>
        <terminate/>
      </sequence>
    </if>
  </function>

  <!-- ================================================================= -->
  <!-- InitJob - This function performs tasks that need to be done once  -->
  <!--     at the beginning of the job.                                  -->
  <!-- ================================================================= -->

  <function name="InitJob" requires="PingTestMachines check-stafcmd">
    <sequence>

      <!-- Resolve the ImportDirectory -->

      <stafcmd>
        <location>'local'</location>
        <service>'VAR'</service>
        <request>'RESOLVE STRING %s' % ImportDirectory</request>
      </stafcmd>

      <script>failMessage = 'Resolving VAR %s' % ImportDirectory</script>
      <call function="'check-stafcmd'"/>

      <script>ImportDirectory = STAFResult</script>

      <message>'ImportMachine=%s' % ImportMachine</message>
      <message>'ImportDirectory=%s' % ImportDirectory</message>

      <import machine="ImportMachine" file="'%s/STAXUtil.xml' % ImportDirectory"/>
      
      <call function="'STAXUtilLogAndMsg'">
        'TestScopes = %s' % (TestScopes)
      </call>

      <call function="'STAXUtilLogAndMsg'">
        'TestMachines=%s' % TestMachines
      </call>

      <call function="'PingTestMachines'"/>

      <!-- Get the handle for this STAX Job -->

      <stafcmd>
        <location>'local'</location>
        <service>'HANDLE'</service>
        <request>'LIST HANDLES NAME STAX/Job/%s' % STAXJobID</request>
      </stafcmd>

      <script>failMessage = 'Finding handle name STAX/Job/%s' % STAXJobID</script>
      <call function="'check-stafcmd'"/>

      <script>
        JobHandle = STAFResult[0]['handle']
      </script>

      <call function="'STAXUtilLogAndMsg'">
        'JobHandle=%s' % JobHandle
      </call>

      <!-- Get the machine nickname for the STAX service machine -->

      <stafcmd>
        <location>'local'</location>
        <service>'VAR'</service>
        <request>'RESOLVE STRING {STAF/Config/MachineNickname}'</request>
      </stafcmd>

      <script>failMessage = 'Resolving {STAF/Config/MachineNickname}'</script>
      <call function="'check-stafcmd'"/>

      <script>STAXMachineNickname = STAFResult</script>

      <call function="'STAXUtilLogAndMsg'">
        'STAXMachineNickname=%s' % STAXMachineNickname
      </call>

      <!-- Get the machine name for the STAX service machine -->

      <stafcmd>
        <location>'local'</location>
        <service>'VAR'</service>
        <request>'RESOLVE STRING {STAF/Config/Machine}'</request>
      </stafcmd>

      <script>failMessage = 'Resolving {STAF/Config/Machine}'</script>
      <call function="'check-stafcmd'"/>

      <script>STAXMachine = STAFResult</script>

      <call function="'STAXUtilLogAndMsg'">
        'STAXMachine=%s' % STAXMachine
      </call>

      <!-- Get the STAF Root for the STAX service machine (used by FS GET FILE TEXT FORMAT) -->
      <stafcmd>
        <location>'local'</location>
        <service>'var'</service>
        <request>'resolve string {STAF/Config/STAFRoot}'</request>
      </stafcmd>

      <script>failMessage = 'Obtaining {STAF/Config/STAFRoot}'</script>
      <call function="'check-stafcmd'"/>

      <script>STAXMachSTAFRoot = STAFResult</script>

      <!-- Get the STAF DataDir for the STAX service machine (used by FS GET FILE TEXT FORMAT) -->
      <stafcmd>
        <location>'local'</location>
        <service>'var'</service>
        <request>'resolve string {STAF/DataDir}'</request>
      </stafcmd>

      <script>failMessage = 'Obtaining {STAF/DataDir}'</script>
      <call function="'check-stafcmd'"/>

      <script>STAXMachDataDir = STAFResult</script>

      <!-- Get the platform for the STAX service machine (used by FS GET FILE TEXT FORMAT) -->
      <stafcmd>
        <location>'local'</location>
        <service>'var'</service>
        <request>'resolve string {STAF/Config/OS/Name}'</request>
      </stafcmd>

      <script>failMessage = 'Obtaining {STAF/Config/OS/Name}'</script>
      <call function="'check-stafcmd'"/>

      <script>
        STAXMachOSType = STAFResult
      </script>

      <script>
        textLargeWinSize     = 45015
        textLargeUnixSize    = 45000
        textEOLWinSize       = 30000
        textEOLUnixSize      = 15000
        textSmallUnixSize    = 49
        textSmallWinSize     = 52
      </script>
     
      <!-- On a Windows STAX machine, determine the processor architecture -->

      <if expr="STAXMachOSType.find('Win') == 0">
        <sequence>

          <script>
            STAXMachProcessorArchitecture = 'i386'
            request = 'RESOLVE SYSTEM STRING {STAF/Env/PROCESSOR_ARCHITECTURE}' + \
              ' STRING {STAF/Env/PROCESSOR_ARCHITEW6432}'
          </script>

          <stafcmd name="'STAF local VAR %s' % (request)">
            <location>'local'</location>
            <service>'VAR'</service>
            <request>request</request>
          </stafcmd>

          <if expr="RC in [ STAFRC.Ok ]">
            <script>
              resolvedVarList = STAFResult
            
              if resolvedVarList[0]['rc'] == '0':
                STAXMachProcessorArchitecture = resolvedVarList[0]['result']

              if resolvedVarList[1]['rc'] == '0':
                STAXMachProcessorArchitecture = resolvedVarList[1]['result']
            </script>
          </if>
        </sequence>
      </if>

      <!-- SSL Support is not provided for z/OS or for Windows IA64.  Since the CHECKSUM option
            on a FS QUERY ENTRY request requires SSL to get the checksum, don't run the checksum
            tests if the STAX machine is z/OS or Windows IA64. -->

      <script>
        if ((STAXMachOSType.find('OS/390') == 0) or
            (STAXMachOSType.find('Win') == 0 and STAXMachProcessorArchitecture == 'IA64')):
          STAXMachHasSSL = 0
        else:
          STAXMachHasSSL = 1
      </script>
 
    </sequence>

  </function>


  <!-- ================================================================= -->
  <!-- PingTestMachines - This function pings all the test machines to   -->
  <!--     verify that STAF is up and running on all of them.  If it's   -->
  <!--     not running on one or more machines, it terminates the job.   -->
  <!-- ================================================================= -->

  <function name="PingTestMachines" scope="local">
    <sequence>

      <message>'Making sure that all TestMachines are running STAF'</message>

      <!-- Make sure that all of the test machines can be sent STAF commands -->

      <call function="'STAXUtilWaitForSTAF'">[TestMachines, 60]</call>

      <script>[rc, result] = STAXResult</script>

      <call function="'STAXUtilCheckSuccess'">
        { 'result': rc == 0,
          'failMsg': 'STAXUtilWaitForSTAF failed.  RC=%s Result=%s' % (rc, result),
          'sendToMonitor': 1,
          'recordStatus': 1 }
      </call>

      <if expr="rc != 0">
        <terminate block="'main'"/>
      </if>

    </sequence>
  </function>

  <!-- ================================================================= -->
  <!-- GatherInfo - This function retrieves information about the        -->
  <!--              system we are testing.                               -->
  <!-- ================================================================= -->

  <function name="GatherInfo">
    <sequence>

      <message>'Gathering information about machine %s' % TestMach</message>
      
      <!-- Resolve the values of various STAF variables on the test machine. -->

      <script>
          request = 'RESOLVE SYSTEM STRING {STAF/Config/STAFRoot} ' + \
            ' STRING {STAF/DataDir} STRING {STAF/Config/OS/Name}' + \
            ' STRING {STAF/Config/Machine} STRING {STAF/Config/MachineNickname}' + \
            ' STRING {STAF/Config/OS/MajorVersion} STRING {STAF/Config/OS/MinorVersion}'
      </script>

      <stafcmd name="'STAF %s VAR %s' % (TestMach, request)">
        <location>TestMach</location>
        <service>'VAR'</service>
        <request>request</request>
      </stafcmd>

      <if expr="RC not in [ STAFRC.Ok, STAFRC.VariableDoesNotExist ]">
        <log message="1">
          'ERROR: STAF %s VAR %s failed with RC=%s STAFResult=%s' % (TestMach, request, RC, STAFResult)
        </log>
      </if>

      <script>
        resolvedVarList = STAFResult
            
        if resolvedVarList[0]['rc'] == '0':
          TestMachSTAFRoot = resolvedVarList[0]['result']

        if resolvedVarList[1]['rc'] == '0':
          TestMachUserDataDir = resolvedVarList[1]['result'] + '/user'

        if resolvedVarList[2]['rc'] == '0':
          TestMachOSType = resolvedVarList[2]['result']

        if resolvedVarList[3]['rc'] == '0':
          TestMachName = resolvedVarList[3]['result']

        if resolvedVarList[4]['rc'] == '0':
          TestMachNickname = resolvedVarList[4]['result']
          
        if resolvedVarList[5]['rc'] == '0':
          TestMachOSMajorVersion = resolvedVarList[5]['result']
       
        if resolvedVarList[6]['rc'] == '0':
          TestMachOSMinorVersion = resolvedVarList[6]['result']
      </script>

      <!-- Submit a MISC WHOAMI request to the TestMach to get the endpoint for the
            STAX machine and to determine if the test machine is the local STAX machine -->

      <stafcmd>
        <location>TestMach</location>
        <service>'MISC'</service>
        <request>'WHOAMI'</request>
      </stafcmd>
      
      <script>failMessage = 'STAF %s MISC WHOAMI' % (TestMach)</script>
      <call function="'check-stafcmd'"/>

      <if expr="RC == 0">
        <sequence>
          <script>
            STAXEndpoint = STAFResult['endpoint']
            testMachineIsLocal = 0
          </script>

          <if expr="STAFResult['isLocalRequest'] == 'Yes'">
            <sequence>
              <script>testMachineIsLocal = 1</script>
              <log message="1">'Test machine %s is the local machine' % (TestMachName)</log>
            </sequence>
          </if>

        </sequence>
      </if>

      <script>
        # Some versions of STAF don't provide Java support (e.g. FreeBSD 4.1.0)
        # Set this TestMachJavaSupport to 0 to not perform tests that require
        # STAF Java support
        if TestMachOSType == 'FreeBSD' and TestMachOSMajorVersion.find('4') == 0:
          TestMachJavaSupport = 0
        else:
          TestMachJavaSupport = 1.
      </script>
      
      <!-- On Windows, try to determine the processor architecture -->

      <if expr="TestMachOSType.find('Win') == 0">
        <sequence>

          <script>
            TestMachProcessorArchitecture = 'i386'
            request = 'RESOLVE SYSTEM STRING {STAF/Env/PROCESSOR_ARCHITECTURE}' + \
              ' STRING {STAF/Env/PROCESSOR_ARCHITEW6432}'
          </script>

          <stafcmd name="'STAF %s VAR %s' % (TestMach, request)">
            <location>TestMach</location>
            <service>'VAR'</service>
            <request>request</request>
          </stafcmd>
          
          <if expr="RC in [ STAFRC.Ok ]">
            <script>
              resolvedVarList = STAFResult

              if resolvedVarList[0]['rc'] == '0':
                TestMachProcessorArchitecture = resolvedVarList[0]['result']

              if resolvedVarList[1]['rc'] == '0':
                TestMachProcessorArchitecture = resolvedVarList[1]['result']
            </script>
          </if>

        </sequence>
      </if>

      <!-- SSL Support is not provided for z/OS or for Windows IA64.  Since the CHECKSUM option
            on a FS QUERY ENTRY request requires SSL to get the checksum, don't run the checksum
            tests if the test machine is z/OS or Windows IA64. -->

      <script>
        if ((TestMachOSType.find('OS/390') == 0) or
            (TestMachOSType.find('Win') == 0 and TestMachProcessorArchitecture == 'IA64')):
          TestMachHasSSL = 0
        else:
          TestMachHasSSL = 1
      </script>

      <script>
        # Set the name of a unique directory on the STAX (local) machine for each test machine
        # Need to check if TestMach contains any characters that are invalid in a file name
        # on any operating system, such as:  @ \ / : * ? " &lt; > |  on Windows if the TestMach is
        # tcp://machine.austin.ibm.com@6599) and replace these invalid characters with
        # valid characters (e.g. '-').
        
        theTestMachine = TestMach.replace(':', '-')
        theTestMachine = theTestMachine.replace('/', '-')
        theTestMachine = theTestMachine.replace('@', '-')
        theTestMachine = theTestMachine.replace('\\', '-')   # Should not ever contain \ but...
        theTestMachine = theTestMachine.replace('*', '-')   # Should not ever contain * but...
        theTestMachine = theTestMachine.replace('?', '-')   # Should not ever contain ? but...
        theTestMachine = theTestMachine.replace('"', '-')   # Should not ever contain " but...
        theTestMachine = theTestMachine.replace('&lt;', '-')   # Should not ever contain &lt; but...
        theTestMachine = theTestMachine.replace('>', '-')   # Should not ever contain a > but...
        theTestMachine = theTestMachine.replace('|', '-')   # Should not ever contain a | but...
        STAXMachTestDir = '%s/tmp/%s' % (STAXMachDataDir, theTestMachine)

        # Set the shell for the test machine
        if (TestMachOSType.find('Win9') == 0 or TestMachOSType.find('WinM') == 0):
            TestMachShell = 'command.com /c %c'
        elif TestMachOSType.find('Win') == 0 or TestMachOSType.find('Unknown Win') == 0:
            TestMachShell = 'cmd.exe /c %c'
        else:
            TestMachShell = '/bin/sh -c %C'
      </script>


      <!-- Get the current date and time on the test machine -->

      <stafcmd>
        <location>TestMach</location>
        <service>'MISC'</service>
        <request>'WHOAREYOU'</request>
      </stafcmd>

      <if expr="RC == 0">
        <script>
          TestMachJobStartTimestamp = STAFResult['currentTimestamp']
          TestMachJobStartDate = STAFResult['currentTimestamp'][0:8]
          TestMachJobStartTime = STAFResult['currentTimestamp'][9:]
        </script>
        <else>
          <script>
            TestMachJobStartDate = STAXJobStartDate
            TestMachJobStartTime = STAXJobStartTime
          </script>
        </else>
      </if>

      <call function="'STAXUtilLogAndMsg'">
        'Test Machine: %s\n  OS type: %s\n  OS Major Version: %s\n  OS Minor Version: %s\n  STAFRoot: %s\n  DataDir/user: %s\n  Shell: %s\n  Machine: %s\n  MachineNickname: %s\n  STAXEndpoint: %s\n  Has SSL: %s\n  Current Timestamp: %s' % \
          (TestMach, TestMachOSType, TestMachOSMajorVersion, TestMachOSMinorVersion, TestMachSTAFRoot, TestMachUserDataDir, TestMachShell, TestMachName, TestMachNickname, STAXEndpoint, TestMachHasSSL, TestMachJobStartTimestamp)
      </call>

    </sequence>
  </function>

  <function name="InitTestMachine" requires="check-stafcmd">
    <sequence>

      <message>
        'Preparing to run tests on machine %s' % (TestMach)
      </message>

      <!-- Delete any Mutex Semaphores left over from a previous run -->

      <script>
        SemMutexList = [ # Internal services

                         'STAFTest/DELAY', 'STAFTest/ECHO',
                         'STAFTest/DIAG',  'STAFTest/SHUTDOWN',
                         'STAFTest/FS',    'STAFTest/HANDLE',
                         'STAFTest/HELP',  'STAFTest/MISC',
                         'STAFTest/PING',  'STAFTest/PROCESS',
                         'STAFTest/QUEUE', 'STAFTest/SEM',
                         'STAFTest/SERVICE', 'STAFTest/TRUST',
                         'STAFTest/TRACE', 'STAFTest/LIFECYCLE',
                         'STAFTest/DEVICE', 'STAFTest/EXECPROXY',
                         'STAFTest/FTP',   'STAFTest/INSTALL',
                         'STAFTest/VAR',   'STAFTest/ZIP',
                         'STAFTest/LOG', 'STAFTest/MONITOR',
                         'STAFTest/RESPOOL', 'STAFTest/OTHER',
                         'STAFTest/DEVICE_C++', 'STAFTest/DEVICE_Java',
                         'STAFTest/STAX', 'STAFTest/EVENT'
                         ]
      </script>

      <!-- Delete any Mutex Semaphores left over from a previous test run -->

      <iterate var="mutexName" in="SemMutexList">
        <sequence>
          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'RELEASE MUTEX %s FORCE' % mutexName</request>
          </stafcmd>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'DELETE MUTEX %s' % mutexName</request>
          </stafcmd>

          <script>failMessage = 'Deleting %s' % mutexName</script>
          <if expr="RC not in [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ]">
            <call function="'check-stafcmd'"/>
          </if>
        </sequence>
      </iterate>
      
      <!-- Clean-up the event semaphores used by this test -->
      <iterate var="i" in="range(1, 9)">
        <sequence>
          <stafcmd name="'Delete Event Semaphore STAFTest/Respool/Step%s' % (i)">
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'DELETE EVENT STAFTest/Respool/Step%s' % (i)</request>
          </stafcmd>
        </sequence>
      </iterate>

      <!-- Remove any services added from a previous test run -->

      <stafcmd>
        <location>TestMach</location>
        <service>'SERVICE'</service>
        <request>'REMOVE SERVICE STAFTest'</request>
      </stafcmd>

      <!-- Delete any resource pools left over from a previous test -->

      <stafcmd>
        <location>TestMach</location>
        <service>ResPoolService</service>
        <request>'DELETE POOL STAFTest CONFIRM FORCE'</request>
      </stafcmd>

      <stafcmd>
        <location>TestMach</location>
        <service>ResPoolService</service>
        <request>'DELETE POOL STAFTestGC CONFIRM FORCE'</request>
      </stafcmd>
      
      <if expr="not TestScopes or 'PING' in TestScopes">
        <testcase name="'PING'">
          <sequence>
            <!-- Make sure that a ping to a machine that's not running STAF returns a 16 -->
            <message>
              'Testing machine: %s service: PING request: PING tcp://ausvmr.austin.ibm.com' % \
              (TestMach)
            </message>

            <stafcmd>
              <location>'tcp://ausvmr.austin.ibm.com'</location>
              <service>'PING'</service>
              <request>'PING'</request>
            </stafcmd>

            <call function="'STAXUtilCheckSuccess'">
              { 'result': RC == STAFRC.NoPathToMachine,
                'failMsg': 'Pinging tcp://ausvmr.austin.ibm.com on machine %s did not get RC=%s.  RC=%s Result=%s' % \
                          (TestMach, STAFRC.NoPathToMachine, RC, STAFResult),
                'sendToMonitor': 1,
                'recordStatus': 1 }
            </call>
          </sequence>
        </testcase>
      </if>

      <if expr="not TestScopes or 'SERVICE' in TestScopes">
        <sequence>

          <!-- Resolve the name specified for EventJarFile (in case it contains STAF variables) -->

          <stafcmd>
            <location>'local'</location>
            <service>'VAR'</service>
            <request>'RESOLVE STRING %s' % EventJarFile</request>
          </stafcmd>

          <script>failMessage = 'Resolving %s' % EventJarFile</script>
          <if expr="RC == STAFRC.Ok">
            <script>resEventJarFile = STAFResult</script>
          </if>

          <script>
            # Locations to look for Event service jar files
            EventJars = [
                         resEventJarFile,
                         '%s/STAFEvent.jar' % (AutomationTestDir),
                         'C:/dev/sf/rel/win32/staf/retail/lib/STAFEvent.jar',
                         'D:/dev/sf/rel/win32/staf/retail/lib/STAFEvent.jar'
                       ]

            EventJarFileFound = 0;

            for jarFile in EventJars:
              try:
                file = open(jarFile)
                EventJarFileFound = 1
                EventJarFile = jarFile
                break
              except IOError:
                EventJarFileFound = 0
          </script>

          <if expr="EventJarFileFound">
            <log message="1">'EventJarFile = %s' % jarFile</log>
            <else>
              <log message="1">
                'Could not find the STAFEvent.jar file specified in EventJars = %s' % EventJars
              </log>
            </else>
          </if>

        </sequence>
      </if>

      <if expr="not TestScopes or 'DEVICE_C++' in TestScopes or 'DEVICE_Java' in TestScopes">
        <sequence>

          <!-- Resolve the name specified for DeviceServiceJarFile (in case it contains STAF variables) -->

          <stafcmd>
            <location>'local'</location>
            <service>'VAR'</service>
            <request>'RESOLVE STRING %s' % DeviceServiceJarFile</request>
          </stafcmd>

          <script>failMessage = 'Resolving %s' % DeviceServiceJarFile</script>
          <if expr="RC == STAFRC.Ok">
            <script>resDeviceServiceJarFile = STAFResult</script>
          </if>

          <script>
            # Locations to look for DEVICE service jar files
            deviceJars = [
                           resDeviceServiceJarFile,
                           '%s/STAFServiceDevice.jar' % (AutomationTestDir),
                           'C:\\automation\\test\\STAFServiceDevice.jar',
                           'C:/dev/sf/rel/win32/staf/retail/lib/STAFDeviceService.jar',
                           'D:/dev/sf/rel/win32/staf/retail/lib/STAFDeviceService.jar'
                         ]

            DeviceJarFileFound = 0;

            for jarFile in deviceJars:
              try:
                file = open(jarFile)
                DeviceJarFileFound = 1
                DeviceServiceJarFile = jarFile
                break
              except IOError:
                DeviceJarFileFound = 0
          </script>

          <if expr="DeviceJarFileFound == 1">
            <log message="1">'DeviceServiceJarFile = %s' % DeviceServiceJarFile</log>
            <else>
              <log message="1">
                'Could not find the STAFDeviceService.jar file specified in DeviceJars = %s' % deviceJars
              </log>
            </else>
          </if>

        </sequence>
      </if>

    </sequence>
  </function>

  <function name="TermTestMachine">
    <sequence>

      <!-- If the test machine is local and if the HANDLE service tests were
           run, delete the static handle named "mySTAFTest" if it exists -->

      <if expr="testMachineIsLocal">
        <if expr="(not TestScopes) or ('HANDLE' in TestScopes)">
          <sequence>
            <!-- Get its handle number -->
            <stafcmd name="'Delete directory %s on STAX machine' % (STAXMachTestDir)">
              <location>'local'</location>
              <service>'HANDLE'</service>
              <request>'LIST HANDLES STATIC NAME mySTAFTest'</request>
            </stafcmd>

            <if expr="RC == STAFRC.Ok">
              <iterate var="handleMap" in="STAFResult">
                <sequence>
                  <stafcmd name="'Delete directory %s on STAX machine' % (STAXMachTestDir)">
                    <location>'local'</location>
                    <service>'HANDLE'</service>
                    <request>'DELETE HANDLE %s' % (handleMap['handle'])</request>
                  </stafcmd>
                </sequence>
              </iterate>
            </if>
          </sequence>
        </if>
      </if>

      <if expr="not TestScopes or 'FS' in TestScopes">
        <sequence>

          <stafcmd name="'Delete directory %s on STAX machine' % (STAXMachTestDir)">
            <location>'local'</location>
            <service>'FS'</service>
            <request>'DELETE ENTRY %s RECURSE CONFIRM' % (STAXMachTestDir)</request>
          </stafcmd>
           <!-- XXX: Remove
           <stafcmd>
              <location>'local'</location>
              <service>'FS'</service>
           <request>'DELETE ENTRY %s CONFIRM' % textFileName1</request>
           </stafcmd>
           <stafcmd>
              <location>'local'</location>
              <service>'FS'</service>
           <request>'DELETE ENTRY %s CONFIRM' % textFileName2</request>
           </stafcmd>
           <stafcmd>
              <location>'local'</location>
              <service>'FS'</service>
           <request>'DELETE ENTRY %s CONFIRM' % textFileName3</request>
           </stafcmd>
           <stafcmd>
              <location>'local'</location>
              <service>'FS'</service>
           <request>'DELETE ENTRY %s CONFIRM' % emptyTextFileName</request>
           </stafcmd>
           -->
          <!-- Clean-up the event semaphores used by this test -->
          <iterate var="i" in="range(1, 9)">
            <sequence>
              <stafcmd name="'Reset Event Semaphore STAFTest/Respool/Step%s' % (i)">
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'RESET EVENT STAFTest/Respool/Step%s' % (i)</request>
              </stafcmd>
              <stafcmd name="'Delete Event Semaphore STAFTest/Respool/Step%s' % (i)">
                <location>TestMach</location>
                <service>'SEM'</service>
                <request>'DELETE EVENT STAFTest/Respool/Step%s' % (i)</request>
              </stafcmd>
            </sequence>
          </iterate>
        </sequence>
      </if>

      <testcase name="'PROCESS'">
        <sequence>
          <!-- Stop the process with handle QHandle that's been running while
               this job has been running -->

          <script>
            stopUsing = ''
          </script>

          <message>
            'Testing machine: %s service: PROCESS request: STOP HANDLE %s%s' % (TestMach, QHandle, stopUsing)
          </message>

          <!-- Stop the process with handle QHandle -->
          <stafcmd>
            <location>TestMach</location>
            <service>'PROCESS'</service>
            <request>'STOP HANDLE %s%s' % (QHandle, stopUsing)</request>
          </stafcmd>

          <if expr="RC == STAFRC.NoPathToMachine">
            <return/>
          </if>

          <call function="'STAXUtilCheckSuccess'">
            { 'result': RC in [STAFRC.Ok, STAFRC.HandleDoesNotExist],
              'failMsg': 'PROCESS STOP HANDLE %s failed on %s.  RC=%s Result=%s' % \
                         (QHandle, TestMach, RC, STAFResult),
              'sendToMonitor': 1,
              'recordStatus': 1 }
          </call>

          <stafcmd>
            <location>TestMach</location>
            <service>'PROCESS'</service>
            <request>'FREE HANDLE %s' % (QHandle)</request>
          </stafcmd>

        </sequence>
      </testcase>

      <!-- Delete any Mutex Semaphores from this run -->

      <message>
        'Performing test cleanup on test machine %s' % (TestMach)
      </message>

      <iterate var="mutexName" in="SemMutexList">
        <sequence>

          <stafcmd>
            <location>TestMach</location>
            <service>'SEM'</service>
            <request>'DELETE MUTEX %s' % mutexName</request>
          </stafcmd>

          <script>failMessage = 'Deleting %s' % mutexName</script>
          <if expr="RC not in [ STAFRC.Ok, STAFRC.SemaphoreDoesNotExist ]">
            <call function="'check-stafcmd'"/>
          </if>
        </sequence>
      </iterate>

    </sequence>
  </function>

  <!-- ================================================================= -->
  <!-- run-standard-test - This function executes a standard STAF test   -->
  <!-- ================================================================= -->

  <function name="run-standard-test">
    <sequence>

      <message>
        'Testing machine: %s service: %s request: %s' % (
          TestMach, thisTest[1], thisTest[2])
      </message>

      <script>failMsg = ''</script>

      <timer duration="stafcmd_timeout">
        <sequence>

          <stafcmd>
            <location>TestMach</location>
            <service>thisTest[1]</service>
            <request>thisTest[2]</request>
          </stafcmd>

          <if expr="RC not in thisTest[3]">
            <sequence>
              <script>
                failMsg = 'Service: %s, Request: %s - RC (%s) not in %s.  STAFResult=%s' % \
                        (thisTest[1], thisTest[2], RC, thisTest[3], STAFResult)
              </script>
              <if expr="RC == STAFRC.NoPathToMachine">
                <sequence>
                  <!-- XXX: Terminate the job because this means STAF died on the test machine -->
                  <call function="'STAXUtilCheckSuccess'">
                    { 'result': failMsg == '', 'failMsg': failMsg,
                      'sendToMonitor': 1, 'recordStatus': 1  }
                  </call>
                  <log message="1">'ERROR: STAFProc appears to have died on test machine %s' % (TestMach)</log>
                  <terminate block="'main'"/>
                </sequence>
              </if>
            </sequence>
            <elseif expr="thisTest[4] and not re.match(thisTest[4], STAFResult)">
              <script>
                failMsg = 'Service: %s, Request: %s - Grep error\nmatching:\n%s\nwith:\n%s' % \
                      (thisTest[1], thisTest[2], thisTest[4], STAFResult)
              </script>
            </elseif>
            <elseif expr="not thisTest[4] and len(thisTest) >= 6 and not eval(thisTest[5])">
              <script>
                failMsg = 'Service: %s, Request: %s - Unexpected STAFResult\nThe following expression evaluated to false:\n%s\nSTAFResult:\n%s' % \
                       (thisTest[1], thisTest[2], thisTest[5], STAFResult)
              </script>
            </elseif>
            <!-- XXX: 
            <elseif expr="not thisTest[4] and len(thisTest) >= 6">
              <sequence>
                <script>
                  evalError = 0
                  try:
                    eval(thisTest[5])
                  except:
                    evalError = 1
                </script>
                <if expr="evalError == 1">
                  <sequence>
                    <script>
                      failMsg = 'Service: %s, Request: %s - Evaluating the expected STAFResult failed\nExpected STAFResult:\n%s\nSTAFResult: %s' % \
                             (thisTest[1], thisTest[2], thisTest[5], STAFResult)
                    </script>
                  </sequence>
                  <elseif expr="not eval(thisTest[5])">
                    <script>
                      failMsg = 'Service: %s, Request: %s - Unexpected STAFResult\nThe following expression evaluated to false:\n%s\nSTAFResult:\n%s' % \
                             (thisTest[1], thisTest[2], thisTest[5], STAFResult)
                    </script>
                  </elseif>
                  <elseif expr="len(thisTest) >= 7">
                    <script>
                      exec(thisTest[6])
                    </script>
                  </elseif>
                </if>
              </sequence>
            </elseif>
            -->
            <elseif expr="len(thisTest) >= 7">
              <script>
                exec(thisTest[6])
              </script>
            </elseif>
          </if>

        </sequence>
      </timer>

      <if expr="RC == 1">
        <script>
          failMsg = 'Request did not complete within timeout value %s.  Service: %s, Request: %s' % \
              (stafcmd_timeout, thisTest[1], thisTest[2])
        </script>
      </if>

      <call function="'STAXUtilCheckSuccess'">
        { 'result': failMsg == '', 'failMsg': failMsg,
          'sendToMonitor': 1, 'recordStatus': 1  }
      </call>

    </sequence>
  </function>

  <!-- ================================================================= -->
  <!-- run-tests - This function runs the testcases on a given system    -->
  <!-- ================================================================= -->

  <function name="RunTests" requires="run-standard-test">
    <sequence>

      <if expr="len(allTests) == 0">
        <return/>
      </if>

      <iterate var="thisTest" in="allTests">
        <sequence>

          <script>
            TestType = thisTest[0]
            TestScope = None

            if string.find(thisTest[0], ':') >= 0:
              [ TestType, TestScope ] = string.split(thisTest[0], ':')
          </script>

          <if expr="TestType == 'STD'">
            <testcase name="TestScope">
              <call function="'run-standard-test'"/>
            </testcase>
            <else>
              <message>'Unknown test type: %s' % thisTest[0]</message>
            </else>
          </if>

        </sequence>
      </iterate>

    </sequence>
  </function>

  <!-- ================================================================= -->
  <!-- DoAll - This function is the main function called and drives the  -->
  <!--         overall build process.                                    -->
  <!-- ================================================================= -->

  <function name="DoAll"
            requires="InitJob GatherInfo TermJob InitTestMachine InitTests RunTests TermTestMachine">

    <testcase name="'TestSTAF'">
      <sequence>

        <script>
          import time
          starttime = time.time() # record starting time
        </script>

        <call function="'InitJob'"/>

        <try>
        <paralleliterate var="TestMach" in="TestMachines">
          <sequence>

            <call function="'GatherInfo'"/>

            <script>
              # Replace any '.'s in test machine name with '-'s so that this
              # modified machine name can be used in block and testcase names
              # without creating a hierarchy of blocks and testcases (e.g. blocks
              # for lucas, then austin, then ibm, then com, since a '.' in a block
              # name (or testcase name) means a new block (or a new testcas).
              TestMach_NoDots = TestMach.replace('.', '-')
            </script>

            <message>'TestMach_NoDots = %s' % (TestMach_NoDots) </message>

            <block name="TestMach_NoDots">
              <sequence>

                <testcase name="TestMachOSType + '.' + TestMach_NoDots">
                  <sequence>

                    <call function="'STAXUtilLogAndMsg'">
                      'STAF Testing started on machine %s' % TestMach
                    </call>

                    <script>
                      QHandle = STAXGlobal(-1)
                      
                      # Use the 'default' mode on Windows so that the process can be stopped when the test
                      # completes as you can't really stop a process on Windows that was started in shell mode
                      if TestMachOSType.find('Win') == 0 or TestMachOSType.find('Unknown Win') == 0:
                        commandMode = 'default'
                      else:
                        commandMode = 'shell'
                    </script>

                    <!-- Start a process on the TestMach that runs in parallel while the
                         tests run in order to use its handle to check its queue, etc.
                         Currently running this process for 5 hours so this assumes
                         STAFTest will complete within 5 hours.  -->

                    <process name="'STAFTest Delay Process'">
                      <location>TestMach</location>
                      <command mode="commandMode">'STAF local DELAY DELAY 5h'</command>
                      <title>'STAFTest Delay Process'</title>
                      <workload>'STAFTest'</workload>
                      <var>'STAFVar=AutoVar'</var>
                      <env>'STAFEnv=AutoEnv'</env>
                      <focus mode="'Minimized'"/>
                      <statichandlename>'STAFTest'</statichandlename>
                      <process-action>
                        <sequence>
                          <script>QHandle.set(STAXProcessHandle)</script>
                          <try>
                            <sequence>
                              <call function="'InitTestMachine'"/>
                              <call function="'InitTests'"/>
                              <call function="'RunTests'"/>
                            </sequence>
                            <finally>
                              <block name="'Finally_%s' % TestMach_NoDots">
                                <call function="'TermTestMachine'"/>
                              </block>
                            </finally>
                          </try>
                        </sequence>
                      </process-action>
                    </process>

                    <testcase name="'PROCESS'">
                      <sequence>

                        <message>
                          'Testing machine: %s service: PROCESS request: STOP HANDLE %s' % (TestMach, QHandle)
                        </message>

                        <!-- Stop the process with handle QHandle again to verify get RC 5 or 11 -->
                        <stafcmd>
                          <location>TestMach</location>
                          <service>'PROCESS'</service>
                          <request>'STOP HANDLE %s' % QHandle</request>
                        </stafcmd>

                        <call function="'STAXUtilCheckSuccess'">
                          { 'result': RC in [STAFRC.HandleDoesNotExist, STAFRC.ProcessAlreadyComplete],
                            'failMsg': 'PROCESS STOP HANDLE %s RC not 5 or 11 on %s.  RC=%s Result=%s' % \
                                       (QHandle, TestMach, RC, STAFResult),
                            'sendToMonitor': 1,
                            'recordStatus': 1 }
                        </call>

                      </sequence>
                    </testcase>

                    <call function="'STAXUtilLogAndMsg'">
                      'STAF Testing completed on machine %s' % TestMach
                    </call>

                  </sequence>
                </testcase>

              </sequence>
            </block>

          </sequence>
        </paralleliterate>

        <finally>
          <block name="'Finally Block for Job'">
            <sequence>
              <!-- Clean up the STAX machine -->
              <call function="'TermJob'"/>

              <!-- Query the test results -->
            
              <script>jobResult = 'Failed'</script>

              <call function="'STAXUtilQueryAllTests'"/>

              <script>[rc, result, totals, testcases] = STAXResult</script>

              <message>
                'STAXUtilQueryAllTests testcase map:\n%s' % (testcases)
              </message>

              <if expr="rc == 0">
                <sequence>
                  <script>
                  [totalTests, totalPasses, totalFails] = totals
                  jobResult = {'fails': totalFails, 'passes': totalPasses }

                  activeTests = []
                  for testName in testcases.keys():
                    testResultList = testcases[testName]
                    if testResultList[2] == '&lt;Pending>':
                      activeTests.append(testName + ': ' + testResultList[2])
                </script>
                <message>
                  'Tests that are still running: %s' % (activeTests)
                </message>
                <log message="1">'Total Passes: %s,  Total Fails: %s' % (totalPasses, totalFails)</log>
              </sequence>
              <else>
                <call function="'STAXUtilLogAndMsg'">
                  'STAXUtilQueryAllTests failed. RC=%s Result=%s' % (rc, result)
                </call>
              </else>
            </if>

            <call function="'STAXUtilQueryTest'">'TestSTAF'</call>

            <script>[rc, result, totals] = STAXResult</script>

            <if expr="rc == 0">
              <sequence>
                <script>[passes, fails, elapsedTime, numStarts] = totals</script>
                <message>'STAXUtilQueryTest TestSTAF results: %s' % (totals)</message>
                <if expr="fails > 0">
                  <call function="'STAXUtilLogAndMsg'">
                    'Testcase: %s, Passes: %s, Fails: %s, ElapsedTime: %s, NumStarts: %s' % \
                    (testName, passes, fails, elapsedTime, numStarts)
                  </call>
                </if>
              </sequence>
              <else>
                <call function="'STAXUtilLogAndMsg'">
                  'STAXUtilQueryTest TestSTAF fails.  RC=%s Result=%s' % (rc, result)
                </call>
              </else>
            </if>

            <!-- Difference between current time and starttime yields time elapsed -->
            <script>elapsed = time.time() - starttime</script>

            <call function="'STAXUtilLogAndMsg'">
              'STAF Testing completed in %.0f seconds' % (elapsed)
            </call>

            <return>jobResult</return>
            </sequence>
          </block>
        </finally>

        </try>

      </sequence>
    </testcase>
  </function>

  <!-- ================================================================= -->
  <!-- TermJob - This function cleans up the STAX machine after the job. -->
  <!-- ================================================================= -->

  <function name="TermJob">
    <sequence>
    
      <nop/>

    </sequence>
  </function>

</stax>
